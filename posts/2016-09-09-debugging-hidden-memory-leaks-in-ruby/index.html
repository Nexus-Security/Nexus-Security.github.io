<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="In 2015 I wrote about some of the tooling Ruby provides for diagnosing managed memory leaks. The article mostly focused on the easy managed leaks.
This article covers tools and tricks you can use to attack leaks that you can not easily introspect in Ruby. In particular I will discuss mwrap, heaptrack, iseq_collector and chap.
An unmanaged memory leak This little program leaks memory by calling malloc directly. It starts off consuming 16MB and finishes off consuming 118MB of RSS."><title>Debugging hidden memory leaks in Ruby</title><link rel=canonical href=https://Nexus-Security.github.io/posts/2016-09-09-debugging-hidden-memory-leaks-in-ruby/><link rel=stylesheet href=/scss/style.min.450926226e724574a6b936335ea06111f8aeb253d932c86cb2cc807341cd2889.css><meta property="og:title" content="Debugging hidden memory leaks in Ruby"><meta property="og:description" content="In 2015 I wrote about some of the tooling Ruby provides for diagnosing managed memory leaks. The article mostly focused on the easy managed leaks.
This article covers tools and tricks you can use to attack leaks that you can not easily introspect in Ruby. In particular I will discuss mwrap, heaptrack, iseq_collector and chap.
An unmanaged memory leak This little program leaks memory by calling malloc directly. It starts off consuming 16MB and finishes off consuming 118MB of RSS."><meta property="og:url" content="https://Nexus-Security.github.io/posts/2016-09-09-debugging-hidden-memory-leaks-in-ruby/"><meta property="og:site_name" content="ZYChimne"><meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:published_time" content="2019-10-19T08:47:00+01:00"><meta property="article:modified_time" content="2019-10-19T08:47:00+01:00"><meta name=twitter:title content="Debugging hidden memory leaks in Ruby"><meta name=twitter:description content="In 2015 I wrote about some of the tooling Ruby provides for diagnosing managed memory leaks. The article mostly focused on the easy managed leaks.
This article covers tools and tricks you can use to attack leaks that you can not easily introspect in Ruby. In particular I will discuss mwrap, heaptrack, iseq_collector and chap.
An unmanaged memory leak This little program leaks memory by calling malloc directly. It starts off consuming 16MB and finishes off consuming 118MB of RSS."></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hue825486955cd7c56d95e38b4bd2a8e3c_229979_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>ZYChimne</a></h1><h2 class=site-description>Computer Science, Wuhan University</h2></div></header><ol class=social-menu><li><a href=https://github.com/ZYChimne target=_blank title=GitHub><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com/ZChimne target=_blank title=Twitter><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/about-me/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>About Me</span></a></li><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></div></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/posts/2016-09-09-debugging-hidden-memory-leaks-in-ruby/>Debugging hidden memory leaks in Ruby</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Oct 19, 2019</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>12 minute read</time></div></footer></div></header><section class=article-content><p>In 2015 I wrote about some of the tooling Ruby provides for <a class=link href=https://samsaffron.com/archive/2015/03/31/debugging-memory-leaks-in-ruby target=_blank rel=noopener>diagnosing managed memory leaks</a>. The article mostly focused on the easy managed leaks.</p><p>This article covers tools and tricks you can use to attack leaks that you can not easily introspect in Ruby. In particular I will discuss mwrap, heaptrack, iseq_collector and chap.</p><h3 id=an-unmanaged-memory-leak>An unmanaged memory leak</h3><p>This little program leaks memory by calling malloc directly. It starts off consuming 16MB and finishes off consuming 118MB of RSS. The code allocates 100k blocks of 1024 bytes and de-allocates 50 thousand of them.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> require &#39;fiddle&#39; require &#39;objspace&#39; def usage rss = `ps -p #{Process.pid} -o rss -h`.strip.to_i * 1024 puts &#34;RSS: #{rss / 1024} ObjectSpace size #{ObjectSpace.memsize_of_all / 1024}&#34; end def leak_memory pointers = [] 100_000.times do i = Fiddle.malloc(1024) pointers &lt;&lt; i end 50_000.times do Fiddle.free(pointers.pop) end end usage # RSS: 16044 ObjectSpace size 2817 leak_memory usage # RSS: 118296 ObjectSpace size 3374 
</span></span></code></pre></td></tr></table></div></div><p>Even though our RSS is 118MB, our Ruby object space is only aware of 3MB, introspection wise we have very little visibility of this very large memory leak.</p><p>A real world example of such a leak is <a class=link href=http://www.be9.io/2015/09/21/memory-leak/ target=_blank rel=noopener>documented by Oleg Dashevskii</a>, it is an excellent article worth reading.</p><h3 id=enter-mwrap>Enter Mwrap</h3><p><a class=link href=https://80x24.org/mwrap/README.html target=_blank rel=noopener>Mwrap</a> is a memory profiler for Ruby that keeps track of all allocations by intercepting malloc and family calls. It does so by intercepting the real calls that allocate and free memory using <a class=link href=https://blog.jessfraz.com/post/ld_preload/ target=_blank rel=noopener>LD_PRELOAD</a>. It uses <a class=link href=https://liburcu.org/ target=_blank rel=noopener>liburcu</a> for bookkeeping and is able to keep track of allocation and de-allocation counts per call-site for both C code and Ruby. It is reasonably lightweight and will approximately double the RSS for the program being profiled and approximately halve the speed.</p><p>It differs from many other libraries in that it is very lightweight and Ruby aware. It track locations in Ruby files and is not limited to C level backtrackes valgrind+masif and similar profilers show. This makes isolating actual sources of an issue much simpler.</p><p>Usage involves running an application via the mwrap wrapper, it inject the LD_PRELOAD environment and execs the Ruby binary.</p><p>Let’s append mwrap to our above script:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>require &#39;mwrap&#39; def report_leaks results = [] Mwrap.each do |location, total, allocations, frees, age_total, max_lifespan| results &lt;&lt; [location, ((total / allocations.to_f) * (allocations - frees)), allocations, frees] end results.sort! do |(_, growth_a), (_, growth_b)| growth_b &lt;=&gt; growth_a end results[0..20].each do |location, growth, allocations, frees| next if growth == 0 puts &#34;#{location} growth: #{growth.to_i} allocs/frees (#{allocations}/#{frees})&#34; end end GC.start Mwrap.clear leak_memory GC.start # Don&#39;t track allocations for this block Mwrap.quiet do report_leaks end 
</span></span></code></pre></td></tr></table></div></div><p>Next we will launch our script with the mwrap wrapper</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>% gem install mwrap % mwrap ruby leak.rb leak.rb:12 growth: 51200000 allocs/frees (100000/50000) leak.rb:51 growth: 4008 allocs/frees (1/0) 
</span></span></code></pre></td></tr></table></div></div><p>Mwrap correctly detected the leak in the above script (50,000 * 1024). Not only it detected it, it isolated the actual line in the script ( <code>i = Fiddle.malloc(1024)</code> ) which caused the leak. It correctly accounted for the <code>Fiddle.free</code> calls.</p><p>It is important to note we are dealing with estimates here, mwrap keeps track of <strong>total</strong> memory allocated at the call-site and then keeps track of de-allocations. However, if you have a single call-site that is allocating memory blocks of different sizes the results can be skewed, we have access to the estimate: <code>((total / allocations) * (allocations - frees))</code></p><p>Additionally, to make tracking down leaks easier mwrap keeps track of <code>age_total</code> which is the sum of the lifespans of every object that was freed, and <code>max_lifespan</code> which is the lifespan of the oldest object in the call-site. If <code>age_total / frees</code> is high, it means the memory growth survives many garbage collections.</p><p>Mwrap has a few helpers that can help you reduce noise. <code>Mwrap.clear</code> will clear all the internal storage. <code>Mwrap.quiet {}</code> will suppress Mwrap tracking for a block of code.</p><p>Another neat feature Mwrap has is that it keeps track of total allocated bytes and total freed bytes. If we remove the clear from our script and run:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>usage puts &#34;Tracked size: #{(Mwrap.total_bytes_allocated - Mwrap.total_bytes_freed) / 1024}&#34; # RSS: 130804 ObjectSpace size 3032 # Tracked size: 91691 
</span></span></code></pre></td></tr></table></div></div><p>This is very interesting cause even though our RSS is 130MB, Mwrap is only seeing 91MB, this demonstrates we have bloated our process. Running without mwrap shows that the process would normally be 118MB so in this simple case accounting is a mere 12MB, the pattern of allocation / deallocation caused fragmentation. Knowing about fragmentation can be quite powerful, in some cases with untuned glibc malloc processes can fragment so much that a very large amount memory consumed in RSS is actually free.</p><h3 id=could-mwrap-isolate-the-old-redcarpet-leak>Could Mwrap isolate the old redcarpet leak?</h3><p>In <a class=link href=http://www.be9.io/2015/09/21/memory-leak/ target=_blank rel=noopener>Oleg’s article</a> he discussed a very thorough way he isolated a very subtle leak in redcarpet. There is lots of detail there. It is critical that you <strong>have instrumentation</strong>. If you are not graphing process RSS you have very little chance at attacking any memory leak.</p><p>Let’s step into a time machine and demonstrate how much easier it can be to use Mwrap for such leaks.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>def red_carpet_leak 100_000.times do markdown = Redcarpet::Markdown.new(Redcarpet::Render::HTML, extensions = {}) markdown.render(&#34;hi&#34;) end end GC.start Mwrap.clear red_carpet_leak GC.start # Don&#39;t track allocations for this block Mwrap.quiet do report_leaks end 
</span></span></code></pre></td></tr></table></div></div><p>Redcarpet version 3.3.2</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>redcarpet.rb:51 growth: 22724224 allocs/frees (500048/400028) redcarpet.rb:62 growth: 4008 allocs/frees (1/0) redcarpet.rb:52 growth: 634 allocs/frees (600007/600000) 
</span></span></code></pre></td></tr></table></div></div><p>Redcarpet version 3.5.0</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>redcarpet.rb:51 growth: 4433 allocs/frees (600045/600022) redcarpet.rb:52 growth: 453 allocs/frees (600005/600000) 
</span></span></code></pre></td></tr></table></div></div><p>Provided you can afford for a process to run at half speed simply re-launching it in production with Mwrap and logging Mwrap output once in a while to a file can identify a broad spectrum of memory leaks.</p><h3 id=a-mysterious-memory-leak>A mysterious memory leak</h3><p>Recently we upgraded Rails to version 6 at Discourse. Overall the experience was extremely positive, performance remained more or less the same, Rails 6 includes some very nice features we get to use (like <a class=link href=https://medium.com/@fxn/zeitwerk-a-new-code-loader-for-ruby-ae7895977e73 target=_blank rel=noopener>Zeitwerk</a>).</p><p>Rails amended the way templates are rendered which required a few backwards compatible changes.</p><p>Fast forward a few days after our upgrade and we noticed RSS for our Sidekiq job runner was climbing.</p><p>Mwrap kept on reporting a sharp incline in memory due to memory being allocated at:</p><p><a class=link href=https://github.com/rails/rails/blob/94fe2430da93daf52f63dbc248dcbdc8e8de2c31/actionview/lib/action_view/template.rb#L341 target=_blank rel=noopener>github.com</a></p><ol start=331><li><code>source.encode!</code></li><li><code># Now, validate that the source we got back from the template</code></li><li><code># handler is valid in the default_internal. This is for handlers</code></li><li><code># that handle encoding but screw up</code></li><li><code>unless source.valid_encoding?</code></li><li><code>raise WrongEncodingError.new(source, Encoding.default_internal)</code></li><li><code>end</code></li><li><code>begin</code></li><li><code>mod.module_eval(source, identifier, 0)</code></li><li><code>rescue SyntaxError</code></li><li><code># Account for when code in the template is not syntactically valid; e.g. if we're using</code></li><li><code># ERB and the user writes &lt;%= foo( %>, attempting to call a helper `foo` and interpolate</code></li><li><code># the result into the template, but missing an end parenthesis.</code></li><li><code>raise SyntaxErrorInTemplate.new(self, original_source)</code></li><li><code>end</code></li><li><code>end</code></li><li><code>def handle_render_error(view, e)</code></li><li><code>if e.is_a?(Template::Error)</code></li></ol><p><code>We initially found this very confusing and kept thinking to ourselves, why is Mwrap complaining? Could it be broken?</code></p><p><code>During the period where memory was climbing the Ruby heaps were not growing in size in a significant manner.</code></p><p><code>2 million slots in the heap are a meager 78MB (40 bytes per slot), strings and arrays can take up more space, but this simply did not explain the enormous memory usage we were seeing. This was confirmed when I ran `rbtrace -p SIDEKIQ_PID -e ObjectSpace.memsize_of_all`.</code></p><p>Where did all the memory go?</p><h3 id=heaptrack>Heaptrack</h3><p><a class=link href=https://github.com/KDE/heaptrack target=_blank rel=noopener>Heaptrack</a> is a memory heap profiler for Linux.</p><p>Milian Wolff does a great job explaining what it is and how it came to be <a class=link href=https://milianw.de/blog/heaptrack-a-heap-memory-profiler-for-linux.html target=_blank rel=noopener>on his blog</a>. He also has several talks about it (<a class=link href="https://www.youtube.com/watch?v=myDWLPBiHn0" target=_blank rel=noopener>1</a>, <a class=link href="https://www.youtube.com/watch?v=YB0QoWI-g8E" target=_blank rel=noopener>2</a>, <a class=link href="https://www.youtube.com/watch?v=-8cOWt7lvUQ" target=_blank rel=noopener>3</a>)</p><p>In essence it is an incredibly efficient native heap profiler that gathers backtraces from a profiled applications using <a class=link href=https://www.nongnu.org/libunwind/ target=_blank rel=noopener>libunwind</a>.</p><p>It is significantly faster than <a class=link href=http://valgrind.org/docs/manual/ms-manual.html target=_blank rel=noopener>Valgrind/Massif</a> and has a feature that makes is much more suitable for <strong>temporary</strong> production profiling.</p><p>It can attach to an already running process!</p><p>As with most heap profilers, when every single malloc family function is called it needs to do some accounting. This accounting certainly slows down the process a bit.</p><p>The design, in my mind, is the best possible design for this type of program. It intercepts using an LD_PRELOAD trick or a <a class=link href=https://milianw.de/blog/heaptrack-attaching-to-running-process target=_blank rel=noopener>GDB trick</a> to load up the profiler. It ships the data out of the profiled process as quickly as possibly using a <a class=link href=https://linux.die.net/man/3/mkfifo target=_blank rel=noopener>FIFO special file</a>. The wrapper <a class=link href=https://github.com/KDE/heaptrack/blob/983cc35dd000a8219e0d5713ab0a0d298af59c97/src/track/heaptrack.sh.cmake target=_blank rel=noopener><code>heaptrack</code></a> is a simple shell script, something that makes troubleshooting simple. A second process runs to read from the FIFO and compress the tracking data on the fly. Since heaptrack operates in “chunks” you can start looking at the profiled information seconds after you start profiling, mid way through a profiling session. Simply copy the profile file to another location and run the heaptrack gui.</p><p>This <a class=link href=https://gitlab.com/gitlab-org/gitlab-foss/issues/49702 target=_blank rel=noopener>ticket at GitLab</a> alerted me to the possibility of running heaptrack. Since they were able to run it, I knew it was a possibility for me.</p><p>We run our application in a container, I needed to relaunch our container with <code>--cap-add=SYS_PTRACE</code> which allows GDB to use <a class=link href=https://en.wikipedia.org/wiki/Ptrace target=_blank rel=noopener>ptrace</a> which we needed so heaptrack can inject itself. Additionally, I needed a <a class=link href=https://github.com/KDE/heaptrack/pull/22 target=_blank rel=noopener>small hack</a> on the shell file to allow <code>root</code> to profile a non <code>root</code> process (we run our Discourse application under a restricted account in the container).</p><p>Once this was done it was as simple as running <code>heaptrack -p PID</code> and waiting for results to stream in.</p><p>The UX of heaptrack is fantastic and extremely rich, it was very easy to follow what was happening with my memory leak.</p><p>At a top level I could see two jumps, one was due to <code>cppjieba</code> and the other was originating from Ruby <code>objspace_xmalloc0</code></p><p>I knew about <a class=link href=https://github.com/fantasticfears/cppjieba_rb target=_blank rel=noopener>cppjieba</a>, segmenting Chinese is expensive, large dictionaries are needed, it was not leaking.</p><p>But why was ruby allocating memory and further more, not telling me about it?</p><p>The largest increase was coming from <code>iseq_set_sequence</code> in <code>compile.c</code>. So it follows that we were leaking instruction sequences.</p><p>This made the leak Mwrap detected make sense. <code>mod.module_eval(source, identifier, 0)</code> was causing a leak cause it was creating instruction sequences that were never being removed.</p><p>In retrospect if I carefully analyzed a heap dump from Ruby I should have seen all these IMEMOs, cause they are included in heap dumps, just invisible from in-process introspection.</p><p>From here on debugging was pretty simple, I tracked down all calls to the module eval and dumped out what it was evaluating. I discovered we kept on appending methods over and over to a big class.</p><p>Simplified, this is the bug we were seeing:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-v data-lang=v><span class=line><span class=cl><span class=nv>require</span> <span class=s1>&#39;securerandom&#39;</span> <span class=kn>module</span> <span class=nc>BigModule</span><span class=p>;</span> <span class=nv>end</span> <span class=nv>def</span> <span class=nv>leak_methods</span> <span class=mi>10_000</span><span class=p>.</span><span class=nv>times</span> <span class=nv>do</span> <span class=nv>method</span> <span class=o>=</span> <span class=s2>&#34;def _#{SecureRandom.hex}; #{&#34;</span><span class=nv>sleep</span><span class=p>;</span><span class=s2>&#34; * 100}; end&#34;</span> <span class=nc>BigModule</span><span class=p>.</span><span class=nf>module_eval</span><span class=p>(</span><span class=nv>method</span><span class=p>)</span> <span class=nv>end</span> <span class=nv>end</span> <span class=nv>usage</span> <span class=o>#</span> <span class=nc>RSS</span><span class=p>:</span> <span class=mi>16164</span> <span class=nc>ObjectSpace</span> <span class=nv>size</span> <span class=mi>2869</span> <span class=nv>leak_methods</span> <span class=nv>usage</span> <span class=o>#</span> <span class=nc>RSS</span><span class=p>:</span> <span class=mi>123096</span> <span class=nc>ObjectSpace</span> <span class=nv>size</span> <span class=mi>5583</span> 
</span></span></code></pre></td></tr></table></div></div><p>Ruby has a class to contain instruction sequences called: <code>RubyVM::InstructionSequence</code>. However, Ruby is lazy about creating these wrapping objects, cause it is inefficient to have them around unless needed.</p><p>Interestingly <a class=link href=http://www.atdot.net/~ko1/ target=_blank rel=noopener>Koichi Sasada</a> created the <a class=link href=https://github.com/ko1/iseq_collector target=_blank rel=noopener>iseq_collector</a> gem. If we add this snippet we can now find our hidden memory:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>require &#39;iseq_collector&#39; puts &#34;#{ObjectSpace.memsize_of_all_iseq / 1024}&#34; # 98747 
</span></span></code></pre></td></tr></table></div></div><p><code>ObjectSpace.memsize_of_all_iseq</code> will materialize every instruction sequence, which can introduce slight process memory growth and slightly more GC work.</p><p>If we, for example, count the number of ISEQs before and after running the collector we will notice that after running <code>ObjectSpace.memsize_of_all_iseq</code> our <code>RubyVM::InstructionSequence</code> class count grows from 0 to 11128 in the example above:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>def count_iseqs ObjectSpace.each_object(RubyVM::InstructionSequence).count end 
</span></span></code></pre></td></tr></table></div></div><p>These wrappers will stay around for the life of a method and need to be visited when a full GC runs.</p><p>For those curious, our fix to our issue was reusing the class responsible for rendering email templates. (<a class=link href=https://review.discourse.org/t/perf-reuse-renderer-when-rendering-email-templates/6010 target=_blank rel=noopener>fix 1</a>, <a class=link href=https://review.discourse.org/t/fix-during-concurrent-emails-generation-renderer-should-not-be-reused/6097 target=_blank rel=noopener>fix 2</a>)</p><h3 id=chap>chap</h3><p>During my debugging I came across a very interesting tool.</p><p>Tim Boddy, extracted an internal tool used at VMWare for analysis of memory leaks and open sourced it a few years ago. The only video I can find about it <a class=link href="https://www.youtube.com/watch?v=EZ2n3kGtVDk" target=_blank rel=noopener>is here</a>. Unlike most tools out there this tool has zero impact on a running process. It can simply run against core dump files, as long as the allocator being used is glibc (no support for jemalloc/tcmalloc etc)</p><p>The initial leak I had can be very easily detected using chap. Not many distros include a binary for chap, but you can easily <a class=link href=https://github.com/vmware/chap target=_blank rel=noopener>build it from source</a>. It is very actively maintained.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># 444098 is the `Process.pid` of the leaking process I had sudo gcore -p 444098 chap core.444098 chap&gt; summarize leaked Unsigned allocations have 49974 instances taking 0x312f1b0(51,573,168) bytes. Unsigned allocations of size 0x408 have 49974 instances taking 0x312f1b0(51,573,168) bytes. 49974 allocations use 0x312f1b0 (51,573,168) bytes. chap&gt; list leaked ... Used allocation at 562ca267cdb0 of size 408 Used allocation at 562ca267d1c0 of size 408 Used allocation at 562ca267d5d0 of size 408 ... chap&gt; summarize anchored .... Signature 7fbe5caa0500 has 1 instances taking 0xc8(200) bytes. 23916 allocations use 0x2ad7500 (44,922,112) bytes. 
</span></span></code></pre></td></tr></table></div></div><p>Chap can use signatures to find where various memory is allocated and can complement GDB. When it comes to debugging Ruby it can do a great job helping you finding out what the actual memory is in use for a process. <code>summarize used</code> gives the actual memory, sometimes glibc malloc can fragment so much that the <code>used</code> number is enormously different to the actual RSS. See: <a class=link href=https://bugs.ruby-lang.org/issues/14759 target=_blank rel=noopener>Feature #14759: [PATCH] set M_ARENA_MAX for glibc malloc - Ruby master - Ruby Issue Tracking System</a> for more discussion. Chap can correctly account for all memory usage and provide deep analysis around memory allocation behaviors.</p><p>Additionally chap can be integrated into build pipelines to automatically detect leaks and flag builds that are leaking.</p><h3 id=future-work>Future work</h3><p>This round of debugging did prompt me to raise a few issues with our supporting tool-sets:</p><h3 id=summary>Summary</h3><p>Our existing tooling for debugging very complex memory leaks in 2019 is vastly superior to what we had 4 years ago! Mwrap, heaptrack and chap provide us with very powerful tools for attacking memory related issues both in development and production.</p><p>If you are hunting a simple memory leak in Ruby, I recommend <a class=link href=https://samsaffron.com/archive/2015/03/31/debugging-memory-leaks-in-ruby target=_blank rel=noopener>my earlier article</a> from 2015, most of it still holds.</p><p>I hope that next time you are stuck debugging a complex native memory leak you have an easier time!</p><p>If you have any interesting battle stories or tools I have forgotten to mention you would like to share, please post a comment!</p><p>from Hacker News <a class=link href=https://ift.tt/33Amc9h target=_blank rel=noopener>https://ift.tt/33Amc9h</a></p></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><footer class=site-footer><section class=copyright>&copy;
2020 -
2022 ZYChimne</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.11.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><ol><li><a href=#an-unmanaged-memory-leak>An unmanaged memory leak</a></li><li><a href=#enter-mwrap>Enter Mwrap</a></li><li><a href=#could-mwrap-isolate-the-old-redcarpet-leak>Could Mwrap isolate the old redcarpet leak?</a></li><li><a href=#a-mysterious-memory-leak>A mysterious memory leak</a></li><li><a href=#heaptrack>Heaptrack</a></li><li><a href=#chap>chap</a></li><li><a href=#future-work>Future work</a></li><li><a href=#summary>Summary</a></li></ol></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>