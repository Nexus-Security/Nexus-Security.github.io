<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Research May 24, 2018
Dimensional Analysis in Programming Languages A survey of existing designs and implementations for automatic conversion and verification of units of measurement in computer programs.
Tags: programming
Overview Dimensional analysis is a technique for comparing and calculating with numerical quantities in which units are included and treated algebraically. This article clarifies the basic concepts and looks at how they have been implemented in various programming languages.
Motivation Opinions differ as to whether dimensional analysis should be implemented as a language feature, a library, or at all."><title>Dimensional Analysis in Programming Languages</title><link rel=canonical href=https://Nexus-Security.github.io/posts/2016-09-09-dimensional-analysis-in-programming/><link rel=stylesheet href=/scss/style.min.7dbfdd4b0c439bdacf631096fda79b869b5850a9d35a3f67b9a557f3010f3972.css><meta property="og:title" content="Dimensional Analysis in Programming Languages"><meta property="og:description" content="Research May 24, 2018
Dimensional Analysis in Programming Languages A survey of existing designs and implementations for automatic conversion and verification of units of measurement in computer programs.
Tags: programming
Overview Dimensional analysis is a technique for comparing and calculating with numerical quantities in which units are included and treated algebraically. This article clarifies the basic concepts and looks at how they have been implemented in various programming languages.
Motivation Opinions differ as to whether dimensional analysis should be implemented as a language feature, a library, or at all."><meta property="og:url" content="https://Nexus-Security.github.io/posts/2016-09-09-dimensional-analysis-in-programming/"><meta property="og:site_name" content="0x000216"><meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:published_time" content="2020-01-26T07:12:00+01:00"><meta property="article:modified_time" content="2020-01-26T07:12:00+01:00"><meta name=twitter:title content="Dimensional Analysis in Programming Languages"><meta name=twitter:description content="Research May 24, 2018
Dimensional Analysis in Programming Languages A survey of existing designs and implementations for automatic conversion and verification of units of measurement in computer programs.
Tags: programming
Overview Dimensional analysis is a technique for comparing and calculating with numerical quantities in which units are included and treated algebraically. This article clarifies the basic concepts and looks at how they have been implemented in various programming languages.
Motivation Opinions differ as to whether dimensional analysis should be implemented as a language feature, a library, or at all."></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"light")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hue825486955cd7c56d95e38b4bd2a8e3c_229979_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>0x000216</a></h1><h2 class=site-description>Where Do Russian Hackers Store Their Exploits? ðŸ¤“ /ussr/bin/ ðŸ˜‹</h2></div></header><ol class=social-menu><li><a href=https://github.com/Nexus-Security target=_blank title=GitHub><svg width="72" height="72" viewBox="0 0 72 72" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><path d="M36 72c19.882251.0 36-16.117749 36-36 0-19.882251-16.117749-36-36-36-19.882251 365231026e-23-36 16.117749-36 36C24348735e-22 55.882251 16.117749 72 36 72z" fill="#3e75c3"/><path d="M35.9985 12C22.746 12 12 22.7870921 12 36.096644c0 10.6440272 6.876 19.6751861 16.4145 22.8617681C29.6145 59.1797862 30.0525 58.4358488 30.0525 57.7973276 30.0525 57.2250681 30.0315 55.7100863 30.0195 53.6996482c-6.6765 1.4562499-8.085-3.2302544-8.085-3.2302544-1.0905-2.7829884-2.664-3.5239139-2.664-3.5239139C17.091 45.4500754 19.4355 45.4801943 19.4355 45.4801943c2.4075.1701719 3.675 2.4833051 3.675 2.4833051 2.142 3.6820383 5.6175 2.6188404 6.9855 2.0014024C30.3135 48.4077535 30.9345 47.3460615 31.62 46.7436831 26.2905 46.1352808 20.688 44.0691228 20.688 34.8361671c0-2.6308879.9345-4.781379 2.4705-6.4665327C22.911 27.7597262 22.0875 25.3110578 23.3925 21.9934585c0 0 2.016-.6475568 6.6 2.4697516C31.908 23.9285993 33.96 23.6620468 36.0015 23.6515052 38.04 23.6620468 40.0935 23.9285993 42.0105 24.4632101c4.581-3.1173084 6.5925-2.4697516 6.5925-2.4697516C49.9125 25.3110578 49.089 27.7597262 48.8415 28.3696344 50.3805 30.0547881 51.309 32.2052792 51.309 34.8361671c0 9.2555448-5.6115 11.29309-10.9575 11.8894446.860999999999997.7439374 1.629 2.2137408 1.629 4.4621184C41.9805 54.4089489 41.9505 57.0067059 41.9505 57.7973276 41.9505 58.4418726 42.3825 59.1918338 43.6005 58.9554002 53.13 55.7627944 60 46.7376593 60 36.096644 60 22.7870921 49.254 12 35.9985 12" fill="#fff"/></g></svg></a></li><li><a href=mailto:0x000216@gmail.com target=_blank title=Email><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" style="enable-background:new 0 0 512 512"><path style="fill:#e6f3ff" d="M512 105.739v300.522c0 27.715-22.372 50.087-50.087 50.087H50.087C22.372 456.348.0 433.976.0 406.261V105.739c0-.89.0-1.781.111-2.671 1.336-25.6 21.704-45.969 47.304-47.304.89-.111 1.781-.111 2.671-.111h411.826c.89.0 1.892.0 2.783.111 25.489 1.336 45.857 21.704 47.193 47.193C512 103.847 512 104.849 512 105.739z"/><path style="fill:#cfdbe6" d="M464.696 55.763c-.892-.111-1.891-.111-2.783-.111H256v400.696h205.913c27.715.0 50.087-22.372 50.087-50.087V105.739c0-.89.0-1.892-.111-2.783C510.553 77.468 490.184 57.099 464.696 55.763z"/><path style="fill:#ff4b26" d="M511.889 102.957c-1.336-25.489-21.704-45.857-47.193-47.193C382.89 137.569 336.951 183.509 256 264.459 225.291 233.732 77.61 85.958 47.416 55.763c-25.6 1.336-45.969 21.704-47.304 47.304C0 103.958.0 104.849.0 105.739v300.522c0 27.715 22.372 50.087 50.087 50.087h16.696V169.739l165.621 165.51c6.456 6.567 15.026 9.795 23.597 9.795 8.57.0 17.141-3.228 23.597-9.795l165.621-165.621v286.72h16.696c27.715.0 50.087-22.372 50.087-50.087V105.739C512 104.849 512 103.847 511.889 102.957z"/><path style="fill:#d93f21" d="M279.596 335.249l165.621-165.621v286.72h16.696c27.715.0 50.087-22.372 50.087-50.087V105.739c0-.89.0-1.892-.111-2.783-1.336-25.489-21.704-45.857-47.193-47.193C382.891 137.569 336.951 183.509 256 264.459v80.584C264.57 345.043 273.141 341.816 279.596 335.249z"/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/></svg></a></li><li><a href=https://www.buymeacoffee.com/0x000216 target=_blank title=RSS><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" style="enable-background:new 0 0 512 512"><path style="fill:#f78c20" d="M78.333 355.334C35.14 355.334.0 390.474.0 433.667S35.14 512 78.333 512s78.333-35.14 78.333-78.333-35.14-78.333-78.333-78.333z"/><g><path style="fill:#ffa929" d="M78.333 381.445c-28.795.0-52.222 23.427-52.222 52.222s23.427 52.222 52.222 52.222 52.222-23.427 52.222-52.222-23.427-52.222-52.222-52.222z"/><path style="fill:#ffa929" d="M477.918 264.861c-21.843-51.641-53.111-98.019-92.936-137.842-39.824-39.824-86.201-71.093-137.843-92.935C193.669 11.468 136.874.0 78.333.0c-4.807.0-8.704 3.897-8.704 8.704v85.519c0 4.807 3.897 8.704 8.704 8.704 182.37.0 330.74 148.369 330.74 330.74.0 4.807 3.897 8.704 8.704 8.704h85.52c4.807.0 8.704-3.897 8.704-8.704C512 375.126 500.533 318.331 477.918 264.861z"/><path style="fill:#ffa929" d="M78.333 163.853c-4.807.0-8.704 3.897-8.704 8.704v95.74c0 4.807 3.897 8.704 8.704 8.704 86.386.0 156.666 70.281 156.666 156.666.0 4.807 3.897 8.704 8.704 8.704h95.74c4.807.0 8.704-3.897 8.704-8.704.0-72.07-28.065-139.826-79.027-190.787-50.961-50.961-118.717-79.027-190.787-79.027z"/></g><g><path style="fill:#f78c20" d="M78.333 242.186c-2.918.0-5.817.076-8.704.206v25.905c0 4.807 3.897 8.704 8.704 8.704 86.386.0 156.666 70.281 156.666 156.666.0 4.807 3.897 8.704 8.704 8.704h25.905c.129-2.886.206-5.786.206-8.704.0-105.752-85.729-191.481-191.481-191.481z"/><path style="fill:#f78c20" d="M78.333 68.113c-2.91.0-5.81.042-8.704.11v26.001c0 4.807 3.897 8.704 8.704 8.704 182.37.0 330.74 148.369 330.74 330.74.0 4.807 3.897 8.704 8.704 8.704h26.001c.067-2.894.11-5.793.11-8.704C443.887 231.777 280.223 68.113 78.333 68.113z"/></g><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/></svg></a></li><li><a href target=_blank title=Slack><svg width="256" height="256" viewBox="0 0 256 256" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid"><path d="M165.964 15.838c-3.89-11.975-16.752-18.528-28.725-14.636-11.975 3.89-18.528 16.752-14.636 28.725l58.947 181.365c4.048 11.187 16.132 17.473 27.732 14.135 12.1-3.483 19.475-16.334 15.614-28.217L165.964 15.838" fill="#dfa22f"/><path d="M74.626 45.516C70.734 33.542 57.873 26.989 45.9 30.879 33.924 34.77 27.37 47.631 31.263 59.606l58.948 181.366c4.047 11.186 16.132 17.473 27.732 14.132 12.099-3.481 19.474-16.332 15.613-28.217L74.626 45.516" fill="#3cb187"/><path d="M240.162 166.045c11.975-3.89 18.526-16.75 14.636-28.726-3.89-11.973-16.752-18.527-28.725-14.636L44.708 181.632c-11.187 4.046-17.473 16.13-14.135 27.73 3.483 12.099 16.334 19.475 28.217 15.614l181.372-58.93" fill="#ce1e5b"/><path d="M82.508 217.27l43.347-14.084-14.086-43.352-43.35 14.09 14.089 43.347" fill="#392538"/><path d="M173.847 187.591c16.388-5.323 31.62-10.273 43.348-14.084l-14.088-43.36-43.35 14.09 14.09 43.354" fill="#bb242a"/><path d="M210.484 74.706c11.974-3.89 18.527-16.751 14.637-28.727-3.89-11.973-16.752-18.526-28.727-14.636L15.028 90.293C3.842 94.337-2.445 106.422.896 118.022c3.481 12.098 16.332 19.474 28.217 15.613l181.371-58.93" fill="#72c5cd"/><path d="M52.822 125.933c11.805-3.836 27.025-8.782 43.354-14.086-5.323-16.39-10.273-31.622-14.084-43.352l-43.36 14.092 14.09 43.346" fill="#248c73"/><path d="M144.16 96.256l43.356-14.088a546179.21 546179.21.0 00-14.089-43.36L130.07 52.9l14.09 43.356" fill="#62803a"/></svg></a></li><li><a href=https://www.buymeacoffee.com/0x000216 target=_blank title=Minds><svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" style="enable-background:new 0 0 512 512"><g><g><path style="fill:#ffe1b2" d="M256 33.085C245.078 13.38 224.079.0 2e2.0c-23.781.0-45.57 13.293-56.594 34.184C115.711 41.602 96 66.977 96 96c0 .059.0.113.0.172-9.977 7.512-16 19.301-16 31.828.0 1.316.078 2.637.234 3.992C60.211 145.266 48 167.758 48 192c0 14.07 4.039 27.543 11.719 39.262C57.273 236.512 56 242.207 56 248c0 2.738.281 5.445.828 8.098C36.672 267.308 24 288.539 24 312c0 27.973 18.305 52.34 44.109 60.785C65.398 378.828 64 385.324 64 392c0 21.098 13.805 39.508 33.539 45.727C103.891 466.746 129.828 488 160 488c4.617.0 9.227-.512 13.766-1.527C181.992 502 198.141 512 216 512c16.687.0 31.396-8.567 40-21.523V33.085z"/></g><g><g><path style="fill:#ffb980" d="M264 256c-4.422.0-8-3.582-8-8 0-22.055-17.945-40-40-40-8.008.0-15.734 2.355-22.336 6.812-3.023 2.043-7.055 1.781-9.797-.652-3.156-2.809-8.477-6.16-15.867-6.16-4.422.0-8-3.582-8-8s3.578-8 8-8c7.711.0 15.234 2.293 21.719 6.539C197.773 194.246 206.758 192 216 192c30.875.0 56 25.121 56 56C272 252.418 268.422 256 264 256z"/></g></g><g><g><path style="fill:#ffb980" d="M120 120c18.977.0 36.875 7.312 50.414 20.594 3.141 3.09 8.203 3.047 11.312-.109 3.094-3.152 3.047-8.219-.109-11.312C165.07 112.941 143.187 104 120 104c-13.046.0-25.395 2.93-36.542 8.046C81.253 117.019 80 122.423 80 128c0 1.316.078 2.637.234 3.992-.094.062-.173.139-.267.202C91.423 124.501 105.193 120 120 120z"/></g></g><g><g><path style="fill:#ffb980" d="M216 360c0-4.418-3.578-8-8-8s-8 3.582-8 8c0 17.645-14.352 32-32 32-14.211.0-26.82-9.648-30.664-23.465-.703-2.512-2.578-4.523-5.039-5.395-2.453-.871-5.188-.492-7.305 1.02C114.094 371.906 101.305 376 88 376c-6.948.0-13.625-1.149-19.894-3.207-2.214 4.939-3.501 10.19-3.916 15.586C71.714 390.73 79.711 392 88 392c13.297.0 26.187-3.266 37.773-9.52C133.969 397.894 150.141 408 168 408c26.469.0 48-21.531 48-48z"/></g></g><g><path style="fill:#fdc88e" d="M488 312c0-23.461-12.672-44.691-32.828-55.902.547-2.652.828-5.359.828-8.098.0-5.793-1.273-11.488-3.719-16.738C459.961 219.543 464 206.07 464 192c0-24.242-12.211-46.734-32.234-60.008.156-1.355.234-2.676.234-3.992.0-12.527-6.023-24.316-16-31.828.0-.059.0-.113.0-.172.0-29.023-19.711-54.398-47.406-61.816C357.57 13.293 335.781.0 312 0c-24.08.0-45.078 13.38-56 33.085v457.391C264.604 503.433 279.313 512 296 512c17.859.0 34.008-10 42.234-25.527C342.773 487.488 347.383 488 352 488c30.172.0 56.109-21.254 62.461-50.273C434.195 431.508 448 413.097 448 392c0-6.676-1.398-13.172-4.109-19.215C469.695 364.34 488 339.973 488 312z"/></g><g><path style="fill:#f8ab6b" d="M272.008 151.199C272 151.465 272 151.734 272 152c0 26.469 21.531 48 48 48s48-21.531 48-48c0-4.418-3.578-8-8-8s-8 3.582-8 8c0 17.645-14.352 32-32 32s-32-14.355-32-32c0-2.184.219-4.359.656-6.465.492-2.395-.133-4.883-1.703-6.754-1.57-1.871-4.016-3.066-6.352-2.859-.453.012-.891.059-.602.078-13.234.0-24-10.766-24-24v31.813C260.673 147.348 266.061 149.988 272.008 151.199z"/></g><g><path style="fill:#f8ab6b" d="M296 328c9.242.0 18.219-2.246 26.281-6.539C328.765 325.707 336.289 328 344 328c4.422.0 8-3.582 8-8s-3.578-8-8-8c-7.391.0-12.711-3.352-15.867-6.16-2.742-2.434-6.766-2.695-9.797-.656C311.726 309.644 304 312 296 312c-22.055.0-40-17.945-40-40v39.116C266.174 321.517 280.337 328 296 328z"/></g><g><g><path style="fill:#f8ab6b" d="M431.765 131.992c.156-1.355.234-2.676.234-3.992.0-5.577-1.253-10.981-3.458-15.954C417.395 106.93 405.046 104 392 104c-4.422.0-8 3.582-8 8s3.578 8 8 8c14.807.0 28.577 4.501 40.032 12.194C431.939 132.131 431.859 132.054 431.765 131.992z"/></g></g><g><g><path style="fill:#f8ab6b" d="M447.81 388.38c-.415-5.396-1.702-10.647-3.916-15.586C437.624 374.85 430.948 376 424 376c-13.578.0-26.594-4.266-37.641-12.332-2.07-1.5-4.719-1.93-7.133-1.168-2.43.77-4.344 2.648-5.164 5.059C369.101 382.176 355.414 392 340 392c-4.422.0-8 3.582-8 8s3.578 8 8 8c18.875.0 35.961-10.191 45.094-26.156C396.976 388.512 410.258 392 424 392 432.288 392 440.285 390.73 447.81 388.38z"/></g></g></g><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/></svg></a></li><li><a href=https://www.buymeacoffee.com/0x000216 target=_blank title=Coffee><svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 340 340" style="enable-background:new 0 0 340 340"><g id="XMLID_18_"><polygon id="XMLID_138_" style="fill:#dedde0" points="76.429,290 80,340 170,340 170,290"/><polygon id="XMLID_169_" style="fill:#dedde0" points="170,80 61.429,80 65,130 170,130"/><polygon id="XMLID_197_" style="fill:#acabb1" points="170,290 170,340 260,340 263.571,290"/><polygon id="XMLID_221_" style="fill:#acabb1" points="170,80 170,130 275,130 278.571,80"/><path id="XMLID_222_" style="fill:#ffda44" d="M170 260c-22.091.0-40-22.386-40-50s17.909-50 40-50v-30H65 50l10 160h16.429H170V260z"/><path id="XMLID_33_" style="fill:#ff9811" d="M170 130v30c22.091.0 40 22.386 40 50s-17.909 50-40 50v30h93.571H280l10-160h-15H170z"/><path id="XMLID_223_" style="fill:#50412e" d="M210 210c0-27.614-17.909-50-40-50v1e2c22.091.0 40-22.386 40-50z"/><path id="XMLID_224_" style="fill:#786145" d="M130 210c0 27.614 17.909 50 40 50V160c-22.091.0-40 22.386-40 50z"/><polygon id="XMLID_225_" style="fill:#50412e" points="278.571,80 300,80 300,40 260,40 260,0 80,0 80,40 40,40 40,80 61.429,80 170,80"/></g><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/about/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>About Us</span></a></li><li><a href=/termsofservice/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-pencil" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 20h4L18.5 9.5a1.5 1.5.0 00-4-4L4 16v4"/><line x1="13.5" y1="6.5" x2="17.5" y2="10.5"/></svg><span>Terms Of Service</span></a></li><li><a href=/privacypolicy/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Privacy Policy</span></a></li><li><a href=/disclaimer/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg><span>Disclaimer</span></a></li><li><a href=/contact/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-mail" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><rect x="3" y="5" width="18" height="14" rx="2"/><polyline points="3 7 12 13 21 7"/></svg><span>Contact Us</span></a></li><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></div></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/posts/2016-09-09-dimensional-analysis-in-programming/>Dimensional Analysis in Programming Languages</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Jan 26, 2020</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>55 minute read</time></div></footer></div></header><section class=article-content><p><a class=link href=https://gmpreussner.com/research target=_blank rel=noopener>Research</a> May 24, 2018</p><h1 id=dimensional-analysis-in-programming-languages>Dimensional Analysis in Programming Languages</h1><p>A survey of existing designs and implementations for automatic conversion and verification of units of measurement in computer programs.</p><p>Tags: <a class=link href=https://gmpreussner.com/research/tag:programming target=_blank rel=noopener>programming</a></p><h1 id=overview>Overview</h1><p><a class=link href=https://en.wikipedia.org/wiki/Dimensional_analysis title="Wikipedia: Dimensional Analysis" target=_blank rel=noopener>Dimensional analysis</a> is a technique for comparing and calculating with numerical quantities in which units are included and treated algebraically. This article clarifies the basic concepts and looks at how they have been implemented in various programming languages.</p><h2 id=motivation>Motivation</h2><p>Opinions differ as to whether dimensional analysis should be implemented as a language feature, a library, or at all. One thing that most engineers do agree on is that there is great value in compilers verifying the correctness of programs before they are executed. The ability to automatically check the usage of units of measurement can eliminate an entire class of errors and potentially prevent <a class=link href=http://mentalfloss.com/article/25845/quick-6-six-unit-conversion-disasters title="Mental Floss: Six Unit Conversion Disasters" target=_blank rel=noopener>all sorts of disasters</a>. What is less clear is how this should be accomplished in practice.</p><p>If you&rsquo;ve used strongly-typed programming languages before, the relationship between dimensional analysis and type theory is rather obvious. Using types to represent measurement systems is in fact the most popular implementation approach, but not everyone agrees that the added structure and complexity is worth the effort. The controversy mainly revolves around convenience. When is a type system beneficial, and when does it get in the way? John D. Cook <a class=link href=https://www.johndcook.com/blog/2015/12/01/dimensional-analysis-and-types/ target=_blank rel=noopener>pointed out</a> that it mainly depends on your use case. It also depends on how expressive the language is and how much machinery is needed to make it work.</p><p>I mostly work in large code bases myself. These aren&rsquo;t necessarily mission critical in the sense that lives depend on them, but reliability still is a desirable property from a business point of view. Other <a class=link href=https://en.wikipedia.org/wiki/Software_quality title="Wikipedia: Software quality" target=_blank rel=noopener>software qualities</a> that are often overlooked are comprehensibility and maintainability. In an economic system that rewards time to market, the long-term costs of software development are rarely considered. By adding dimensional analysis to code we have an opportunity to make it easier to read, understand, refactor and extend. This is increasingly important as projects grow larger over time.</p><h2 id=concepts>Concepts</h2><p>Different authors use slightly different terminology in the literature for dimensional analysis, so it might be worthwhile to clarify the concepts.</p><p><strong>Physical dimensions</strong> (also: <em>dimensions</em>) are distinct kinds of observable characteristics of objects or events that can be directly compared to one another, i.e. <em>length</em>, <em>mass</em>, and <em>electric charge</em>. Even though there is strong agreement about which dimensions form the foundation of the natural sciences, they are nevertheless a matter of convention. For instance, electrical properties were not taken into consideration until the 1800&rsquo;s.</p><p><strong>Measurements</strong> are the assignments of numbers (also: <em>measures</em>, <em>values</em>, or <em>magnitudes</em>) to the characteristics of objects or events within a given <em>dimension</em>. Since physical characteristics cannot be described in absolute terms they must be compared by reference to other objects or events. For example, we can determine that some object has the same length as, or twice the mass of another object. The process of measuring can be simple or involved, but the numbers assigned as a result are always ratios of the objects&rsquo; characteristics within the dimension of interest.</p><p><strong>Base units</strong> are characteristics of <em>particular</em> objects or events that are selected as a reference for taking <em>measurements</em> in a given dimension. In practice, most base units are derived from invariant constants of nature that can be measured with great accuracy, but it is important to note that they, too, are a matter of convention. For example, <em>second</em> is the base unit for measuring time in the SI system and defined in terms of radiation properties of Caesium 133 atoms. Base units are chosen in such a way that they cannot be derived (are mutually independent) from each other.</p><p><strong>Derived units</strong> are defined in terms of <em>base units</em> or other derived units by combining them via multiplication or division. If <em>meter</em> and <em>second</em> are chosen as base units, <em>meter2</em> and <em>meter/second</em> would be derived units.</p><p><strong>Unit exponents</strong> (also: <em>exponents</em>) are positive or negative numbers for the powers of base units that make up a <em>derived unit</em>. For example, <em>voltage</em> is derived from the base units kilogram, meter, second, and ampere, and the exponents are 1, 2, -3, and -1 for kgÃ—m2Ã—sâˆ’3Ã—Aâˆ’1. In practice, the vast majority of exponents are in the range -4 to +4, inclusive. Exponents are usually integral, but some computations involve rational exponents.</p><p><strong>Units of measurement</strong> (also: <em>units</em>, <em>units of measure</em>) are <em>base units</em> or <em>derived units</em>. Physical dimensions may have multiple units, for example, <em>meter</em> and <em>inch</em> are both units of length. Units may contain multiplicative factors, for example, one <em>inch</em> is 0.0254 meters. Units are said to be <em>coherent</em> if they do not contain any numerical factors other than 1. Units may also contain zero point shifts as in <em>celsius</em> and <em>fahrenheit</em>, which are both units of temperature. These are sometimes called <em>affine units</em>.</p><p><strong>Unit symbols</strong> (also: <em>symbols</em>) are letters or signs assigned to <em>units of measurement</em> so that the latter can be expressed more concisely. For example, in the SI system, <em>m</em> is the symbol for meter (the unit of length), and <em>J</em> (Joule) is the symbol for kgÃ—m2Ã—sâˆ’2 (the unit of energy).</p><p><strong>Prefix names</strong> (also: <em>prefixes</em>) are words added to unit names to produce multiples and sub-multiples (usually powers of ten or a thousand) of the original unit. For example, the SI system defines the standard prefix names <em>kilo</em> for 103 and <em>milli</em> for 10-3, so that <em>kilometer</em> is equal to one thousand meter, and <em>milligram</em> to one thousands of a gram. Prefixes are never combined, i.e. <em>micrometer</em> is used instead of <em>millimillimeter</em>.</p><p><strong>Prefix symbols</strong> are short versions of <em>prefix names</em> that are attached to <em>unit symbols</em>, for example, <em>k</em> for kilo and <em>m</em> for milli, so that kilometer can be written as <em>km</em>, and milligram as <em>mg</em>.</p><p><strong>Physical quantities</strong> (also: <em>quantities</em>) are characteristics of objects or events that can be quantified by measurements. They can be represented as a combination of magnitude, usually a real number, and <em>unit</em>. For example, the quantity <em>1.6749Ã—10âˆ’27 kg</em> is the mass of a neutron. Physical quantities that have the same dimension are said to be <em>commensurable</em> and can be directly compared to each other even when expressed in different units of measure. Quantities measured in base units are <em>base quantities</em>. Quantities that do not have a physical dimension associated, such as angles, ratios, or percentages are called <em>dimensionless quantities</em>.</p><p><strong>Systems of measurements</strong> are sets of <em>units of measurement</em> that form a framework for comparing <em>physical quantities</em>. Such systems may or may not be coherent. The modern SI system was designed to be coherent, but the Centimetreâ€“gramâ€“second (CGS) system is not because it contains <em>calorie</em> as a unit of energy, which is not coherent with its other base units. Systems of measurement may include definitions for <em>unit symbols</em> and <em>prefixes</em>.</p><p><strong>Dimensional analysis</strong> is the analysis of the relationships between different <em>physical quantities</em> by identifying their <em>base quantities</em> and <em>units of measure</em>, and tracking these as calculations or comparisons are carried out. Historically, it is used to simplify physical problems before obtaining a quantitative answer. In computer programs it can be used to verify the semantic consistency of scientific algorithms.</p><p>An important theorem in dimensional analysis is the <em>Buckingham Ï€ theorem</em>, which states that the laws of physics do not depend on the choice of a specific system of measurement. One should also note that, even though dimensional analysis is usually associated with scientific calculations and the definitions above rest on examples from physics, it is not limited to physical quantities, but applicable to any kind of units, practical or not.</p><p>The theoretical foundations of dimensional analysis and its application in the natural sciences are well explained in Sonin&rsquo;s paper on <a class=link href=http://web.mit.edu/2.25/www/pdf/DA_unified.pdf target=_blank rel=noopener>The Physical Basis of Dimensional Analysis</a>. In the rest of this article we will take a look at how it is implemented in existing software systems.</p><h2 id=languages>Languages</h2><p>We already considered the use of the type systems of programming languages to represent units of measurement. However, the label notation that is commonly taught in school, and that most of us are familiar with, does not lend itself to the syntactic requirements of most languages. The resulting code can be awkward or cumbersome to use. It is therefore tempting to build syntactic support for dimensions and units into the language itself.</p><p>Surprisingly, there aren&rsquo;t many programming languages that actually do this. At the time of this writing, the only mainstream language with built-in support appears to be <a class=link href=https://gmpreussner.com/research/dimensional-analysis-in-programming-languages#fsharp target=_blank rel=noopener>F#</a>. The other big contenders are <a class=link href=https://gmpreussner.com/research/dimensional-analysis-in-programming-languages#atlas target=_blank rel=noopener>ATLAS</a>, <a class=link href=https://gmpreussner.com/research/dimensional-analysis-in-programming-languages#fortress target=_blank rel=noopener>Fortress</a> and <a class=link href=https://gmpreussner.com/research/dimensional-analysis-in-programming-languages#frink target=_blank rel=noopener>Frink</a>. We&rsquo;ll look at these in more detail below.</p><h2 id=libraries>Libraries</h2><p>Many argue that dimensional analysis is a domain specific feature that does not belong into the programming language itself, but is best left to be implemented in libraries. Ideally, a programming language is as concise and general as possible while also providing mechanisms for expressing domain specific concerns in a convenient and readable way.</p><p>Even though most of today&rsquo;s mainstream languages are still significantly handicapped in this regard, there has been no lack of implementation attempts. It is worthwhile to study the most popular libraries and see what they offer, how they differ, and the limitations they have.</p><h2 id=research>Research</h2><p>Research for the incorporation of units into programming language goes all the way back to the 60&rsquo;s. A more general discussion has been presented as early as 1978 by <a class=link href="https://dl.acm.org/citation.cfm?doid=359488.359501" title="ACM Digital Library: Incorporation of Units Into Programming Languages" target=_blank rel=noopener>Karr & Loveman</a>. After reviewing units calculus, their paper introduces units as sub-types and covers syntactical issues. Much of it is still relevant today.</p><p>There have also been attempts to infer unit types automatically without any annotations, such as by <a class=link href=http://www.ccs.neu.edu/home/wand/papers/dimensions.ps title="PS: Automatic Dimensional Inference" target=_blank rel=noopener>Wand & O&rsquo;Keefe</a> for ML, and <a class=link href=https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-883-program-analysis-fall-2005/projects/unit_type_infere.pdf title="PDF: Annotation-less Unit Type Inference for C" target=_blank rel=noopener>Guo & McCamant</a> for C. <a class=link href=http://www.hpl.hp.com/techreports/96/HPL-96-61.pdf target=_blank rel=noopener>Bruche Hamilton</a> discussed the general representation of units in and between computer systems.</p><p>The following sections will give an overview of particular implementation examples in various programming languages. It is not my goal to provide an exhaustive list and analyze or evaluate each of them in detail, but rather to point out certain design decisions, features, and syntactic choices.</p><h1 id=ada>Ada</h1><p>Dimensional analysis support in Ada has been researched since the mid 80&rsquo;s, and there have been a number of proposals. Grein et. al. published a <a class=link href=https://link.springer.com/chapter/10.1007/3-540-44947-7_19 target=_blank rel=noopener>survey of physical unit handling techniques</a> in 2003, discussing the contradictory requirements of compile-time methods, as well as the implementation and shortcomings of existing solutions. The problem was solved more generally (and with some compromises) in the GNAT dimension system in 2012.</p><h2 id=gehani>Gehani</h2><p>In 1985, N. H. Gehani&rsquo;s presented two ideas for <a class=link href=https://dl.acm.org/citation.cfm target=_blank rel=noopener>units of measure in Ada</a>. His first implementation uses distinct derived types in combination with operator overloading:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type SPEED is new FLOAT; type ACCELERATION is new FLOAT; type TIME is new FLOAT; type DISTANCE is new FLOAT; function &#34;*&#34;(A:SPEED;B;TIME) return DISTANCE is begin return DISTANCE(A) * DISTANCE(B); end &#34;*&#34;; function &#34;*&#34; (A:ACCELERATION; B:TIME) return DISTANCE is begin return DISTANCE(A) * DISTANCE(B); end &#34;*&#34;; U: SPEED; A: ACCELERATION; T: TIME; S: DISTANCE; S:= U * T + 0.5 * A * (T * T);
</span></span></code></pre></td></tr></table></div></div><p>Gehani shows that this is approach is not sufficient for modelling an algebra with units as it disallows certain operations that should be permitted and vice versa.</p><p>After considering language modifications and preprocessors, his second implementation is a library package that introduces integer and floating-point quantity types that store a unit name and exponent along with values, and a set of operators and helpers for assignments and conversions:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>AREA: FLOAT-WITH-UNITS:= (0.0, 1, ((METER, 2))); SIDE: FLOAT-WITH-UNITS:= (5.0.1. ((METER, 1))); S1, S2: FLOAT-WITH-UNITS:= (0.0, 2, ((MILE, 1), (HOUR, -1))); ASSIGN(AREA, SIDE*SIDE);
</span></span></code></pre></td></tr></table></div></div><p>This notation considerably differs differs from what scientists are acustomed to, and Gehani&rsquo;s approach also has some other problems. A detailed critique can be found in R. T. House&rsquo;s proposal for <a class=link href=https://dl.acm.org/citation.cfm target=_blank rel=noopener>type checking of expressions</a> (<a class=link href=https://academic.oup.com/comjnl/article-pdf/26/4/366/1072622/26-4-366.pdf target=_blank rel=noopener>PDF</a>).</p><h2 id=gnat>GNAT</h2><p>In 2012, Vincent Pucci and Ed Schonberg added support for physical units with <a class=link href=https://blog.adacore.com/uploads/dc.pdf target=_blank rel=noopener>simple dimensionality checking</a> at compile-time to AdaCore&rsquo;s GNAT compiler. The system provides base and derived MKS units and symbols with zero run-time overhead. It has support for fractional dimensions and basic I/O. Prefixed units are represented as constants.</p><p>Unit systems are defined via two aspects, <code>Dimension</code> and <code>Dimension_System</code>, which can also be used for defining custom units. The details and some examples are explained in <a class=link href=https://www.adacore.com/gems/gem-136-how-tall-is-a-kilogram title="AdaCore Blog: How tall is a kilogram?" target=_blank rel=noopener>Pucci&rsquo;s blog post</a>.</p><p>The following is an excerpt of the MKS system definition:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type Mks_Type is new Long_Long_Float with Dimension_System =&gt; ( (Unit_Name =&gt; Meter, Unit_Symbol =&gt; &#39;m&#39;, Dim_Symbol =&gt; &#39;L&#39;), (Unit_Name =&gt; Second, Unit_Symbol =&gt; &#39;s&#39;, Dim_Symbol =&gt; &#39;T&#39;), ... subtype Length is Mks_Type with Dimension =&gt; (Symbol =&gt; &#39;m&#39;, Meter =&gt; 1, others =&gt; 0); subtype Time is Mks_Type with Dimension =&gt; (Symbol =&gt; &#39;s&#39;, Second =&gt; 1, others =&gt; 0); m : constant Length := 1.0; s : constant Time := 1.0; cm : constant Length := 1.0E-02; km : constant Length := 1.0E+03; min : constant Time := 60.0 * s; hour : constant Time := 60.0 * min; subtype Area is Mks_Type with Dimension =&gt; ( Meter =&gt; 2, others =&gt; 0); subtype Speed is Mks_Type with Dimension =&gt; ( Meter =&gt; 1, Second =&gt; -1, others =&gt; 0);
</span></span></code></pre></td></tr></table></div></div><p>The defined units can then be used in program code (excerpt from GNAT):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>procedure Foo is subtype Acceleration is Mks_Type with Dimension =&gt; (&#34;m/sec^2&#34;, 1, 0, -2, others =&gt; 0); G : constant Acceleration := 9.81 * M / (S ** 2); T : Time := 10.0 * S; Distance : Length; begin Distance := 0.5 * G * T ** 2; Put (Distance, Aft =&gt; 2, Exp =&gt; 0); end Foo
</span></span></code></pre></td></tr></table></div></div><p>The original implementation allowed for generic programming, but left it unchecked for dimensionality correctness. This was later <a class=link href=https://blog.adacore.com/physical-units-pass-the-generic-test title="AdaCore Blog: Physical Units Pass the Generic Test" target=_blank rel=noopener>improved</a> by Moy, Becker, and Regnath. Note that identifiers in Ada are case-insensitive, so the above example (<code>M</code> vs. <code>m</code>, <code>S</code> vs. <code>s</code>) still works. This and other minor shortcomings along with suggested improvements were <a class=link href=http://www.christ-usch-grein.homepage.t-online.de/Ada/Dimension/Physical_units_with_GNAT_GPL_2013-AUJ35.1.pdf title="Physical Units with GNAT (PDF)" target=_blank rel=noopener>discussed by Grein</a>.</p><h2 id=units>UNITS</h2><p>In 1988, Paul N. Hilfinger published a paper that demonstrates <a class=link href=https://dl.acm.org/citation.cfm target=_blank rel=noopener>dimensional analysis in Ada</a> based on Gehani&rsquo;s approach using the language&rsquo;s existing abstraction facilities like operator overloading and type parameterization. His <em>UNITS</em> package allows for declaring variables, constants, and parameters with particular units of measure and arithmetic operations between them.</p><p>The following code snippet shows the syntax for declaring base unit types, a constant, variables, and function parameters:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>subtype DISTANCE is QUANT(i,O,O,O); subtype TIME is QUANT(O,l,O,O); GRAVITY : constant QUANT := 980.7 * CM / SEC**2; x,y : DISTANCE := 0.0 * CM; V : VELOCITY := 0.0 * (CM / SEC); function HEIGHT(X : DISTANCE) return DISTANCE is -- implementation goes here end HEIGHT; 
</span></span></code></pre></td></tr></table></div></div><p><code>QUANT</code> is a generic value-with-units type for defining concrete unit subtypes. It uses Ada&rsquo;s constant folding to evaluate the discriminants at compile-time. It is limited to a total of four integral dimensionalities.</p><h1 id=atlas>ATLAS</h1><h2 id=catlas>C/ATLAS</h2><p>One of the early high-level programming languages with support for units is <a class=link href=https://en.wikipedia.org/wiki/Abbreviated_Test_Language_for_All_Systems title="Wikipedia: ATLAS" target=_blank rel=noopener>C/ATLAS</a>, which was originally created in 1968 for the automated testing of avionics equipment. It has a fixed set of physical units and operations to model signal flows and common electrical and mechanical systems.</p><p>The following statement applies an alternating current of 7.5 volts at 3 kilohertz to a pin called <em>AC SIGNAL</em>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>010200 APPLY, AC SIGNAL, VOLTAGE-PP 7.5V, FREQ 3 KHZ, CNX HI=P1-1 $
</span></span></code></pre></td></tr></table></div></div><h2 id=atlas-2000>ATLAS 2000</h2><p>After several IEEE standard iterations of <em>C/ATLAS</em> that culminated in <a class=link href=https://standards.ieee.org/findstds/standard/716-1995.html title="IEEE Standards Association: 716-1995" target=_blank rel=noopener>IEEE 716-1995</a>, the language was restructured into <a class=link href=http://ieeexplore.ieee.org/document/713433/ target=_blank rel=noopener>ATLAS 2000</a>. The signal modelling aspects moved into a new language called <a class=link href=https://web.archive.org/web/20051110020029/http://grouper.ieee.org/groups/scc20/atlas/SMMLusers_manual.doc title="System Signal Method Modeling Language User's Manual" target=_blank rel=noopener>SMML</a>. It uses a more familiar syntax, but still doesn&rsquo;t allow for extending the built-in units.</p><p>The following sample declares a voltage input signal and then applies a 20 hertz sine wave at 2 volts and zero phase to it:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>inp:: SignalRep Time Voltage inp = sine(V 2.0)(Hz 20)(Rad 0.0)
</span></span></code></pre></td></tr></table></div></div><p>There are a total of 41 predefined physical types, each with its own unit. Units always start with an upper-case letter, regardless of physical convention. Some are overloaded with prefixes, i.e. <code>Hz</code>, <code>Khz</code> and <code>Mhz</code>.</p><h1 id=c>C</h1><p>C is still one of the most widely used programming languages today. Compared to many modern languages, its type system is arguably more limited when it comes to abstraction capabilities. Nevertheless, support for dimensional analysis has been studied and exists via pre-processors.</p><h2 id=c-units>C-UNITS</h2><p>In 2003, Grigore Rosu and Feng Chen published a prototype for <a class=link href=https://pdfs.semanticscholar.org/4466/ee6fdb08c4f9761385da05510dac65c93095.pdf target=_blank rel=noopener>certifying measurement unit safety policies</a> that is based on <a class=link href=http://maude.cs.uiuc.edu/overview.html title="Maude Project Page" target=_blank rel=noopener>Maude</a>, a framework for program specification and verification, and consists of both a static and a dynamic checker. It uses a <em>Maude</em> specification to declare units of measure within the C programming language, and a special <code>/*U U*/</code> comment syntax for annotating the code.</p><p>The following snippet was taken from the paper to demonstrate the annotation of functions and variables:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>float lb2kg(float w) /*U assert unit(w) = lb U*/ /*U assume returns kg U*/ { return 10 * w / 22; } float projectilex, projectiley; projectilex = 0; /*U assume unit(projectilex) = meter U*/ projectiley = 0; /*U assume unit(projectiley) = unit(projectilex) U*/
</span></span></code></pre></td></tr></table></div></div><p>The system&rsquo;s dynamic checker interprets the enriched C program and checks the units of variables when they are evaluated. This adds some storage and run-time overhead. The static checker covers all reachable code, but may generate a large number of false alarms in the absence of annotations.</p><h2 id=guo--mccamant>Guo & McCamant</h2><p>In 2005, Philip Guo and Stephen McCamant presented a technique for <a class=link href=https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-883-program-analysis-fall-2005/projects/unit_type_infere.pdf title="PDF: Annotation-less Unit Type Inference for C" target=_blank rel=noopener>annotation-less type inference for C</a> that automatically assigns and verifies unit types to all of a program&rsquo;s variables.</p><p>One interesting aspect of their tool is that it does not assume any particular unit system, but instead builds up a set of constraints over all variables based on static code analysis. From these, a system with the minimum number of unspecified base units is then constructed. The user may, but is not required to annotate them with more specific names.</p><p>This approach has the major advantage that programmers can construct a complete unit typing with a minimal number of annotations. It also allows for verifying the unit correctness of existing programs without modifying the programs themselves.</p><p>For example, take the following C program:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>int main() { double mass, velocity, height, kinetic, potential; /* ... initialize relevant variables ... */ kinetic = 0.5 * mass * velocity * velocity; potential = mass * height * 9.8; printf(&#34;Total energy is: %g J\n&#34;, kinetic + potential); return 0; }
</span></span></code></pre></td></tr></table></div></div><p>Based on the constraints imposed by the addition and multiplication operations in this code, the tool may produce the following results:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Variables: 1: velocity Units: (unit 1) 2: mass Units: (unit 2) 3: constant 0.5 Units: (unit 3) 4: constant 9.8 Units: (unit 4) 5: height Units: (unit 1)^2 * (unit 3) * (unit 4)^-1 6: kinetic, potential Units: (unit 1)^2 * (unit 2) * (unit 3)
</span></span></code></pre></td></tr></table></div></div><p>Since the inferred unit names are largely meaningless, the user may annotate them with physics terms, such as:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Variables: 1: velocity Units: meter second^-1 2: mass Units: kilogram 3: constant 0.5 Units: dimensionless 4: constant 9.8 Units: meter second^-2 5: height Units: meter 6: kinetic, potential Units: kilogram meter^2 second^-2
</span></span></code></pre></td></tr></table></div></div><p>In practice, only four of the six units need to be annotated, because the tool can infer the derived units automatically. These annotations are then used for human readable error messages when parsing additional code.</p><h2 id=osprey>Osprey</h2><p>The <a class=link href=http://web.cs.ucdavis.edu/~su/unitfull.pdf title="PDF: Osprey: A Practical Type System for Validating Dimensional Unit Correctness of C Programs" target=_blank rel=noopener>Osprey</a> type system adds special unit annotations to C code that are parsed and converted to type constraints and evaluated at compile time. The system focuses on the SI system of measurement and implements the seven base units from which all other scientific units can be derived.</p><p>Unit annotations start with a <code>$</code> character and support superscripts for exponentiation. Some units also have aliases, such as <code>kilogram</code> and <code>kg</code>. The special unit type <code>$unity</code> is used for dimensionless units.</p><p>The following code declares a variable &rsquo;length&rsquo; with base unit &lsquo;meter&rsquo;, a variable &rsquo;energy&rsquo; with derived units, and a structure containing a dimensionless quantity.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$meter double length; $kilogram*meterÂ²*secondâ»Â² double energy; typedef struct { $kilogram double atomicWeight; $unity double atomicNumber; } Element;
</span></span></code></pre></td></tr></table></div></div><p>A constraint resolution algorithm uses these annotations to verify the correctness of the rest of the program.</p><h2 id=unitc>Unitc</h2><p><a class=link href=https://github.com/magnusjonsson/unitc title="unitc on GitHub" target=_blank rel=noopener>unitc</a> is a pre-processor written in Haskell with unit annotations in a different syntax. The following is a valid program that declares annotated velocity and time variables and computes an acceleration from them:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>double v unit(m/s); double t unit(s); double a unit(m/s/s) = v / t;
</span></span></code></pre></td></tr></table></div></div><p>The current implementation only supports base units. These are not hard-coded, but derived from the annotations. It doesn&rsquo;t support prefixes or aliases, and the notation for exponentiation is rather limiting.</p><h1 id=c-1>C++</h1><p>As might be expected, the template meta-programming features of C++ encouraged a number of compile and run-time dimensional analysis libraries. A search on GitHub reveals over a dozen, and many more can be found on the internet. Most implementations are more or less variations of each other, so we will only look at some representative examples.</p><h2 id=boost>Boost</h2><p>One of the most prominent implementations is <a class=link href=http://www.boost.org/doc/libs/1_65_0/doc/html/boost_units.html title="Official Boost.Units documentation" target=_blank rel=noopener>Boost.Units</a>. It uses compile-time metaprogramming techniques to implement generic and extensible unit systems that do not incur any run-time overhead.</p><p>Like most Boost libraries, Boost.Units is very comprehensive, extremely flexible, and tries to cover all posssible use and edge cases. The library does not only check the validity of unit calculations at compile-time, but also allows for compile-time unit calculations according to dimensional analysis rules inside template meta-programs.</p><p>The following lines are excerpts from the definition of a simple meter-kilogram-second unit system:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>struct length_base_dimension : base_dimension { }; struct mass_base_dimension : base_dimension { }; struct time_base_dimension : base_dimension { }; typedef length_base_dimension::dimension_type length_dimension; typedef mass_base_dimension::dimension_type mass_dimension; typedef time_base_dimension::dimension_type time_dimension; typedef derived_dimension::type area_dimension; typedef derived_dimension::type energy_dimension; struct meter_base_unit : base_unit { }; struct kilogram_base_unit : base_unit { }; struct second_base_unit : base_unit { }; typedef make_system&lt; meter_base_unit, kilogram_base_unit, second_base_unit&gt;::type mks_system; typedef unit dimensionless; typedef unit length; typedef unit mass; typedef unit time; BOOST_UNITS_STATIC_CONSTANT(meter, length); BOOST_UNITS_STATIC_CONSTANT(meters, length); BOOST_UNITS_STATIC_CONSTANT(kilogram, mass); BOOST_UNITS_STATIC_CONSTANT(kilograms, mass); BOOST_UNITS_STATIC_CONSTANT(second, time); BOOST_UNITS_STATIC_CONSTANT(seconds, time); template&lt;&gt; struct base_unit_info { static std::string name() { return &#34;meter&#34;; } static std::string symbol() { return &#34;m&#34;; } }; template&lt;&gt; struct base_unit_info { static std::string name() { return &#34;kilogram&#34;; } static std::string symbol() { return &#34;kg&#34;; } }; template&lt;&gt; struct base_unit_info { static std::string name() { return &#34;second&#34;; } static std::string symbol() { return &#34;s&#34;; } };
</span></span></code></pre></td></tr></table></div></div><p>Unit systems defined in this way may then be used as follows:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>quantity L(2.0 * meters); quantity E = kilograms * pow&lt;2&gt;(L / seconds); quantity &gt; L(std::complex(3.0, 4.0) * meters); quantity &gt; E(kilograms * pow&lt;2&gt;(L / seconds)); const double dimless = (L/L);
</span></span></code></pre></td></tr></table></div></div><p>Note that scientific calculations can be performed out of the box, because the library already includes complete definitions for the SI and CGS unit systems, supports angle and temperature measurements in various units, and provides fine-grained conversions between them.</p><p>For a complete description of all features along with numerous examples check out the official documentation.</p><h2 id=cpp-measures>cpp-measures</h2><p>Carlo Milanesi&rsquo;s <a class=link href=https://github.com/carlomilanesi/cpp-measures title="cpp-measures on GitHub" target=_blank rel=noopener>cpp-measures</a> is a header-only library for compile-time dimensional analysis using C++ templates. The only pre-defined unit of measure is <code>radians</code>. All others must be defined by the user, for example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>MEASURES_MAGNITUDE(Length, metres, &#34; m&#34;) MEASURES_UNIT(km, Length, &#34; Km&#34;, 1000, 0) MEASURES_UNIT(cm, Length, &#34; cm&#34;, 0.01, 0)
</span></span></code></pre></td></tr></table></div></div><p>The following example code demonstrates the definition and usage of physical quantities, as well as conversions between units:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vect1 a(6); vect1 work = vect2(12, 13) * vect2(3, 5); vect1 t = convert(vect1(90));
</span></span></code></pre></td></tr></table></div></div><p>Support for vector quantities is built into the library and limited to a maximum of three dimensions:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>point3 b(7, 8, 9);
</span></span></code></pre></td></tr></table></div></div><p>This may seem like a surprising design choice at first, but it enables some interesting calculations. For example, it allows energy to be expressed in relation to vector quantities:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vect1 e = vect2(12, 13) * vect2(3, 5);
</span></span></code></pre></td></tr></table></div></div><p>Note that the <code>*</code> operator is defined as the dot product here.</p><h2 id=dimentia>Dimentia</h2><p><a class=link href=https://www.cs.cmu.edu/~sboucher/dimentia.pdf target=_blank rel=noopener>Dimentia</a> is a system that implements a static analysis pass for LLVM in order to perform consistency checks without requiring any input from the programmer. It does so by associating with each program variable a so called <em>scalar deggree</em>, which is the sum of exponents of a type&rsquo;s units. These are solely derived from the operations on the variables.</p><p>Due to its approach, the system cannot detect semantic errors in isolation, but it can successfully detect confliting usages of variables in larger programs without having to know their intended semantics.</p><h2 id=quantity>Quantity</h2><p>Michael Kenniston&rsquo;s <a class=link href=http://home.xnet.com/~msk/quantity/quantity.html target=_blank rel=noopener>Quantity</a> is a portable header-only C++ template library for compile-time verification of computations with physical quantities. It includes a <code>quantity</code> template type with a fixed set of seven dimensions for modelling the SI system, a comprehensive collection of base and derived units and quantities, arithmetic operations over quantities, SI prefixes, and some support for I/O and unit conversion.</p><p>Magnitudes are internally represented as <code>double</code> by default, but the behavior can be overriden with a compiler directive. The following code is taken from the library to illustrate how it defines these aspects:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>typedef dimensions&lt;1, 0, 0, 0, 0, 0, 0&gt; length_d; typedef dimensions&lt;0, 0, 1, 0, 0, 0, 0&gt; time_interval_d; typedef dimensions&lt;1, 0, -1&gt; speed_d; inline Rep milli() { return Rep(1e-3L); } inline Rep kilo() { return Rep(1e+3L); } inline quantity kilogram() { return quantity(detail::permit(Rep(1.0))); } inline quantity gram() { return kilogram() / 1000; } inline quantity newton() { return meter() * kilogram() / square(second()); }
</span></span></code></pre></td></tr></table></div></div><p>The following lines demonstrate the usage of the library:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>quantity width(1.2f * meter()); quantity height(2.3f * meter()); quantity area(width * height); quantity speed = height / second(); quantity vol = cube(height); double r = width / height; double s = speed * (second() / meter()); quantity e = 42 * kilo() * watt() * hour(); std::cout &lt;&lt; e; // &#34;42 m+2 kg s-2&#34;
</span></span></code></pre></td></tr></table></div></div><p><a class=link href=https://github.com/martinmoene/PhysUnits-CT-Cpp11 target=_blank rel=noopener>PhysUnits</a> is an adaption of Quantity for C++11. One of the interesting improvements is the added support for user-defined literals, so that quantities can be written more concisely as <code>1_ns</code> or <code>42_km</code>.</p><p><a class=link href=https://github.com/martinmoene/PhysUnits-CT target=_blank rel=noopener>PhysUnits-CT</a> and <a class=link href=https://github.com/martinmoene/PhysUnits-RT target=_blank rel=noopener>PhysUnits-RT</a> are versions of PhysUnits for C++98 and for run-time evaluation. The latter increases the number of supported dimensions to 10 and stores them alongside values:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>quantity F(2.0 * newton()); quantity dx(2.0 * meter()); quantity E(work(F, dx)); std::cout &lt;&lt; E; // &#34;4 J&#34;
</span></span></code></pre></td></tr></table></div></div><h2 id=siunits>SIunits</h2><p>Walter E. Brown&rsquo;s <em>SIunits</em> is a template based C++ library for compile-time checking of physical units. The initial version was introduced in the 1998 paper <a class=link href=https://pdfs.semanticscholar.org/8d7a/b4a389a5a8b99594255b4197b11f199a5991.pdf target=_blank rel=noopener>Introduction to the SI Library of Unit-Based Computation</a>. It has no run-time overhead, includes a large number of pre-defined units, and allows for user defined calibration of base units to accommodate for different precisions/magnitudes.</p><p>As a somewhat unique feature, the library also offers five different models for base units to enable calculations from different physical view points, i.e. high-energy, relativistic, or quantum.</p><p>The API assumes that values are represented as <code>double</code>, but also allows for custom value types via template parameters.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Length d1(2.5); // 2.5 meters; same as 2.5 * m Length d2(1.2 * cm); // 1.2 centimeters; recorded as .012 * m Width d3(1.23 * pico_ * meter); // 1.23e-12 * m; Width is a synonym for Length Length d4(d1 + d2); Area a1(d1 * d2);
</span></span></code></pre></td></tr></table></div></div><p>Like many other libraries, SIunits encodes a unit type&rsquo;s dimensions in a 7-tuple that holds the exponent for each dimension. Early implementations used seven integer template parameters, but those were later refined to take a type list of compile-time rational numbers, which permit a broader range of dimensional exponents and cover computations involving roots:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Mass&lt;&gt; m = 100 * kilogram; Energy&lt;&gt; e = m * c * c; Velocity&lt;&gt; v = sqrt(e) / sqrt(m);
</span></span></code></pre></td></tr></table></div></div><p>The implementation details can be found in the 2002 paper <a class=link href=https://www.semanticscholar.org/paper/Applied-Template-Metaprogramming-in-SIunits-Brown/3958f4a6dac0fbfed4be87a891df444ed31dd7c3 target=_blank rel=noopener>Applied Template Metaprogramming in SIunits</a>.</p><h1 id=d>D</h1><p>The inclusion of dimensional analysis support in the Phobos standard library <a class=link href=https://forum.dlang.org/thread/io1vgo%241fnc%241@digitalmars.com target=_blank rel=noopener>has been discussed</a> for several years and seems to be an ongoing effort. So far there have been only a couple major community projects.</p><h2 id=quantities>quantities</h2><p>Nicolas Sicard&rsquo;s <a class=link href=https://github.com/biozic/quantities target=_blank rel=noopener>quantities</a> library supports both compile-time and run-time checking of units of measures and includes a comprehensive set of SI units, unit symbols, and prefixes.</p><p>Compile-time support is provided via a <code>Quantity</code> template that wraps a generic scalar value into a struct whose type contains a vector of dimensions. The dimension vector is used to statically check for dimensional consistency, and it has zero storage and run-time overhead:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>auto kilometer = kilo(meter); auto distance = 384_400 * kilometer; auto speed = si!&#34;299_792_458 m/s&#34;; Time time = distance / speed; writeln(siFormat!&#34;%.3f s&#34;(time)); // &#34;1.282 s&#34;
</span></span></code></pre></td></tr></table></div></div><p>For run-time support, the library introduces a generic <code>QVariant</code> type that stores the vector of dimensions in a member field instead, and inconsistent calculations throw an exception:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>auto distance = qVariant(384_400 * kilo(meter)); auto speed = parseSI(&#34;299_792_458 m/s&#34;); auto time = distance / speed; writeln(siFormat!&#34;%.3f s&#34;(time)); // &#34;1.282 s&#34;
</span></span></code></pre></td></tr></table></div></div><p>To some extent, <code>Quantity</code> and <code>QVariant</code> can be used together in the same expression. The parser used to read quantities from strings is extensible.</p><h2 id=stdunits>std.units</h2><p>David Nadlinger&rsquo;s <a class=link href=http://klickverbot.at/code/units/std_units.html target=_blank rel=noopener>std.units</a> (<a class=link href=https://github.com/klickverbot/phobos/blob/units/std/units.d target=_blank rel=noopener>GitHub</a>) is a library for compile-time checking of units of measurements. It does not define any system of measurement out of the box, but provides a set of mixins for creating user defined base, derived, scaled, and affine units:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>alias BaseUnit!(&#34;Ampere&#34;, &#34;A&#34;) Ampere; enum ampere = Ampere.init; // or enum ampere = baseUnit!(&#34;Ampere&#34;, &#34;A&#34;); alias DerivedUnit!( BaseUnitExp!(Ampere, Rational!1), BaseUnitExp!(Second, Rational!1) ) Coulomb; enum coulomb = Coulomb.init; // or enum coulomb = ampere * second; alias ScaledUnit!(Metre, 0.0254, &#34;inch&#34;, &#34;in&#34;) Inch; // or alias ScaledUnit!(metre, 0.0254, &#34;inch&#34;, &#34;in&#34;) Inch; // or enum inch = scale!(metre, 0.0254, &#34;inch&#34;, &#34;in&#34;); enum celsius = affine!(273.15, &#34;degrees Celsius&#34;, &#34;Â°C&#34;)(kelvin);
</span></span></code></pre></td></tr></table></div></div><p>The unit dimensions are encoded into the types. Prefixes are implemented as templates and helper functions that can also be generated automatically:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>alias PrefixSystem!(10, { return [ Prefix(-3, &#34;milli&#34;, &#34;m&#34;), Prefix(3, &#34;kilo&#34;, &#34;k&#34;)]; }) System; alias prefixTemplate!(-3, System) milli; alias prefixTemplate!(3, System) kilo;
</span></span></code></pre></td></tr></table></div></div><p>The following are usage examples for code with units:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>enum squareMetre = pow!2(metre); enum celsius = affine!(273.15, &#34;degrees Celsius&#34;, &#34;Â°C&#34;)(kelvin); Quantity!(metre, int) x = 6 * metre; auto speed = x / second; assert(l / metre == 6 * dimensionless); auto il = cast(Quantity!(metre, int))x; auto a = pow!2(5 * metre);
</span></span></code></pre></td></tr></table></div></div><p>With the <a class=link href=https://github.com/nordlow/units-d target=_blank rel=noopener>units-d</a> library, Per NordlÃ¶w attempted to combine <em>std.units</em> with the expression parsing capabilities of <em>quantities</em>.</p><h1 id=eiffel>Eiffel</h1><h2 id=eiffelunits>EiffelUnits</h2><p><a class=link href=http://se.inf.ethz.ch/old/projects/markus_keller/EiffelUnits.html title="EiffelUnits Homepage" target=_blank rel=noopener>EiffelUnits</a> is a library for the <em>Eiffel</em> programming language that allows for attaching units to quantities. It includes a set of common scientific units, but can be extended with user defined unit types. The following code snippet declares a constant for gravitational acceleration:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Gravity: QUANTITY is -- gravitational acceleration on earth surface once Result := quantity (9.81) * m / (s ^ 2) ensure Result.has_dimension (dim.Acceleration) end
</span></span></code></pre></td></tr></table></div></div><p><code>QUANTITY</code> is a generic type that can hold any combination of unit and quantity. New types of quantities can be created by multiplying and dividing existing base or derived quantities.</p><p><code>dim.Acceleration</code> is a predefined instance of the dimension class provided by the library. Each class provides ready to use units, such as <code>m</code>, <code>s</code> and <code>kg</code>. There are also complex derived classes for units with special names, such as <code>N</code> for Newtons.</p><p>Usage of quantities follows along similar lines:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>feature {NONE} -- Initialization make (mass_1_: QUANTITY; mass_2_: QUANTITY) is -- Load the machine require is_mass_1: mass_1_.commensurate_with (kg) is_mass_2: mass_2_.commensurate_with (kg) do mass_1 := mass_1_ mass_2 := mass_2_ end feature -- Access mass_1: QUANTITY mass_2: QUANTITY acceleration_1: QUANTITY is -- acceleration of mass 1 do Result := (mass_2 - mass_1) / (mass_1 + mass_2) * Gravity ensure Result.commensurate_with (m * s^-2) end
</span></span></code></pre></td></tr></table></div></div><p>The library performs all semantic validation at run-time. The information needed for this is carried in the instances of quantities. There is no mechanism for checking the correctness of code at compile-time.</p><h1 id=excel>Excel</h1><p>Although technically not programming languages, spreadsheets are similar to declarative functional languages with reactive semantics. They are used as a tool in many financial, engineering and scientifc applications, and therefore the automatic detection of unit errors can be desirable.</p><h2 id=xelda>XeLda</h2><p>In <a class=link href=https://dl.acm.org/citation.cfm target=_blank rel=noopener>Validating the Unit Correctness of Spreadsheet Programs</a> (<a class=link href=https://cs.brown.edu/~sk/Publications/Papers/Published/asknf-valid-unit-sprdsht/ target=_blank rel=noopener>PDF</a>) from 2004, Tudor Antoniu et. al. describe a standalone prototype tool for unit checking Excel spreadsheets. Users may annotate spreadsheet cells that contain either values or formulas with a (possibly empty) list of unit names and associated exponents.</p><p>For example, an annotation for a force value could be:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>((kilogram 1) (meter 1) (second -2))
</span></span></code></pre></td></tr></table></div></div><p>The names of units are arbitrary, and their order is not important. The tool parses the cells and annotations in a bottom-up fashion, generates and evaluates unit constraints, and then colors any cells with with consistency errors. It also provides a textual explanation.</p><p><img src=https://gmpreussner.com/user/pages/04.research/dimensional-analysis-in-programming-languages/_excel/xelda.png loading=lazy alt="Unit Errors in Excel Spreadsheet"></p><h1 id=fortran>Fortran</h1><p>Fortran continues to be the predominant programming language of the physical sciences. Surprisingly though, the representation of physical units had not been addressed systematically until more recently.</p><h2 id=physunits>PHYSUNITS</h2><p>Grant Petty developed a <a class=link href=http://sleet.aos.wisc.edu/~gpetty/gpetty//physunits.html title="Project page for Automated Computation and Consistency Checking of Physical Dimensions and Units in Scientific Program" target=_blank rel=noopener>software package</a> (<a class=link href=http://onlinelibrary.wiley.com/doi/10.1002/spe.401/abstract title="Wiley Online Library: Automated computation and consistency checking of physical dimensions and units in scientific programs" target=_blank rel=noopener>paper</a>) that adds automated computation and consistency checking of physical dimensions and units to Fortran 90. The implementation has a run-time cost for computations and storage, because dimension information is carried alongside numerical values in additional memory and computed by overloaded operators.</p><p>The module implements a number of SI units, which are represented as constants, such as <code>u_meter</code>. The following is a valid program that declares velocity, mass and acceleration to compute various energies:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>v = 10.0*u_meter/u_second m = 5.0*u_kilogram g = 9.807*u_meter/(u_second**2) kinetic_energy = 0.5*m*v**2 potential_energy = m*g total_energy = kinetic_energy + potential_energy
</span></span></code></pre></td></tr></table></div></div><h1 id=fortress>Fortress</h1><p>The discontinued language <a class=link href=https://en.wikipedia.org/wiki/Fortress_%28programming_language%29 title="Wikipedia: Fortress" target=_blank rel=noopener>Fortress</a>, a DARPA funded research project started by Sun Microsystems and later slashed by Oracle, had syntax support for dimensional analysis. Of particular interest are the <code>dim</code> and <code>unit</code> keywords that are used to declare dimensions and units respectively.</p><p>The language has largely disappeared from the internet, and most of the original <a class=link href=https://web.archive.org/web/20080318151108/http://research.sun.com:80/projects/plrg/Publications/ title="WaybackMachine: Publications and Fortress Specifications" target=_blank rel=noopener>related publications</a> are no longer available. Some up to date details can be found in the <a class=link href=http://www.ccs.neu.edu/home/samth/fortress-spec.pdf title="PDF: The Fortress Language Specification" target=_blank rel=noopener>language specification</a> and a chapter in the <a class=link href=https://www.amazon.com/Encyclopedia-Parallel-Computing-Springer-Reference/dp/0387097651/ title="Amazon: Encyclopedia of Parallel Computing" target=_blank rel=noopener>Encyclopedia of Parallel Computing</a>.</p><p>The following code demonstrates the declaration of base and derived dimensions, base and derived units with and without scaling, as well as their use in program statements:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>dim Length default meter (* base dimensions *) dim Time default second dim Velocity = Length/Time (* derived dimension *) unit meter m: Length (* base units *) unit second s: Time unit joule J: Energy = newton meter (* derived unit without scaling *) unit centimeter cm: Length = 10â»Â² meter (* derived unit with scaling *) d: RR64 Length = 2 m_ t: RR64 Time = 4 s_ v:= d / t (* 0.5 m_/s_ *)
</span></span></code></pre></td></tr></table></div></div><h1 id=frink>Frink</h1><p>Another language with built-in support is <a class=link href=https://frinklang.org/ title="Frink Homepage" target=_blank rel=noopener>Frink</a>, although it is more of a tool for physics calculations than a general purpose programming language. Units of measure and unit conversion are a major pillar of the language&rsquo;s design and largely driven by a <a class=link href=https://frinklang.org/frinkdata/units.txt title="Frink Data File" target=_blank rel=noopener>data file</a> consisting of predefined units, prefixes, constants and relationships.</p><p>The following code demonstrates the declaration and usage of variables:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mass = 2 kg gravity = 9.81 m/s^2 force = mass * gravity // 19.62 kg m/s^2 force2 = 19.62 newton // same as &#39;force&#39;
</span></span></code></pre></td></tr></table></div></div><p>The author has put considerable effort into analyzing the pitfalls and ambiguities of representing physical dimensions in computer programs using standard mathematical notation and orthography. The language also has some other interesting features that make it worth a look.</p><h1 id=f>F#</h1><p>The first general purpose (and hitherto only mainstream) programming language with built-in support for static checking and inference of units of measure is F#. Andrew Kennedy&rsquo;s blog has a <a class=link href=https://blogs.msdn.microsoft.com/andrewkennedy/2008/08/29/units-of-measure-in-f-part-one-introducing-units/ title="Units of Measure in F#" target=_blank rel=noopener>brief overview</a> (<a class=link href=https://blogs.msdn.microsoft.com/andrewkennedy/2008/09/02/units-of-measure-in-f-part-two-unit-conversions/ target=_blank rel=noopener>Part 2</a>, <a class=link href=https://blogs.msdn.microsoft.com/andrewkennedy/2008/09/04/units-of-measure-in-f-part-three-generic-units/ target=_blank rel=noopener>Part 3</a>) of that particular feature. You might also want to read his <a class=link href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.538.964&rep=rep1&type=pdf" title="PDF: Types for Units-of-Measure: Theory and Practice" target=_blank rel=noopener>related paper</a> and <a class=link href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.93.807&rep=rep1&type=pdf" title="PDF: Programming Languages and Dimensions" target=_blank rel=noopener>dissertation</a> for some more theoretical background.</p><p>The language provides a <code>Measure</code> attribute that enables the declaration of measurement types, which can then be used to annotate numerical values using an angle bracket notation. Derived units are type aliases for algebraic combinations of base units. The language also supports unit conversions, dimensionless quantities and generic functions.</p><p>The following code declares base and derived unit types and demonstrates their semantic equivalency when used in program statements:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[] type kg // declaration of base unit types [] type m [] type s let mass = 2.0 let gravity = 9.81 let force = mass * gravity // 19.62 [] type N = kg m/s^2 // declaration of derived unit type let force2 = 19.62 // same as &#39;force&#39;
</span></span></code></pre></td></tr></table></div></div><h1 id=haskell>Haskell</h1><p>Haskell&rsquo;s strong static typing and widespread use in the scientific community make it a prime candidate for researching dimensional analysis in programming languages. A number of different solutions exist, and the most popular ones are presented below.</p><h2 id=boyer>Boyer</h2><p>Stephan Boyer presented a <a class=link href=https://www.stephanboyer.com/post/131/type-safe-dimensional-analysis-in-haskell title="Stephan Boyer's blog" target=_blank rel=noopener>simple approach</a> using function spaces. It has a few limitations, such as an awkward construct/destruct syntax and a need to arrange arguments of unit operations in the right order.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type Length = BaseQuantity Meter tableWidth :: Length tableWidth = construct 1.5 tableHeight :: Length tableHeight = construct 2.5 tableArea :: Area tableArea = tableWidth .*. tableHeight
</span></span></code></pre></td></tr></table></div></div><h2 id=dimensional>dimensional</h2><p>The <a class=link href=https://github.com/bjornbm/dimensional/ title="dimensional on GitHub" target=_blank rel=noopener>dimensional</a> package (<a class=link href=https://hackage.haskell.org/package/dimensional title="dimensional on Hackage" target=_blank rel=noopener>Hackage</a>) is a recent dimensional analysis implementation that has a slightly more familiar syntax based on <em>Closed Type Families</em> and <em>Data Kinds</em> for dimension tracking.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>leg :: Length Double leg = 1 *~ mile speeds :: [Velocity Double] speeds = [60, 50, 40, 30] *~~ (kilo meter / hour)
</span></span></code></pre></td></tr></table></div></div><h2 id=physics>physics</h2><p>The <a class=link href=http://haskell-libs.cvs.sourceforge.net/haskell-libs/libs/physics/ title="SourceForge: haskell-libs physics" target=_blank rel=noopener>physics</a> Haskell package is the oldest implementation of dimensional analysis in Haskell that I could find. It is fairly simple and limited.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>test1 :: Velocity -&gt; Time -&gt; Length test1 m n = mult m n test2 :: Length -&gt; Time -&gt; Velocity test2 m n = divide m n
</span></span></code></pre></td></tr></table></div></div><h2 id=units-1>units</h2><p>The <a class=link href=https://github.com/goldfirere/units title="units on GitHub" target=_blank rel=noopener>units</a> package (<a class=link href=https://hackage.haskell.org/package/units title="units on Hackage" target=_blank rel=noopener>Hackage</a>) is a more sophisticated solution that provides a fully extensible embedded type system with support for independent notions of dimensions and unit, inter-convertible units of the same dimension, unit-polymorphic programs, and unit prefixes. It also includes definitions for SI units.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-zed data-lang=zed><span class=line><span class=cl><span class=o>--</span><span class=w> </span><span class=n>dimension</span><span class=w> </span><span class=kt>definition</span><span class=w> </span><span class=n>data</span><span class=w> </span><span class=n>LengthDim</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>LengthDim</span><span class=w> </span><span class=n>instance</span><span class=w> </span><span class=n>Dimension</span><span class=w> </span><span class=n>LengthDim</span><span class=w> </span><span class=o>--</span><span class=w> </span><span class=n>derived</span><span class=w> </span><span class=n>dimension</span><span class=w> </span><span class=n>type</span><span class=w> </span><span class=n>VelocityDim</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>LengthDim</span><span class=w> </span><span class=o>:/</span><span class=w> </span><span class=n>TimeDim</span><span class=w> </span><span class=o>--</span><span class=w> </span><span class=n>unit</span><span class=w> </span><span class=kt>definition</span><span class=w> </span><span class=n>data</span><span class=w> </span><span class=n>Meter</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Meter</span><span class=w> </span><span class=n>instance</span><span class=w> </span><span class=n>Unit</span><span class=w> </span><span class=n>Meter</span><span class=w> </span><span class=n>where</span><span class=w> </span><span class=n>type</span><span class=w> </span><span class=n>BaseUnit</span><span class=w> </span><span class=n>Meter</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Canonical</span><span class=w> </span><span class=n>type</span><span class=w> </span><span class=n>DimOfUnit</span><span class=w> </span><span class=n>Meter</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>LengthDim</span><span class=w> </span><span class=o>--</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=n>type</span><span class=w> </span><span class=kt>definition</span><span class=w> </span><span class=n>type</span><span class=w> </span><span class=n>Length</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>MkQu_DLN</span><span class=w> </span><span class=n>LengthDim</span><span class=w> </span><span class=n>LCSU</span><span class=w> </span><span class=n>Double</span><span class=w> </span><span class=o>--</span><span class=w> </span><span class=n>values</span><span class=w> </span><span class=n>and</span><span class=w> </span><span class=n>prefixes</span><span class=w> </span><span class=n>len</span><span class=w> </span><span class=o>::</span><span class=w> </span><span class=n>Length</span><span class=w> </span><span class=n>len</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=err>3</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=n>Meter</span><span class=w> </span><span class=n>longLen</span><span class=w> </span><span class=o>::</span><span class=w> </span><span class=n>Length</span><span class=w> </span><span class=n>longLen</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=err>150</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=n>kilo</span><span class=w> </span><span class=n>Meter</span><span class=w> </span><span class=o>--</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=n>computations</span><span class=w> </span><span class=n>vel</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=err>3</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=n>Meter</span><span class=p>)</span><span class=w> </span><span class=o>|/|</span><span class=w> </span><span class=p>(</span><span class=err>2</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=n>Second</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=uom-plugin>uom-plugin</h2><p>A completely different implementation approach can be found in Adam Gundry&rsquo;s <a class=link href=https://github.com/adamgundry/uom-plugin title="uom-plugin on GitHub" target=_blank rel=noopener>uom-plugin</a> package (<a class=link href=https://hackage.haskell.org/package/uom-plugin title="uom-plugin on Hackage" target=_blank rel=noopener>Hackage</a>). It uses GHC&rsquo;s facility for type checker plug-ins to add support for units of measure. The <a class=link href=http://adam.gundry.co.uk/pub/typechecker-plugins/ title="PDF: A Typechecker Plugin for Units of Measure" target=_blank rel=noopener>accompanying paper</a> describes the ideas behind it in more detail. There is also a brief <a class=link href=https://hackage.haskell.org/package/uom-plugin-0.2.0.1/docs/Data-UnitsOfMeasure-Tutorial.html title="uom-plugin tutorial" target=_blank rel=noopener>tutorial</a> that explains the basics.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gravityOnEarth :: Quantity Double [u| m/s^2 |] gravityOnEarth = [u| 9.808 m/(s*s) |]
</span></span></code></pre></td></tr></table></div></div><h1 id=java>Java</h1><h2 id=metagen>MetaGen</h2><p>In 2004, Eric Allen et. all presented a very comprehensive implementation of <a class=link href="https://dl.acm.org/citation.cfm?id=1029008" target=_blank rel=noopener>Object-oriented units of measurement</a> for Java. At the heart of it lies the observation that dimensions and units have a dual nature in being both types (to statically check expressions) and values (can be multiplied together). They conclude that this necessitates support for generic metaclasses, which they introduce via custom language extensions.</p><p>It is my understanding that the abstraction mechanisms available in Java today are still insufficient to model all desired aspects as proposed without introducing extensions, and it is therefore not an off-the-shelf solution for the general Java programmer. Nevertheless, the paper is worth a read as it covers basic terminology, design challenges and constraints, uncommon edge cases, and a detailed analysis of the underlying problems.</p><p>The paper&rsquo;s summary outlines that their solution allows for parametric and inheritance polymorphism with respect to both dimension and unit types, integration of encapsulated measurement systems, dynamic conversion factors, declarations of scales (including nonlinear scales) with defined zeros, and nonconstant exponents on dimension types.</p><p>In classical Java style, this results in many layers of abstractions, the details of which cannot be explained in a couple paragraphs. The interested reader is therefore referred to the original paper. To illustrate just one aspect of metaclasses, consider the implementation of measurements.</p><p>A metaclass <code>Dimension</code> is introduced to declare instance classes for specific dimensions, which may also have static member functions:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>abstract class Dimension { abstract String shortName(); } Dimension Length { static String shortName() { return &#34;L&#34;; } } Dimension Time { static String shortName() { return &#34;T&#34;; } }
</span></span></code></pre></td></tr></table></div></div><p>Note that <code>Length</code> and <code>Time</code> are also classes. Units are classes that extend dimensions, which means that every unit is associated with its own type:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class* Unit extends D { ... } Unit Minute { ... } Unit Foot { ... } Unit Mile { ... }
</span></span></code></pre></td></tr></table></div></div><p>Measurements are classes that are tied to units:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Measurement U&gt; extends D { private final Real _magnitude; }
</span></span></code></pre></td></tr></table></div></div><p>We can now declare symbols that can be interpreted as both an instance (object) of measurements and a class instance:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Measurement CircumferenceOfEarth { static { container(24889); } }
</span></span></code></pre></td></tr></table></div></div><p>As a result, <code>_magnitude</code> can be either a field on an object, or a static field on a class. In their actual implementation, magnitudes are of generic types (via another class called <code>Unity</code>) and not limited to real numbers.</p><h1 id=lisp>Lisp</h1><h2 id=cunis>Cunis</h2><p>In <a class=link href=https://dl.acm.org/citation.cfm target=_blank rel=noopener>A package for handling units of measure in Lisp</a> (<a class=link href=http://3e8.org/pub/scheme/doc/lisp-pointers/v5i2/p21-cunis.pdf target=_blank rel=noopener>PDF</a>) from 1992, Roman Cunis introduces a <em>Common Lisp</em> package for representing and checking units of measurement at run-time. The paper does not provide any code for implementation and usage examples, but contains some interesting ideas.</p><p>Instead of using vectors to represent unit dimensions, it associates base units with prime numbers that can be multiplied together into ratios to represent compound units. The scaling of units is done at input time, so that all quantities are internally stored in base units.</p><p>It also introduces a compact syntax for defining measures and units:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-zed data-lang=zed><span class=line><span class=cl><span class=p>(</span><span class=n>defmeasure</span><span class=w> </span><span class=n>speed</span><span class=w> </span><span class=p>;</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=n>of</span><span class=w> </span><span class=n>measure</span><span class=w> </span><span class=err>&#34;</span><span class=nn>m/</span><span class=n>s</span><span class=err>&#34;</span><span class=w> </span><span class=p>;</span><span class=w> </span><span class=n>base</span><span class=w> </span><span class=n>unit</span><span class=w> </span><span class=o>:</span><span class=n>units</span><span class=w> </span><span class=p>(</span><span class=err>&#34;</span><span class=nn>km/</span><span class=n>h</span><span class=err>&#34;</span><span class=w> </span><span class=p>;</span><span class=w> </span><span class=n>implicit</span><span class=w> </span><span class=n>unit</span><span class=w> </span><span class=kt>definition</span><span class=w> </span><span class=p>(</span><span class=err>&#34;</span><span class=n>mph</span><span class=err>&#34;</span><span class=w> </span><span class=err>1</span><span class=p>.</span><span class=err>6</span><span class=nn>km/</span><span class=n>h</span><span class=p>)</span><span class=w> </span><span class=p>;</span><span class=w> </span><span class=n>explicit</span><span class=w> </span><span class=n>unit</span><span class=w> </span><span class=kt>definition</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>output</span><span class=o>-</span><span class=n>format</span><span class=w> </span><span class=p>(</span><span class=o>:</span><span class=n>unit</span><span class=w> </span><span class=err>&#34;</span><span class=n>mph</span><span class=err>&#34;</span><span class=p>)</span><span class=w> </span><span class=p>;</span><span class=w> </span><span class=n>all</span><span class=w> </span><span class=n>speeds</span><span class=w> </span><span class=n>printed</span><span class=w> </span><span class=n>scaled</span><span class=w> </span><span class=n>to</span><span class=w> </span><span class=n>mph</span><span class=w> </span><span class=p>)</span><span class=w> 
</span></span></span></code></pre></td></tr></table></div></div><h2 id=novak>Novak</h2><p>In <a class=link href=https://www.cs.utexas.edu/users/novak/units95.pdf target=_blank rel=noopener>Conversion of units of measurement</a> from 1997, Gordon S. Novak Jr. presents algorithms and their implementation for representing, converting, normalizing, and automatic checking of units in <em>GLisp</em>, which is an extension of Lisp with structural abstractions.</p><p>Novak distinguishes between simple and composite units. Simple units include base units (<code>kilogram</code>), named units that can be defined in terms of other units (<code>horsepower</code>), and SI prefixes for scaling (<code>nano</code>). They are associated with a numeric conversion factor to base units.</p><p>Composite units are products or quotients of simple units:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(* 60 (/ mile hour)) ; 60 mph (/ (* 2000 kilo calorie) day) ; 2000 kcal/day
</span></span></code></pre></td></tr></table></div></div><p>Simple and composite units along with their scaling factors and aliases can be defined as follows:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(defsimpleunits `length `((meter 1.0 (m meters))) (foot 0.3048 (ft feet)) (angstrom 1.0e-10 (a angstrom))) (defderivedunits `force `((newton (/ (* kilogram meter) (* second second)) (nt netwons)) (pound-force (/ (* slug foot) (* second second)) (lbf))))
</span></span></code></pre></td></tr></table></div></div><p>The package provides aliases for common simple and composite units, such as <code>kg</code>, <code>mph</code>, and <code>tablespoons</code>. Quantities for physical constants are defined by packaging them together:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>`(q 2.997 (/ meter second)) ; 2.997 m/s
</span></span></code></pre></td></tr></table></div></div><p>Units can be converted into each other:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(glconvertunit &#39;kilogram &#39;lb) ; 1 kg = 2.20462 lb (glconvertunit &#39;(/ (* 2000 kilo calorie) day) &#39;watt) ; 2000 kcal/day = 96.85185 W
</span></span></code></pre></td></tr></table></div></div><p>Units can also be simplified, so that they have at most one <code>/</code> at the top, or use common names:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(glsimplifyunit `(/ meter foot)) ; 3.280839895013123 (glsimplifyunit `(/ joule watt)) ; SECOND (glsimplifyunit `(/ joule horsepower)) ; (* 0.001341022 SECOND) (glsimplifyunit `(/ (* kilogram meter) (* second second))) ; NEWTON
</span></span></code></pre></td></tr></table></div></div><p>And, of course, the whole point is to be able to use them in functions:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(gldefun test (speed\:(units real (/ (* atto parsec) (* micro fortnight)))) (if (speed &gt; &#39;(q 55 mph)) (print &#34;speeding&#34;)))
</span></span></code></pre></td></tr></table></div></div><p>The package&rsquo;s dimensional analysis facilities combine the seven SI base units and a unit type for monetary values into an 8-vector of integers. Products and quotients of units are calculated as sums and differences of vectors. The paper describes a bit packing scheme to store dimensions in a single 32-bit integer, and it discusses support for generic quantities.</p><p>The code can be downloaded from <a class=link href=https://www.cs.utexas.edu/users/novak/units.html target=_blank rel=noopener>Novak&rsquo;s website</a>, which also has an <a class=link href=https://www.cs.utexas.edu/users/novak/cgi/unitsdemoty.cgi target=_blank rel=noopener>online demo</a> for testing unit conversions in a web browser.</p><h1 id=nemerle>Nemerle</h1><p>Nemerle is a high-level multi-paradigm general purpose programming language for the .NET common language infrastructure with a C# like syntax and powerful metaprogramming support.</p><h2 id=oyster-units>Oyster Units</h2><p>Andriy Kozachuk wrote a small implementation as a learning excercise for converting template code from C++ to Nemerle. It is documented in a <a class=link href=http://rsdn.org/forum/src/1823225.flat#1823225 target=_blank rel=noopener>forum post</a> and uses a combination of classes, attributes and compile-time macros to add support for units. The assembly also contains declarations for common base and derived CGS and SI units.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>def m1 = Cgs.Mass(1); // 1 gram def l1 = Cgs.Length(100); // 100 centimeters def l2 = Si.Length(l1); // auto conversion to 1 meter def t1 = Cgs.Time(1); // 1 second def f3 : Si.Force = m1 * l2 / (t1 * t1);
</span></span></code></pre></td></tr></table></div></div><p>The subsequent forum discussion contains a number of improvements and fixes. The latest version appears to be <a class=link href=http://rsdn.org/File/27948/Oyster.Units.0.05.zip target=_blank rel=noopener>Oyster.Units.0.05</a>.</p><h1 id=nim>Nim</h1><p>Nim is a relatively new programming language and as such did not yet have as much exposure as many of the other languages discussed here. Nevertheless, it has some very interesting capabilities, such as powerful metaprogramming facilities that allow for manipulating the abstract syntax tree at compile time, and generic types where parameters can have algebraic dependencies.</p><p>Existing units of measure implementations are still very scarce and do not use the language&rsquo;s full potential. The <a class=link href=https://github.com/ClementJnc/dimrod target=_blank rel=noopener>dimrod</a> module was one of the earliest attempts that seems to have been abandoned a few years ago.</p><h2 id=metric>metric</h2><p>A recent and more advanced implementation is Michael Jendrusch&rsquo;s <a class=link href=https://github.com/mjendrusch/metric target=_blank rel=noopener>metric</a> package, which ships with an extensible set of SI units, prefixes, and natural constants. It uses a combination of <em>concepts</em> and macros to generate unit types at compile-time.</p><p>Dimensions are encoded as static tuples of arbitrary length. New base units and prefixes can be declared and implemented as follows:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type Length* = object of BaseDimension template `$`*(x: typedesc[Length]): string = &#34;m&#34; template centi*(x: auto): auto = 1e-2 * x const meter = Metric[Length, float](val: 1.0) cm {. used .} = centi m inch = 2.54 * cm
</span></span></code></pre></td></tr></table></div></div><p>Such units can then be used in code and will be verified at compile-time:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>withUnits: var v0 = 40.0 * mile / hour echo &#34;v0 in miles per hour: &#34;, fmt &#34;{v0 as mile / hour} [mph]&#34; echo &#34;v0 in decimeters per fortnight: &#34;, fmt &#34;{v0 as dm / (2.0 * week)} [dm / fortnight]&#34; echo &#34;v0 in SI units: &#34;, v0
</span></span></code></pre></td></tr></table></div></div><p>Note that <code>fmt</code> evaluates an expression to format the output string, and <code>as</code> is a template function for converting unit types.</p><h1 id=pascal>Pascal</h1><p>Dimensions cannot be easily expressed in Pascal&rsquo;s type system, but there have been a number of proposals for physical units support in the late 70&rsquo;s and mid 80&rsquo;s, most notably by <a class=link href=https://dl.acm.org/citation.cfm target=_blank rel=noopener>Gehani</a>, <a class=link href=https://dl.acm.org/citation.cfm target=_blank rel=noopener>MÃ¤nner</a>, <a class=link href=https://dl.acm.org/citation.cfm target=_blank rel=noopener>Dreiheller</a>, and <a class=link href=https://dl.acm.org/citation.cfm target=_blank rel=noopener>Agrawal</a>. Some of these suggestions were later implemented by others.</p><h2 id=baldwin>Baldwin</h2><p>Geoff Baldwin&rsquo;s paper <a class=link href=https://dl.acm.org/citation.cfm target=_blank rel=noopener>Implementation of Physical Units</a> describes an implementation of strong typing with physical units in a minimally extended Pascal compiler. It is not extensible and limited to a small number of units for a specific electrical use case.</p><p>Like many other implementations, Baldwin internally represents units as dimnensionality vectors. He modified the lexer to recognize certain expressions, convert them into appropriate values and synthesize the corresponding dimensionalities. For example, the expression <code>1.2mV</code> is interpreted and stored in the symbol table as <code>1.2e-3</code> of type <code>VOLTAGE</code>.</p><h2 id=vector-pascal>Vector Pascal</h2><p><a class=link href=https://en.wikipedia.org/wiki/Vector_Pascal title="Vector Pascal on Wikipedia" target=_blank rel=noopener>Vector Pascal</a> is an extension of a Pascal compiler with focus on SIMD algorithms. Its type system has built-in support for dimensional analysis. The implementation details are described in Paul Cockshott&rsquo;s <a class=link href=https://pdfs.semanticscholar.org/2633/cc6f3adf86127789e477068c873b970b444e.pdf target=_blank rel=noopener>paper</a>.</p><p>The following example code defines the basis space of a dimensioned type and declares a number of base and derived unit types:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type kms = (mass, distance, time); meter = real of distance; kilo = real of mass; second = real of time; newton = real of mass * distance * time POW -2; meterpersecond = real of distance * time POW -1;
</span></span></code></pre></td></tr></table></div></div><h1 id=perl>Perl</h1><h2 id=datadimensions>Data::Dimensions</h2><p>The <a class=link href=http://search.cpan.org/~ajgough/Data-Dimensions-0.04/lib/Data/Dimensions.pm target=_blank rel=noopener>Data::Dimensions</a> module implements physical values using strongly typed values. Quantities are defined by initializing a <code>Dimensions</code> object with dimensionality exponents and an optional initial value:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$distance = Data::Dimensions-&gt;new( {meter =&gt; 1 } ); # 0 m $time = units( {hour =&gt; 1}, 2 ); # 2 hours $speed = units( {miles =&gt; 1, hour =&gt; -1}, 70 ); # 70 mph
</span></span></code></pre></td></tr></table></div></div><p>Once defined, variables retain their initial units, so that subsequent values can be assigned without specifying unit names. Units of expressions are derived automatically via operator overloading. Operations with untyped values are assumed to have the same unit as the other operand:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>set $speed = 60; # 60 mph set $distance = $speed * $time; # 120 miles set $newspeed = $speed + 10; # 70 mph
</span></span></code></pre></td></tr></table></div></div><p>The module provides a collection of SI and other common units and prefixes, and it also allows for user-defined units.</p><h2 id=mathunits>Math::Units</h2><p><a class=link href=http://search.cpan.org/~jettero/Math-Units-PhysicalValue-1.0009/lib/Math/Units/PhysicalValue.pod target=_blank rel=noopener>Math::Units</a> focuses on automatic conversion of values with compatible units. It is still in an early stage, but already supports prefixes, reductions, conversion factors, along with some optimizations to speed things up at run-time.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>convert(5, &#39;mm&#39;, &#39;in&#39;) # 0.19685 convert(4500, &#39;rpm&#39;, &#39;Hz&#39;) # 75
</span></span></code></pre></td></tr></table></div></div><p>The <a class=link href=http://search.cpan.org/~jettero/Math-Units-PhysicalValue-1.0009/lib/Math/Units/PhysicalValue.pod target=_blank rel=noopener>Math::Units::PhysicalValue</a> module was built on top of <em>Math::Units</em> to provide an object-oriented interface for unit calculations. Internally, it splits and stores value strings separately as an array and evaluates them using overloaded operators.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$height = new Math::Units::PhysicalValue &#34;10,000 ft&#34;; $duration = &#34;43 s&#34;; $speed = $height / $duration; $weight = &#34;180 lbs&#34;; $momentum = ($weight * $speed) + &#34;0 kg*m/s&#34;; print &#34;$momentum\n&#34;; # &#34;5,787.42 kg*m/s&#34; print ($speed + &#34;0 miles/hour&#34;), &#34;\n&#34; # &#34;158.56 miles/hour&#34;
</span></span></code></pre></td></tr></table></div></div><h2 id=physicsunit>Physics::Unit</h2><p>The <a class=link href=http://search.cpan.org/~klortho/Physics-Unit-0.04/lib/Physics/Unit.pm target=_blank rel=noopener>Physics::Unit</a> module is interesting, because it has a couple unusual characteristics. First, it introduces a <code>Unit</code> type that is not only used to represent base and derived units, but also unit prefixes and conversion factors. It combines the conversion factor, a dimensionality vector of ten integers, and an optional list of unit name in a single structure. A unit prefix would be represented as a dimensionless unit with a single name.</p><p>Named &ldquo;units&rdquo;, such as <code>kilo</code>, <code>foot</code>, or <code>mg</code> are constants that do not change at run-time in order to guarantee that their usage in algorithms and derived units remains consistent. For unit values that change at run-time, such as variables or intermediate results, the module uses unnamed units, also called <em>anonymous units</em>.</p><p>Then, the module defines a set of operators, some of which are aliased. It also includes a whitespace operator that allows for the concatenation of prefixes, conversion factors, and units in different ways. In particular, whitespace between two unit names is considered a multiplication, but concatenation without whitespace is also allowed.</p><p>For example, the following notations are all equivalent:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>megaparsec mega parsec kilo kilo parsec kilo**2 parsec square kilo parsec
</span></span></code></pre></td></tr></table></div></div><p>Obviously, this notation allows (if not encourages) the combination of unit prefixes, which is actually prohibited in the SI system. Precedence rules for the various operators are rather complicated and must be studied carefully. For example, the unit for acceleration, m/s2, can be expressed as <code>meters / sec sec</code>, but not <code>meters / sec*sec</code> (the seconds cancel out).</p><p>The module includes a comprehensive set of SI and other common units and prefixes, but also allows for the definition of arbitrary custom unit types of up to ten dimensions. The following are excerpts from its implementation to demonstrate the syntax for defining new base units, prefixes, derived units, and associated data types:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>InitBaseUnit ( &#39;Distance&#39; =&gt; [&#39;meter&#39;, &#39;m&#39;, &#39;meters&#39;], &#39;Mass&#39; =&gt; [&#39;gram&#39;, &#39;gm&#39;, &#39;grams&#39;], &#39;Time&#39; =&gt; [&#39;second&#39;, &#39;s&#39;, &#39;sec&#39;, &#39;secs&#39;, &#39;seconds&#39;], &#39;Current&#39; =&gt; [&#39;ampere&#39;, &#39;amp&#39;, &#39;amps&#39;, &#39;amperes&#39;] ); InitPrefix ( &#39;kilo&#39;, 1e3, &#39;milli&#39;, 1e-3, &#39;mebi&#39;, 2^20, &#39;semi&#39;, 0.5 ); InitUnit ( [&#39;unity&#39;, &#39;one&#39;, &#39;ones&#39;,], &#39;1&#39;, [&#39;hundredth&#39;,], &#39;0.01&#39;, [&#39;percent&#39;, &#39;%&#39;,], &#39;0.01&#39;, [&#39;radian&#39;, &#39;radians&#39;,], &#39;1&#39;, [&#39;degree&#39;, &#39;deg&#39;, &#39;degrees&#39;,], &#39;pi radians / 180&#39;, [&#39;foot&#39;, &#39;ft&#39;, &#39;feet&#39;,], &#39;.3048 m&#39;, [&#39;inch&#39;, &#39;in&#39;, &#39;inches&#39;,], &#39;ft/12&#39;, [&#39;mg&#39;,], &#39;milligram&#39;, [&#39;tesla&#39;, &#39;teslas&#39;], &#39;kg / amp sec^2&#39; ); InitTypes ( &#39;Dimensionless&#39; =&gt; &#39;unity&#39;, &#39;Magnetic_field&#39; =&gt; &#39;tesla&#39;, &#39;Acceleration&#39; =&gt; &#39;m/s^2&#39; );
</span></span></code></pre></td></tr></table></div></div><h1 id=python>Python</h1><p>There exist a substantial number of packages for handling units in Python. Dr. Dobb&rsquo;s online magazine has an <a class=link href=http://www.drdobbs.com/jvm/quantities-and-units-in-python/240161101 target=_blank rel=noopener>overview</a> of the three most prominent ones. A selection of other packages is listed on the homepage of <a class=link href=http://kdavies4.github.io/natu/seealso.html target=_blank rel=noopener>natu</a>, which is not discussed here. Most of these have a similar API and feature set, so I will only cover a few.</p><h2 id=biggs>Biggs</h2><p>In <a class=link href=https://www.researchgate.net/publication/228991349_A_design_for_dimensional_analysis_in_robotics target=_blank rel=noopener>A Design for Dimensional Analysis in Robotics</a> from 2005, Geoffrey Biggs presents the design requirements and custom Python interpreter called <em>RADAR</em> for use in dimensional analysis in robot software.</p><p>Biggs chose to attach unit information to data values, so that they are available at run-time and help verify computations on input operations. The following code demonstrates the definition of dimensions and units:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>dimension.DefineDimension (â€™fasterthanlightâ€™) dimension.DefineUnit (&#39;fasterthanlightâ€™, â€™warpâ€™, UnitPrec_Floating, 1.0, UnitRange_Exclude, 0, UnitRange_Include, 9.9) 
</span></span></code></pre></td></tr></table></div></div><p>The module includes definitions for commonly used units and also supports dimensionless types. Units can be added to scalar values by concatenating them with the <code>~</code> character, and derived units are specified via the <code>*</code>, <code>/</code> and <code>^</code> operators as follows:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>distance = 10~m gravity = 9.81~m/s^2 r = (distance * 10) / 5 - 1~m speed = (r / 1~s) / 10
</span></span></code></pre></td></tr></table></div></div><h2 id=numericalunits>numericalunits</h2><p><a class=link href=https://pypi.org/project/numericalunits/ target=_blank rel=noopener>numericalunits</a> implements units and dimensional analysis with zero run-time overhead in a non-intrusive way, and it works with any numerical calculation routine, including <em>numpy</em> and <em>scipy</em>. Quantities are internally stored as regular integer or floating-point numbers, and dimensions are encoded as multiplicative factors.</p><p>Since no type information is attached to quantities, the package is of somewhat limited use. In particular, there is no way to see what unit a particular quantity is in, and semantic consistency is detected in a rather obscure way that involves running the same program twice and checking whether the output is identical.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>from numericalunits import mL, nm, V, cm, e, me, m, s x = 5 * mL print(x / nm**3) # 5e21 (cubic nanometers) Efield = 1e5 * (V / cm) force = e * Efield # elementary charge accel = force / me print(accel / (m / s**2)) # 1.7588e18
</span></span></code></pre></td></tr></table></div></div><h2 id=pint>Pint</h2><p><a class=link href=https://pypi.org/project/Pint/ target=_blank rel=noopener>Pint</a> includes many physical units, prefixes and constants, and it has no dependencies on other packages. Extensible unit definitions are loaded from text files. It also includes parsing of units and quantities, as well as string formatting routines for pretty printing and LaTeX.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>import pint ureg = pint.UnitRegistry() x = 24.0 * ureg.meter # print(x.magnitude) # 24.0 print(x.units) # meter print(x.dimensionality) # [length] t = 8.0 * ureg.second speed = x / t print(speed) # 3.0 meter / second speed.ito(ureg.inch / ureg.minute) print(speed) # 7086.614173228345 inch / minute user_input = &#39;2.54 * centimeter to inch&#39; src, dst = user_input.split(&#39; to &#39;) q = Q_(src).to(dst) # 
</span></span></code></pre></td></tr></table></div></div><h2 id=scientificpython>ScientificPython</h2><p>Konrad Hinsen&rsquo;s <a class=link href=https://bitbucket.org/khinsen/scientificpython/ target=_blank rel=noopener>ScientificPython</a> is a collection of modules for scientific applications that also provides a data type for representing <a class=link href=https://bitbucket.org/khinsen/scientificpython/src/7fef5df489b0588899a6582a3c62ccde447f8ece/Scientific/Physics/PhysicalQuantities.py target=_blank rel=noopener>physical quantities</a> with units.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>d1 = PhysicalQuantity(&#39;10 m&#39;) d2 = PhysicalQuantity(&#39;10 km&#39;) total = d1 + d2 # PhysicalQuantity(10010.0,&#39;m&#39;) total.convertToUnit(&#39;km&#39;) total.getValue() # 10.01 e = PhysicalQuantity(&#39;2.7 Hartree*Nav&#39;) e.convertToUnit(&#39;kcal/mol&#39;) # PhysicalQuantity(1694.2757596034764,&#39;kcal/mol&#39;) str(e.inBaseUnits()) # &#39;7088849.77818 kg*m**2/s**2/mol&#39;
</span></span></code></pre></td></tr></table></div></div><p>The <em>PhysicalQuantities</em> module has dependencies on other <em>ScientificPython</em> modules. Hans Petter Langtangen isolated the relevant bits into a <a class=link href=https://github.com/hplgit/physical-quantities target=_blank rel=noopener>standalone module</a>, and Georg Brandl ported it <a class=link href=https://bitbucket.org/birkenfeld/ipython-physics target=_blank rel=noopener>for use in IPython</a> notebooks.</p><h2 id=units-2>units</h2><p><a class=link href=https://pypi.org/project/units/ target=_blank rel=noopener>units</a> is yet another Python package for quantities and units that strictly disallows invalid operations. What makes it slightly different from other packages is the way in which instances of units are defined. Newly created units are automatically incompatible with other units, but can be combined via multiplication and division.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>from units import unit metre = unit(&#39;m&#39;) second = unit(&#39;s&#39;) print(metre(10) / second(2)) # 5.00 m / s print(metre(10) ** 3) # 1000.00 m * m * m
</span></span></code></pre></td></tr></table></div></div><p>The package also contains an optional patch that turns the Python interpreter into a unit-enhanced version to enable a more compact syntax:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>print(2cm / 0.5 s) # 4.0 cm / s
</span></span></code></pre></td></tr></table></div></div><h1 id=rust>Rust</h1><p>Rust is a relatively new programming language that has already gathered a large following due to being sponsored by Mozilla. Several solutions for dimensional analysis exist, some of which are described below.</p><h2 id=dimensioned>dimensioned</h2><p><a class=link href=https://github.com/paholg/dimensioned title="dimensioned on GitHub" target=_blank rel=noopener>dimensioned</a> (<a class=link href=https://crates.io/crates/dimensioned/ title="dimensioned on crates.io" target=_blank rel=noopener>crate</a>) is a library for compile-time dimensional analysis with zero run-time cost designed for ease of use (but not necessarily readability). It ships with a somewhat incomplete collection of pre-defined SI, CGS, FPS, and MKS units, and two sets of prefixes, one for 32-bit and one for 64-bit values.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>let length = 6.0 * dim::si::M; let time = 3.0 * dim::si::S; let vel = 2.0 * dim::si::M/dim::si::S; let vel2 = length / time; fn speed(dist: dim::si::Meter, time: dim::si::Second) -&gt; dim::si::MeterPerSecond { dist / time }
</span></span></code></pre></td></tr></table></div></div><p>Custom unit types can be created with a <code>make_units!</code> macro, which is also used to define the built-in systems:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>make_units! { MS; ONE: Unitless; base { M: Meter, &#34;m&#34;, Length; S: Second, &#34;s&#34;, Time; } derived { MPS: MeterPerSecond = (Meter / Second), Velocity; HZ: Hertz = (Unitless / Second), Frequency; M3: Meter3 = (Meter * Meter * Meter), Volume; M5: Meter5 = (Meter3 * Meter * Meter); } constants { FT: Meter = 0.3048; CM: Meter = CENTI * M.value_unsafe; MIN: Second = 60.0; HR: Second = 60.0 * MIN.value_unsafe; PI: Unitless = consts::PI; } fmt = true; }
</span></span></code></pre></td></tr></table></div></div><h2 id=runits>runits</h2><p><a class=link href=https://github.com/jesse99/runits title="runits on GitHub" target=_blank rel=noopener>runits</a> stores unit types and values in a struct and performs validation at run-time. It provides a <code>Unit</code> enumeration with constructors for SI and common unit types, a <code>Compound</code> constructor for creating derived units, a <code>Value</code> struct that packages unit and value, a set of methods on those types, and some helper functions.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>let speed = from_units(30.0, Mile/Hour); let delta = from_units(2.0, Meter/Second); let sum = speed + delta;
</span></span></code></pre></td></tr></table></div></div><h2 id=simple_units>simple_units</h2><p>Another compile-time unit system for Rust is <a class=link href=https://github.com/willi-kappler/simple_units title="simple_units on GitHub" target=_blank rel=noopener>simple_units</a>. It consists of a small set of macros to define unit types, methods on those types, and conversion functions. One interesting aspect of it is that all units, even those for the same dimension, such as meter and foot are distinct types and require conversion functions.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>let length = Meter(20.72); let time = Second(12.39); let velocity = length / time; let duration = Second(35.0); let distance: Meter = velocity * duration; let distance_in_foot = Foot::from(distance);
</span></span></code></pre></td></tr></table></div></div><h2 id=uom>uom</h2><p>One compile-time library with a richer feature set is <a class=link href=https://github.com/iliekturtles/uom title="uom on GitHub" target=_blank rel=noopener>uom</a> (<a class=link href=https://crates.io/crates/uom title="uom on crates.io" target=_blank rel=noopener>crate</a>). The library normalizes all quantities to base units, and the values can be stored in a number of underlying storage types. It includes SI units and supports automatic conversion between units.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>let length = Length::new::(5.0); let time = Time::new::(15.0); let vel = Velocity::new::(3.0); let vel2 = length / time;
</span></span></code></pre></td></tr></table></div></div><p>User defined unit systems can be defined using the included macros:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>#[macro_use] mod length { quantity! { quantity: Length; &#34;length&#34;; dimension: Q; units { @meter: 1.0E0; &#34;m&#34;, &#34;meter&#34;, &#34;meters&#34;; @foot: 3.048E-1; &#34;ft&#34;, &#34;foot&#34;, &#34;feet&#34;; } } } #[macro_use] mod mass { quantity! { quantity: Mass; &#34;mass&#34;; dimension: Q; units { @kilogram: 1.0; &#34;kg&#34;, &#34;kilogram&#34;, &#34;kilograms&#34;; } } } #[macro_use] mod time { quantity! { quantity: Time; &#34;time&#34;; dimension: Q; units { @second: 1.0; &#34;s&#34;, &#34;second&#34;, &#34;seconds&#34;; } } } system! { quantities: Q { length: meter, L; mass: kilogram, M; time: second, T; } units: U { mod length::Length, mod mass::Mass, mod time::Time, } }
</span></span></code></pre></td></tr></table></div></div><h1 id=scala>Scala</h1><h2 id=libra>Libra</h2><p><a class=link href=https://to-ithaca.github.io/libra/ target=_blank rel=noopener>Libra</a> is a dimensional analysis library based on typelevel induction for compile-time verification of units of measure. Zainab Ali wrote a detailed <a class=link href=https://typelevel.org/blog/2017/06/13/libra.html target=_blank rel=noopener>blog post</a> explaining the rationale, implementation and usage of it, so I won&rsquo;t go into too much detail here.</p><p>Dimensions are represented as <a class=link href=http://enear.github.io/2016/04/05/bits-shapeless-1-hlists/ target=_blank rel=noopener>heterogenous type lists</a> with singleton types as exponents on which operations can be performed at run-time in order to derive new unit types that arise during calculations with quantities:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type LightYearSeconds = LightYear :: Second :: HNil type MetresPerSecond = FieldType[Metre, 1] :: FieldType[Second, -1] :: HNil
</span></span></code></pre></td></tr></table></div></div><p>User code generally doesn&rsquo;t have to deal with this verbose notation as the library provides a set of extension methods for common units that can be used directly on scalar values:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>val distance = 3.0.m val time = 2.0.s val speed = distance / time
</span></span></code></pre></td></tr></table></div></div><h2 id=squants>Squants</h2><p><a class=link href=https://github.com/typelevel/squants target=_blank rel=noopener>Squants</a> is a framework of data types and a domain specific language for type and thread-safe compile-time dimensional analysis. It uses regular classes to represent unit types and hence requires boxing and unboxing of values with the associated run-time overhead.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>import squants.energy.{Gigawatts, Kilowatts, Power} import squants.time.{Hours, Days} val ratio = Days(1) / Hours(3) val load = Kilowatts(1.2) val time = Hours(2) val energyUsed = load * time val load2 = load in Gigawatts val s: String = load toString Kilowatts
</span></span></code></pre></td></tr></table></div></div><p>Via implicit conversions, the library provides a DSL that is more akin to scientific notation for simple expressions:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>val load1 = 100 kW val load2 = 100 megawatts val freq = 60 / second val time = 3.hours + 45.minutes // dots required here
</span></span></code></pre></td></tr></table></div></div><p>Ranges are supported out of the box:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>val range1 = 1000.kW to 5000.kW val range2 = 5000.kW plusOrMinus 1000.kW val range2 = 5000.kW +- 1000.kW
</span></span></code></pre></td></tr></table></div></div><p>There is also built-in support for vector quantities, string formatting, and unit simplification. In total, the library currently implements over 250 units for SI, monetary and information quantities.</p><p>Internally, it appears that all the common operations between different unit types, as well as unit conversions are hard-coded. There are some special traits to handle time derivaties, specifically, in a more convenient way.</p><h2 id=supersquants>Supersquants</h2><p>In Scala, <a class=link href=http://dcapwell.github.io/scala-tour/Tag%20Types.html title="Scala Tour: Tag Types" target=_blank rel=noopener>tagged types</a> are a technique for creating distinct value types that have the same underlying representation without having to box and unbox them with reference types acting as wrappers. This is usually accomplished by storing tags in the type parameters of Scala traits. The trick is that this extra type information is used only at compile-time. At run-time, the tagged values are equivalent to regular values.</p><p>Mikhail Savinov&rsquo;s <a class=link href=https://github.com/rudogma/scala-superquants title="GitHub: scala-supertagged" target=_blank rel=noopener>supersquant</a> uses a custom implementation of tagged types on top of the <a class=link href=https://github.com/Rudogma/scala-supertagged title="GitHub: scala-supertagged" target=_blank rel=noopener>supertagged</a> library in order to implement unit types:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>trait DoubleLengthTypesTrait { object Length extends TaggedType[Double] type Length[T] = (Double with Tag[Double, Length.Tag]) @@ T object Meters extends OverTagged(Length) type Meters = Meters.Type object Kilometers extends OverTagged(Length) type Kilometers = Kilometers.Type }
</span></span></code></pre></td></tr></table></div></div><p>Units are defined in a shared trait:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>trait LengthForRawOpsTrait[Raw] extends Any { def meters: Meters = safecasted def km: Kilometers = safecasted }
</span></span></code></pre></td></tr></table></div></div><p>Together, these can then be used to define quantities:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>val meters:Meters = 5.meters // or val meters:Meters = Meters @@ (Length @@ 5L)
</span></span></code></pre></td></tr></table></div></div><p>The exponents of unit dimensions are also stored as tags in traits. This makes for a very verbose syntax in user code, but it can be somewhat simplified using by predefined aliases:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type Acceleration = Complex[Long, Pow[Long, Meters, PowPlus, Nat._1] :: Pow[Long, Seconds, PowMinus, Nat._2] :: HNil] // or type Acceleration = Complex[Long, Single[Meters] :: Squared[Seconds] :: HNil] val squaredSeconds:Pow[Long, Seconds, PowPlus, Nat._1] = 5L.as[Pow[Long, Seconds, PowPlus, Nat._1]] // or val squaredSeconds:Squared[Seconds] = 5L.as[Squared[Seconds]]
</span></span></code></pre></td></tr></table></div></div><p>Quantities can also be converted and formatted for printing:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>val mg:Milligrams = 5.kg in Grams // 5000 Milligrams 10.kg.pretty // &#34;10 kg&#34; 11123456789L.mg.pretty[Tonnes :: Kilograms :: Grams :: Milligrams :: HNil] // &#34;11 t 123 kg 456 g 789 mg&#34;
</span></span></code></pre></td></tr></table></div></div><p>Actual operations on unit types are performed and verified via operations on traits and yield the expected behavior:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>val metersXseconds = 5.meters ** 5.seconds val speed3:Speed = 5.meters divide (5.seconds ** 5.seconds) val plainMeters:Meters = speed3 ** (5.seconds ** 5.seconds) val plainLong = speed3 ** (5.seconds ** 5.seconds divide 5.meters)
</span></span></code></pre></td></tr></table></div></div><p>The library currently provides unit types only for length, mass, time, and information units, along with a set of common prefixes. User defined unit types can be added by following the same patterns though. The value specific traits must be implemented separately for each underlying type (the library includes support for 64-bit signed integer and floating-point values).</p><h1 id=summary>Summary</h1><p>I do not wish to attempt a classification of the various implementations described in this article, but I&rsquo;d like to point out some of the major differences between them. Each of the design decisions have advantages and disadvantages, and their value often depends on the particular use case.</p><h2 id=compile-time-vs-run-time>Compile-time vs. Run-time</h2><p>Catching semantic errors in program code as early as possible is a very desirable feature, which is why most authors opt for compile-time checking of unit types. Compiler assisted dimensional analysis also has the major advantage that it usually does not incur any run-time overhead.</p><p>Run-time verification requires extra storage and logic, but it is by no means limited to those programming languages that do not provide adequate syntax support. There are valid use cases that cannot be solved with compile-time systems, for example, if the units are not known until run-time, or if the unit system must be configurable by the user.</p><h2 id=pre-processor-vs-type-system>Pre-processor vs. Type System</h2><p>For dimensional analysis at compile-time most authors will leverage the programming language&rsquo;s type system as it turns the problem of verifying unit semantics into the much simpler problem of verifying program syntax. It therefore pushes the burden of verification to the compiler, which is already implemented. In some cases, it may be necessary to make minor modifications to the parser or compiler in order to support the desired syntax, but this still requires considerable less effort than writing dimensional analysis tools from scratch.</p><p>When programming languages are not expressive enough, pre-processing tools that convert annotated source code into compilable source code seem to be a natural choice. However, these shouldn&rsquo;t be dismissed as a last resort to work around the limitations of the language, because standalone tools that deduce unit dimensions automatically can be a great help in analyzing code that has not been annotated at all. This is extremely useful for verifying existing programs without having to refactor them.</p><h2 id=automatic-vs-assisted-unit-inference>Automatic vs. Assisted Unit Inference</h2><p>Opinions differ on how much the source code should be annotated in order to support dimensional analysis. Some argue that the entire process should be as transparent as possible and not require any annotations at all. Many libraries, regardless of whether they use the type system or annotations, are very verbose and put a huge burden on the programmer. This is seen as undesirable. The main downside of fully automated verification is that it requires a certain amount of context to construct a system of constraints, and therefore it cannot capture all use cases.</p><p>At the other end of the spectrum, some authors note that annotating source code with units can actually increase the readability, comprehensibility, and maintainability of programs as it better describes the intent of the computations. It seems that, depending on the use case, a balance must be struck between the two approaches.</p><h2 id=integer-vs-rational-unit-exponents>Integer vs. Rational Unit Exponents</h2><p>The vast majority of libraries and tools for dimensional analysis assume integral unit exponents, which cover most use cases and are easier to implement. However, scientific computations exist that involve the roots of units, particularly in high-energy physics. The added complexity for supporting rational unit exponents allows for computations that could not be expressed otherwise and may therefore be worth the extra effort.</p><h2 id=pre-defined-vs-extensible-vs-data-driven-units>Pre-defined vs. Extensible vs. Data-driven Units</h2><p>The lack of abstraction capabilities in early (and even some modern) programming languages can make the development of extensible unit of measurement systems difficult or impossible, while more powerful type systems allow for units to be defined or extended by the user. Depending on the use case, a fixed set of units, such as SI is not necessarily a limitation though. In fact, they can lead to simpler and more efficient implementations, especially in those designed for run-time.</p><p>For compile-time systems with adequate compiler support there is generally no reason to not provide a generic and extensible API as they will most likely be built on top of generic programming features anyway.</p><p>Some frameworks support the definition of units in separate text files, so that they can be modified after the program has been compiled.</p><h2 id=coherent-vs-incoherent-unit-storage>Coherent vs. Incoherent Unit Storage</h2><p>Each physical dimension may have multiple units that require conversion functions between them, and an implementation must choose wether to store quantities in coherent units (i.e. all lengths are internally converted to and stored as <em>meter</em>), or allow incoherent units (i.e. lengths can be stored as <em>meter</em>, <em>kilometer</em>, <em>foot</em>, or some other commensurable unit). Storing coherent units is easier to implement, but has some important downsides.</p><p>One big problem is that the binary representation of a quantity&rsquo;s magnitude is not preserved as the assignment from one unit to another involves scaling and sometimes offsets (i.e. fahrenheit to celsius). Worse still, this may introduce unexpected errors due to rounding and limited numerical precision, especially when dealing with floating-point values.</p><p>In some use cases it can also be desirable to require that users represent quantities in particular units in order to avoid unnecessary conversions and to make the code easier to reason about. For example, a physics simulations library may require that all calculations be performed in the SI system and allow conversions from and to imperial units only for input and output.</p><p>Some implementations use a hybrid approach where the multiplicative factor is stored alongside the quantity&rsquo;s magnitude and applied in calculations. Others introduce separate types for every available unit and implement the conversions via operator overloading or helper functions.</p><h2 id=dimensionless-quantities>Dimensionless Quantities</h2><p>One detail that is often overlooked is the support for dimensionless quantities. Some libraries represent these as multiplicative scalars using built-in types, such as integers or floats. Others use dimensionality vectors that have all their exponents set to zero, which allows for seamless integration with other units. Some have no support at all.</p><p>It is important to note, however, that dimensionless quantities are not simply scalar values. In fact, many have their own unit symbols assigned. For example, angles can be expressed as <em>radians</em> or <em>degrees</em>, proportions as <em>percent</em> or <em>promille</em>, and ratios as <em>decibel</em> or <em>partspermillion</em>. While mixing these is permitted mathematically, it may be problematic semantically.</p><h1 id=related-resources>Related Resources</h1><p><a class=link href=https://gmpreussner.com/research/dimensional-analysis-in-programming-languages#top target=_blank rel=noopener>Top</a> Updated: May 30, 2018</p><p>from Hacker News <a class=link href=https://ift.tt/2J0PHdJ target=_blank rel=noopener>https://ift.tt/2J0PHdJ</a></p></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><footer class=site-footer><section class=copyright>&copy;
2020 -
2022 0x000216</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.11.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section><script data-name=BMC-Widget src=https://cdn.buymeacoffee.com/widget/1.0.0/prod/widget.prod.min.js data-id=0x000216 data-description=coffee! data-message=coffee! data-color=#FF813F data-position=right data-x_margin=28 data-y_margin=18></script></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#motivation>Motivation</a></li><li><a href=#concepts>Concepts</a></li><li><a href=#languages>Languages</a></li><li><a href=#libraries>Libraries</a></li><li><a href=#research>Research</a></li></ol><ol><li><a href=#gehani>Gehani</a></li><li><a href=#gnat>GNAT</a></li><li><a href=#units>UNITS</a></li></ol><ol><li><a href=#catlas>C/ATLAS</a></li><li><a href=#atlas-2000>ATLAS 2000</a></li></ol><ol><li><a href=#c-units>C-UNITS</a></li><li><a href=#guo--mccamant>Guo & McCamant</a></li><li><a href=#osprey>Osprey</a></li><li><a href=#unitc>Unitc</a></li></ol><ol><li><a href=#boost>Boost</a></li><li><a href=#cpp-measures>cpp-measures</a></li><li><a href=#dimentia>Dimentia</a></li><li><a href=#quantity>Quantity</a></li><li><a href=#siunits>SIunits</a></li></ol><ol><li><a href=#quantities>quantities</a></li><li><a href=#stdunits>std.units</a></li></ol><ol><li><a href=#eiffelunits>EiffelUnits</a></li></ol><ol><li><a href=#xelda>XeLda</a></li></ol><ol><li><a href=#physunits>PHYSUNITS</a></li></ol><ol><li><a href=#boyer>Boyer</a></li><li><a href=#dimensional>dimensional</a></li><li><a href=#physics>physics</a></li><li><a href=#units-1>units</a></li><li><a href=#uom-plugin>uom-plugin</a></li></ol><ol><li><a href=#metagen>MetaGen</a></li></ol><ol><li><a href=#cunis>Cunis</a></li><li><a href=#novak>Novak</a></li></ol><ol><li><a href=#oyster-units>Oyster Units</a></li></ol><ol><li><a href=#metric>metric</a></li></ol><ol><li><a href=#baldwin>Baldwin</a></li><li><a href=#vector-pascal>Vector Pascal</a></li></ol><ol><li><a href=#datadimensions>Data::Dimensions</a></li><li><a href=#mathunits>Math::Units</a></li><li><a href=#physicsunit>Physics::Unit</a></li></ol><ol><li><a href=#biggs>Biggs</a></li><li><a href=#numericalunits>numericalunits</a></li><li><a href=#pint>Pint</a></li><li><a href=#scientificpython>ScientificPython</a></li><li><a href=#units-2>units</a></li></ol><ol><li><a href=#dimensioned>dimensioned</a></li><li><a href=#runits>runits</a></li><li><a href=#simple_units>simple_units</a></li><li><a href=#uom>uom</a></li></ol><ol><li><a href=#libra>Libra</a></li><li><a href=#squants>Squants</a></li><li><a href=#supersquants>Supersquants</a></li></ol><ol><li><a href=#compile-time-vs-run-time>Compile-time vs. Run-time</a></li><li><a href=#pre-processor-vs-type-system>Pre-processor vs. Type System</a></li><li><a href=#automatic-vs-assisted-unit-inference>Automatic vs. Assisted Unit Inference</a></li><li><a href=#integer-vs-rational-unit-exponents>Integer vs. Rational Unit Exponents</a></li><li><a href=#pre-defined-vs-extensible-vs-data-driven-units>Pre-defined vs. Extensible vs. Data-driven Units</a></li><li><a href=#coherent-vs-incoherent-unit-storage>Coherent vs. Incoherent Unit Storage</a></li><li><a href=#dimensionless-quantities>Dimensionless Quantities</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>