<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="(I&amp;rsquo;d like to give a big shoutout to John Chandler Burnham, who published a very clear and comprehensive set of notes that helped me immensely.)
Background I&amp;rsquo;ve used Python in production for about three years now. Even as it&amp;rsquo;s a wonderful Swiss Army knife, Python also feels limiting in some ways. The same classes of bugs (e.g. type casting / translation errors, state management errors) kept cropping up, and Sisyphean bugs frustrate me."><title>A Pythonista's Review of Haskell</title><link rel=canonical href=https://Nexus-Security.github.io/posts/2016-09-09-a-pythonista-review-of-haskell/><link rel=stylesheet href=/scss/style.min.450926226e724574a6b936335ea06111f8aeb253d932c86cb2cc807341cd2889.css><meta property="og:title" content="A Pythonista's Review of Haskell"><meta property="og:description" content="(I&amp;rsquo;d like to give a big shoutout to John Chandler Burnham, who published a very clear and comprehensive set of notes that helped me immensely.)
Background I&amp;rsquo;ve used Python in production for about three years now. Even as it&amp;rsquo;s a wonderful Swiss Army knife, Python also feels limiting in some ways. The same classes of bugs (e.g. type casting / translation errors, state management errors) kept cropping up, and Sisyphean bugs frustrate me."><meta property="og:url" content="https://Nexus-Security.github.io/posts/2016-09-09-a-pythonista-review-of-haskell/"><meta property="og:site_name" content="ZYChimne"><meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:published_time" content="2020-01-31T07:04:00+01:00"><meta property="article:modified_time" content="2020-01-31T07:04:00+01:00"><meta name=twitter:title content="A Pythonista's Review of Haskell"><meta name=twitter:description content="(I&amp;rsquo;d like to give a big shoutout to John Chandler Burnham, who published a very clear and comprehensive set of notes that helped me immensely.)
Background I&amp;rsquo;ve used Python in production for about three years now. Even as it&amp;rsquo;s a wonderful Swiss Army knife, Python also feels limiting in some ways. The same classes of bugs (e.g. type casting / translation errors, state management errors) kept cropping up, and Sisyphean bugs frustrate me."></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu8b78332b6420dc9affabe23720d11e63_1937019_300x0_resize_q75_box.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a>
<span class=emoji>üçá</span></figure><div class=site-meta><h1 class=site-name><a href=/>ZYChimne</a></h1><h2 class=site-description>Computer Science, Wuhan University</h2></div></header><ol class=social-menu><li><a href=https://github.com/ZYChimne target=_blank title=GitHub><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com/ZChimne target=_blank title=Twitter><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/about-me/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>About Me</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></div></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/posts/2016-09-09-a-pythonista-review-of-haskell/>A Pythonista's Review of Haskell</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Jan 31, 2020</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>21 minute read</time></div></footer></div></header><section class=article-content><p><img src="https://www.gravatar.com/avatar/56f019c1fcd83bb2c035aa59a0d73583?s=256" loading=lazy></p><p>(I&rsquo;d like to give a big shoutout to <a class=link href=https://github.com/johnchandlerburnham target=_blank rel=noopener>John Chandler Burnham</a>, who published <a class=link href=https://github.com/johnchandlerburnham/hpfp target=_blank rel=noopener>a very clear and comprehensive set of notes</a> that helped me immensely.)</p><hr><h2 id=background>Background</h2><p>I&rsquo;ve used Python in production for about three years now. Even as it&rsquo;s a wonderful Swiss Army knife, Python also feels limiting in some ways. The same classes of bugs (e.g. type casting / translation errors, state management errors) kept cropping up, and Sisyphean bugs frustrate me. Python is also quite slow when you compare the operations you want to execute vs. the theoretical maximum performance of those operations on the underlying hardware. I kept wondering about what was possible if I had used a different tool.</p><p>What would happen if a data pipeline was lazy instead of eager, not because I&rsquo;m using a lazy library API, but because the language is non-strict by default? What if you could use types in order to register properties of data instead of state?</p><p>Lastly, I wanted to break free of the practitioner&rsquo;s pragmatic culture and see what academia had to offer in the start of the art. I remember one conversation I had years ago with a professor in college who had previously worked in industry, and he said that <a class=link href=https://en.wikipedia.org/wiki/A*_search_algorithm target=_blank rel=noopener>A*</a> was invented twenty years before it was widely used in industry (e.g. video game development). I think having an understanding of what&rsquo;s possible and what the future might bring could prove useful in understanding how to get there as a practitioner.</p><p>I thought learning Haskell provided the highest likelihood of satisfying these requirements. So over the past three months, I&rsquo;ve been reading through <a class=link href=https://haskellbook.com/ target=_blank rel=noopener>‚ÄúHaskell Programming, From First Principles‚Äù by Chris Allen and Julie Moronuki</a>, the 4th release candidate of the 1.0 edition (1.0-rc4). I&rsquo;m pleased to say that I made it to the end of this 1,857 page (by the e-reader PDF version) montrosity. Here&rsquo;s some of the things that I, as a software engineer who has used Python in production and Haskell doing book exercises only, liked and didn&rsquo;t like about Haskell.</p><h2 id=what-i-like-about-haskell>What I like about Haskell</h2><h3 id=the-type-system>The type system</h3><p>Haskell&rsquo;s type system makes Python&rsquo;s type system look downright primitive. The closest analogy I can think of is if you had direct access to dunder methods, like Python&rsquo;s <code>__eq__</code> vs. Haskell&rsquo;s <code>Data.Eq</code> typeclass constraint, when defining classes or methods. Then you had the ability to create <code>typing</code> type signatures on different, overlapping sets of these dunder methods somehow, and baked it all into your native toolchain as a set of compile-time guarantees. This still doesn&rsquo;t encapsulate the full power of the Haskell type system, like higher-kinded types and actual sum/product types. It&rsquo;s insanely mind-blowing. Constrained polymorphism is probably worth learning Haskell for alone.</p><p>I was reading through some of <a class=link href=https://hillelwayne.com target=_blank rel=noopener>Hillel Wayne&rsquo;s blog posts</a>, and <a class=link href=https://hillelwayne.com/post/why-dont-people-use-formal-methods/ target=_blank rel=noopener>one of them</a> discussed the <a class=link href=https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence target=_blank rel=noopener>Curry-Howard correspondence</a>, which somehow proves a 1:1 association between aspects of a mathematical proof and aspects of a type system. You can convert a proof into a type, if your type system supports it. I think Haskell&rsquo;s type system respects this. I don&rsquo;t think Python&rsquo;s type system does.</p><h3 id=an-emphasis-on-structure>An emphasis on structure</h3><p>One key aspect of Haskell the authors came back to repeatedly (and I mean <em>repeatedly</em>) is Haskell&rsquo;s emphasis on <em>structure</em>. If I had to explain functors, applicatives, and monads to somebody else, it wouldn&rsquo;t be in terms of I/O, or error handling, or burritos. It&rsquo;d be <em>structure</em>.</p><p>Structure, in this case, refers to a higher-kinded or partially-applied type, like a list. You apply another type to a higher-kinded type to create a concrete type (e.g. <code>Integer</code> to <code>[]</code> to create <code>[Integer]</code> or a list of integers.) A functor instance <em>lifts</em> a function over some structure to affect only the values within. An applicative (a monoidal functor) leverages a structure and function together while lifting the function over structure. A monad (an applicative functor) creates new structure whilst in the process of lifting a function over existing structure.</p><p>Let&rsquo;s take this example that might explain functors and structure to a tiny degree. Say you want to add one to a list of integers in Python. You can do this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>xs = [1, 2, 3, 4, 5] # xs = [2, 3, 4, 5, 6] xs_ = map(lambda x : x + 1, xs) 
</span></span></code></pre></td></tr></table></div></div><p>In Haskell, this may look like:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>xs = [1, 2, 3, 4, 5] -- xs&#39; = [2, 3, 4, 5, 6] xs&#39; = map (+1) xs 
</span></span></code></pre></td></tr></table></div></div><p>Sure. But Haskell <em>also</em> has <code>fmap</code>, which stands for ‚Äúfunctor map‚Äù. On lists this is straightforward:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>-- xs&#39;&#39; = [2, 3, 4, 5, 6] xs&#39;&#39; = fmap (+1) xs 
</span></span></code></pre></td></tr></table></div></div><p>But you can also define it on other types, such as concrete <code>Maybe</code> values:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>-- ys = (Just 2) ys = fmap (+1) (Just 1) 
</span></span></code></pre></td></tr></table></div></div><p>In both cases, you&rsquo;re lifting the method <code>(+1)</code> over <code>[]</code> and <code>Just</code> respectively to affect the value(s) within.</p><p>You can also more explicitly lift <code>fmap</code> inside nested structure, such as a list of concrete <code>Maybe</code> values using function composition:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>-- zs = [Just 2, Just 3, Just 4] zs = (fmap . fmap) (+1) [Just 1, Just 2, Just 3] -- zs&#39; = [Just 2, Nothing, Just 4] zs&#39; = (fmap . fmap) (+1) [Just 1, Nothing, Just 3] 
</span></span></code></pre></td></tr></table></div></div><p>I don&rsquo;t think you can do anything like this with Python or any other practitioner&rsquo;s language that I&rsquo;m familiar with. This barely begins to touch the power of Haskell structure. I definitely recommend thinking in terms of structure when learning Haskell.</p><p>As an aside, I published <a class=link href=https://bytes.yingw787.com/posts/2019/12/06/monads target=_blank rel=noopener>a monad tutorial last year</a> before reading through the monads section, and uh, yeah. Not a good idea to speak authoritatively on a subject you know nothing about (if only because it may lead others astray). You can read <a class=link href=https://lobste.rs/s/fwyvqr/monads_aren_t_as_hard_as_you_think target=_blank rel=noopener>the feedback I got on that from lobste.rs here</a>.</p><h3 id=streams-and-stream-oriented-programming-foundations>Streams and stream-oriented programming foundations</h3><p>Haskell has native streams in the form of unbounded structures (such as lists), where you can apply <code>take</code> to take a number of elements for evaluation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>-- [1..] is a never-ending stream of increasingly large integers. -- -- `$` is an associativity forcing function, to evaluate everything to its right -- before evaluating anything to its left. -- -- `take 5` takes the first 5 values. -- -- The compiler takes the full expression, and returns: -- xs = [1, 2, 3, 4, 5] xs = take 5 $ [1..] 
</span></span></code></pre></td></tr></table></div></div><p>No need for separate generator syntax. This is due to Haskell&rsquo;s non-strict evaluation, compiler optimizations, and the clear delination between structure and values. This could be useful for languages implementing streaming frameworks, such as <a class=link href=https://hackage.haskell.org/package/streaming target=_blank rel=noopener><strong><code>streaming</code></strong></a>. Streaming is important for, among other things, implementing real-time analytics, which is slowly becoming a basic requirement for various BI platforms.</p><p>Even the base error type, <code>bottom</code> or <code>_|_</code>, is defined as an evaluation that never completes successfully, either because a computation failed, or because <em>there&rsquo;s an infinite loop</em>. See <a class=link href=https://wiki.haskell.org/Bottom target=_blank rel=noopener>the Haskell wiki definition of <code>bottom</code></a>. I don&rsquo;t think Python&rsquo;s <a class=link href=https://docs.python.org/3/library/exceptions.html#BaseException target=_blank rel=noopener><code>BaseException</code></a> has a built-in notion of infinite loops evaluating to an error condition. This appears super powerful to me, because the big error type introduced by going over network connections are network timeouts, which appear to most programs as infinitely long computations.</p><h3 id=property-based-testing>Property-based testing</h3><p>Haskell has <a class=link href=https://hackage.haskell.org/package/QuickCheck target=_blank rel=noopener><strong><code>Test.QuickCheck</code></strong></a>, a property-based testing framework that generates values to check a declared property. Python has <a class=link href=https://hypothesis.readthedocs.io/en/latest/ target=_blank rel=noopener><strong><code>hypothesis</code></strong></a>, but having used it a tiny bit for an open-source contribution, I don&rsquo;t think it&rsquo;s the same without the Haskell type system. The type system empowers effective property-based testing to a high degree. For example, in <code>Test.QuickCheck</code>, you can literally create a wholly abstract type, and then <em>cast it to different concrete types for different QuickCheck runs</em>. So you can check that your declared monoid is properly associative for <em>a set of different concrete types</em>, which QuickCheck will validate by running at least <em>100 different concrete values per concrete type signature</em>, while only needing to mutate the type signature. In production, libraries like <a class=link href=https://hackage.haskell.org/package/checkers target=_blank rel=noopener><strong><code>checkers</code> or <code>Test.QuickCheck.Checkers</code></strong></a> abstract away testing properties of common typeclass instances like functors, applicatives, and monads to give you soft assurances they work as intended. From my current understanding, I would categorize property-based testing as something between Monte Carlo simulation and constraint solving.</p><p>I can&rsquo;t overstate how powerful <code>Test.QuickCheck</code> is. I can run <em>hundreds</em> of unit tests <em>per dozen lines of code</em>, without having to set and mutate my own oracle values. By constrast, a couple thousand unit tests in a project with 10^5 LOC in Python would be considered well-tested. The vast majority of testing I did as part of the book exercises would be through <code>Test.QuickCheck</code>. <a class=link href=https://hackage.haskell.org/package/hspec target=_blank rel=noopener><strong><code>Hspec</code></strong></a>, the Haskell unit testing framework, hardly gets mentioned.</p><h3 id=ghci>GHCi</h3><p>An interpreter for a compiled language? Yup. <code>stack ghci</code> was a good friend during this time period. You can pretty much do anything that compiled Haskell can do. Load GHC language extensions? Check. Set runtime conditions like <code>:set -Wall</code> to see all raised warnings? Check. Print type signatures, kind-ness signatures, and other information around methods? Check.</p><p>There&rsquo;s some weird edges around GHCi, mostly around the difference in runtime behavior between GHC and GHCi. Ordering matters in GHCi and not in an equivalent source file compiled using GHC. GHCi natively prints results to terminal and therefore deriving <code>Show</code> is necessary for type definitions referenced in GHCi. GHCi defaults types to <code>()</code> if they&rsquo;re not specified vs. GHC&rsquo;s compile-time error, which for me led to some interesting <code>QuickCheck</code> behavior. However, none of this really impacted my workflows very much, or took away from how impressive GHCi was.</p><h3 id=hoogle>Hoogle</h3><p><a class=link href=https://hoogle.haskell.org/ target=_blank rel=noopener>Hoogle</a> is Haskell&rsquo;s API search engine where, among other things, you can search a method for by passing in <em>the type signature of a method you think you want</em>. There&rsquo;s <a class=link href=https://hackage.haskell.org/ target=_blank rel=noopener>Hackage</a>, whose search maps more closely to that of <a class=link href=https://pypi.org/ target=_blank rel=noopener>PyPI</a>, but I don&rsquo;t think Python has anything like Hoogle. I don&rsquo;t think Hoogle exists just as a flex on lesser-typed languages. I&rsquo;ve had to search for some things there and I&rsquo;d say it&rsquo;s been useful even to a beginner like me. I can see how using such a tool would become easier as you become more and more familiar with the Haskell standard library and the major package ecosystem.</p><h2 id=what-i-dislike-about-haskell>What I dislike about Haskell</h2><h3 id=cognitive-load>Cognitive load</h3><p>My appreciation of programming as an art and as a discipline increased by my learning Haskell, at the cost of my brain constantly melting out my ears and my eyeballs not comprehending what I was reading. The cognitive load was <em>insane</em>. Three months in and I still have little idea on how to write production-grade Haskell code.</p><p>This may just be that this specific book is a high-level overview of Haskell and not a practitioner&rsquo;s guide. Chris, one of the authors, mentioned <a class=link href=https://bitemyapp.com/blog/wrapping-up-haskellbook/ target=_blank rel=noopener>some differences in direction with Julie</a> with respect to the book&rsquo;s purpose. Julie&rsquo;s new book, <a class=link href=https://joyofhaskell.com/ target=_blank rel=noopener>‚ÄúThe Joy of Haskell‚Äù</a>, sells itself as ‚Äúextremely approachable‚Äù and ‚Äúa practical problem-motivated approach‚Äù, which may be more catered towards her interests. In my experience, the longer a book is, the more times I need to review it in order to absorb all the content.</p><p>Then again, I remember how my old Python code was absolute hot garbage, and I only really got good at Python about a year into my first job and asked questions every 20 minutes for a month and read 10-15 books on the subject. If I started using Haskell at a Haskell-friendly workplace, I&rsquo;m sure it&rsquo;d be much the same story: first overwhelmed, then awed, then routine.</p><p>IMHO, the solution to high cognitive load, given a high enough reward, is just persistent, methodical execution towards learning. If I had to choose one feeling, I generally prefer being overwhelmed to being helpless. I find it easier to sprout enough dendrites to understand this stuff one day and add it to my toolbox rather than stomach the regret of the path not taken.</p><h3 id=indentation>Indentation</h3><p>Haskell, like Python, practices <a class=link href=https://en.wikipedia.org/wiki/Off-side_rule target=_blank rel=noopener>indentation-as-code</a>, where indentation affects program structure and execution. I found myself unused to Haskell notation where the program seems to backtrack in on itself, such as applying <code>do</code>, <code>let</code>, and <code>where</code> notation. Here&rsquo;s an example with all three in Haskell, taken from the book:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gameWords :: IO WordList gameWords = do (WordList aw) &lt;- allWords return $ WordList (filter gameLength aw) where gameLength w = let l = length (w :: String) in l &gt;= minWordLength &amp;&amp; l &lt; maxWordLength 
</span></span></code></pre></td></tr></table></div></div><p>IIRC the last few lines wouldn&rsquo;t compile until I indented at least that much (like, past the start of variable <code>gameLength</code>, instead of just 2 spaces in like the rest of the program). If I indented more, it would work the same. In Python, I would get a clean <code>IndentationError</code> for everything except the proper indentation, and if I indented more and remained valid, it would imply different code behavior (like a scoping change).</p><p>Ultimately, I don&rsquo;t think this is a big issue. Haskell has code auto-formatters like <a class=link href=https://hackage.haskell.org/package/haskell-formatter target=_blank rel=noopener><strong><code>haskell-formatter</code></strong></a>, much like Python&rsquo;s <a class=link href=https://black.readthedocs.io/en/stable/ target=_blank rel=noopener><strong><code>black</code></strong></a>. Use it and move on. Bikeshed about something else, you know?</p><h3 id=concurrency--parallelism>Concurrency / Parallelism</h3><p>Since Haskell is a lambda calculus, and everything is functional, I thought I could get parallelism trivially. Trivially, as in I expected GHCi could be run with multiple processes / threads using a config flag or file, and you could configure GHC to create a compiled binary targeting a (max?) specific number of processes / threads.</p><p>Nope. As far as I can tell, you still have to mutate your source code, and use a library, such as <a class=link href=https://hackage.haskell.org/package/parallel-3.2.2.0 target=_blank rel=noopener><strong><code>Control.Parallel</code></strong></a> (external dep) or <a class=link href=https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Concurrent.html target=_blank rel=noopener><strong><code>Control.Concurrent</code></strong></a> (base stdlib). Simon Marlow&rsquo;s <a class=link href=https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/ target=_blank rel=noopener>‚ÄúParallel and Concurrent Programming in Haskell‚Äù</a> is probably a must-read to understand this topic (and things like <a class=link href=https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Concurrent-MVar.html target=_blank rel=noopener><strong><code>Control.Concurrent.MVar</code></strong></a>).</p><p>I get concerns about resource contention, and the fact that side effects may exist and compile may imply non-trivial parallelization, but it does reduce the value proposition of Haskell when comparing to something that&rsquo;s more ‚Äútraditional‚Äù, where you have to change the source anyways to get those benefits. When I apply property-based testing to check monadic associativity and applicative composition on naive custom-defined <code>List</code> types using <a class=link href=https://hackage.haskell.org/package/checkers-0.4.4/docs/Test-QuickCheck-Checkers.html target=_blank rel=noopener><strong><code>checkers</code></strong></a>, the fact that it stalls one CPU core while not using the other 11 CPU cores (I have an Intel Xeon) kind of kills me inside.</p><p>I could be wrong. There might be an option in GHC or GHCi I don&rsquo;t know about that enables this to occur. If that&rsquo;s not the case though, I think if Haskell made parallelization more upfront and trivial, it would be a material selling point for practitioners.</p><h3 id=strictness--non-strictness>Strictness / Non-strictness</h3><p>Haskell is fundamentally a non-strict language. However, <em>you still need strict-ness in order to do useful stuff</em>. So the way Haskell ended up appearing to me in this regards was a mish-mash of strict and non-strict portions of the codebase. You have to take a look at GHC Core, the underlying strict (transpilation?) of GHC Haskell to understand how the code actually behaves, and GHC Core is not the most readable language. For example, for <code>Foldable</code> types, a left-associative fold <code>foldl</code> is strict over spine evaluation, while right-associative folds <code>foldr</code> is non-strict over spine evaluation.</p><p>There&rsquo;s some conventions people follow. For example, when implementing <code>Foldable</code> types, making the spine lazy and values strict is a point constantly hammered home. So does properly raising asynchronous exceptions. However, to me this falls far short of the guarantees I thought I could get, and I honestly prefer having an explicit distinction between lazy/eager APIs after seeing the alternative.</p><h3 id=package-management>Package Management</h3><p><code>stack uninstall $PACKAGE</code> does not exist, and I wish the reasoning was more clear (like code samples to indicate <em>why</em> it is unnecessary). Here&rsquo;s the <a class=link href=https://github.com/commercialhaskell/stack/issues/361 target=_blank rel=noopener>GitHub issue related to implementing <code>stack uninstall</code></a>, which was, as far as I can tell, closed without action. As a newbie, I do wish that there was guidance on the ‚Äúproper‚Äù way to uninstall packages if <code>stack uninstall</code> is not available.</p><p>I also wish that there was a better way to version and lock environments. I would have loved to have package lockfiles available for source code work as part of the book, as parts of GHC have changed since the book was written.</p><h3 id=compatibility>Compatibility</h3><p>On the issue of compatibility.</p><p>Haskell has the ability to declare a type alias around an existing type, called <code>newtype</code>, that guarantees only the type name and not the underlying data representation changes. Ostensibly, this serves as a way to typecheck data and act as an extra constraint. What <code>newtype</code> really reminds me of though is a comment on Hacker News talking about how Lisp&rsquo;s type system enabled the creation of Lisp macros and tightly coupled a developer&rsquo;s team to its codebase. If you could define a DSL on top of Haskell and shoot yourself in the foot, <code>newtype</code> would likely the culprit. I&rsquo;m not sure how library compatibility would work. Does <code>newtype</code> exist as part of native top-level APIs for Haskel libraries? How much churn do production Haskell type signatures suffer from? This is an unknown quantity to me.</p><p>In addition to concerns about ‚Äúhorizontal‚Äù compatibility between third-party libraries in the same environment, I also worry about ‚Äúvertical‚Äù (backwards / forwards) compatibility when upgrading or downgrading environments. Haskell respects the mathematics behind type theory, and when there are new discoveries, Haskell doesn&rsquo;t mind making breaking changes. For example, <a class=link href=https://stackoverflow.com/a/52238024/1497211 target=_blank rel=noopener>this Stack Overflow answer</a> helped me understand why I needed to implement <code>Semigroup</code> every time I needed to implement <code>Monoid</code>, which wasn&rsquo;t the case in the book examples. When <a class=link href=http://www.staff.city.ac.uk/~ross/papers/Applicative.html target=_blank rel=noopener><code>Applicative</code> and <code>Traversable</code> was discovered</a>, they were added to GHC 7.10. I believe I had to implement <code>Applicative</code> when I needed to implement <code>Monad</code> for various type definitions. Yeah. <em>Math changes</em>.</p><p>I&rsquo;m interested in seeing any published upgrade paths, or how existing Haskell projects pull core dependencies from upstream. Maybe it&rsquo;s just a different workflow than what I&rsquo;m used to, but in any case it would be helpful to understand for any production Haskell projects.</p><h3 id=small-nits>Small Nits</h3><p>Haskell has no null definition of type <code>Char</code>, at least according to <a class=link href=https://stackoverflow.com/a/58924575 target=_blank rel=noopener>this Stack Overflow answer</a>. Python doesn&rsquo;t distinguish between <code>Char</code> and <code>String</code> types with single and double quotes, so empty char is empty string is an empty list. It seems weird to me that for all the typing wealth Haskell provides, this base case doesn&rsquo;t exist, though I personally don&rsquo;t know what it is.</p><hr><p><code>Int</code> and <code>Integer</code> are two different types, according to <a class=link href=https://stackoverflow.com/a/12273762/1497211 target=_blank rel=noopener>this Stack Overflow post</a>. Apparently it&rsquo;s easier to just change the type signature rather than execute a type conversion. I&rsquo;m sure they have their reasons, but I personally don&rsquo;t understand this.</p><hr><p>I don&rsquo;t like how Haskell applies wildcard imports by default. Here&rsquo;s Haskell:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>-- Wildcard import import Package -- Namespaced import import qualified Package as Package 
</span></span></code></pre></td></tr></table></div></div><p>vs Python:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=err>#</span> <span class=nx>Namespaced</span> <span class=kn>import</span> <span class=kn>import</span> <span class=kn>package</span> <span class=err>#</span> <span class=nx>Wildcard</span> <span class=kn>import</span> <span class=nx>from</span> <span class=kn>package</span> <span class=kn>import</span> <span class=o>*</span> 
</span></span></code></pre></td></tr></table></div></div><hr><p>Haskell can raise errors partway through evaluating an error message. This (feature?) seems alien to me:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Prelude&gt; map (+1) [1, 2, undefined] -- &#39;[2, 3,&#39; is still visible, and has been executed. [2,3,*** Exception: Prelude.undefined CallStack (from HasCallStack): error, called at libraries/base/GHC/Err.hs:79:14 in base:GHC.Err undefined, called at &lt;interactive&gt;:27:17 in interactive:Ghci14 Prelude&gt; 
</span></span></code></pre></td></tr></table></div></div><h3 id=community-organization>Community Organization</h3><p>One day, I was looking up how to use <code>FlexibleInstances</code>, which is a GHC language extension. The book referenced this URL:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>https://ghc.haskell.org/trac/haskell-prime/wiki/FlexibleInstances 
</span></span></code></pre></td></tr></table></div></div><p>As of <code>2020-01-14T16:38:59.758039-05:00</code>, this link returned <code>nginx: 404 Not Found</code>. When I searched for <code>FlexibleInstances</code> using DuckDuckGo, I got this completely new link:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>https://prime.haskell.org/wiki/FlexibleInstances 
</span></span></code></pre></td></tr></table></div></div><p>From <a class=link href=https://bitemyapp.com/blog/wrapping-up-haskellbook/ target=_blank rel=noopener>Christopher Allen&rsquo;s blog post finalizing ‚ÄúThe Haskell Book‚Äù</a>, it looks like the book was last updated around end of 2018. So in less than two years, the link had rotted.</p><p>I think Python&rsquo;s spoiled me. I can go to python.org&rsquo;s website, and pull up a set of offline docs for <em>every GA version of Python going back to Python 1.4, published October 25th, 1996</em>. Don&rsquo;t take my word for it. Here&rsquo;s the <a class=link href=https://docs.python.org/release/1.4/ref/ target=_blank rel=noopener>Python 1.4 documentation</a>. I have no idea who even uses Python 1.4. But I&rsquo;m pretty sure that for whoever needs Python 1.4 (maybe some poor legacy embedded systems engineer), this specific link <em>will not rot</em>.</p><p>To be clear, I didn&rsquo;t choose to learn Haskell because it&rsquo;s friendly to developers. One of my reasons for learning Haskell, is to see what a language is like when it doesn&rsquo;t compromise. However, things like link rot, or a general affinity towards terseness, or a lack of unstructured documentation (IMHO type signatures aren&rsquo;t a substitute for documentation) or migrating the bug tracker to a GitLab deploy for reasons (where you now have to create an account and sign in to read issues) stand out in my mind as impediments that might make learning Haskell and growing the Haskell community unnecessarily difficult.</p><p>Perhaps I&rsquo;m being dramatic, but I oftentimes forget that I&rsquo;m extraordinarily privileged to live in a first-world country, with the financial capacity to attend conferences at will, gain access to core devs and library maintainers over email, and spend time to learn things for fun. Not everybody has that ability, and this stark contrast between community management styles brings this privilege to my mind&rsquo;s forefront. I think the Haskell community could take many cues on this subject from the Python community, and I think that would lend a massive step towards in sharing Haskell&rsquo;s beauty with more people around the world.</p><h2 id=projects-id-like-to-do-in-haskell>Projects I&rsquo;d like to do in Haskell</h2><p>I&rsquo;m probably tabling my journey towards learning additional Haskell until I ship some other stuff, but I already have some ideas for projects I would like to implement in Haskell:</p><ul><li><p><strong>A tool to model ETL workflows for integration testing</strong>: I&rsquo;ve found ETL workflows to be tremendously difficult to model, because verifying correctness almost entirely revolves around parsing side effects. Haskell is great at abstracting away side effects, and it&rsquo;s great at generative testing. Both of these attributes could apply to a new integration testing framework for something like Apache Airflow.</p></li><li><p><strong>An RFC-4180 compliant CSV parser</strong>: There&rsquo;s plenty of CSV parsers out there. There aren&rsquo;t too many that openly state to be RFC-4180 compliant, given the need to satisfy business requirements. Of those that are, I haven&rsquo;t seen any that publish test reports that can automatically verify RFC-4180 compliance. Of course, the goal of a CSV parser is to get the CSV file into a highly structured format as quickly as possible in order to avoid parsing errors further down the pipeline, but even getting that first step done is a materially non-trivial task. I&rsquo;d love to have a CSV parser that could be verified using some kind of IETF grammar generation tool, or modeled using formal reasoning. <a class=link href=http://hackage.haskell.org/package/liquidhaskell target=_blank rel=noopener><strong><code>liquidhaskell</code></strong></a> and <a class=link href=https://hackage.haskell.org/package/cassava target=_blank rel=noopener><strong><code>cassava</code></strong></a> would be great prior art for me to study.</p></li><li><p><strong>A POSIX-compatible, lazy data engineering pipelining tool</strong>: The big data engineering tool I&rsquo;ve used in the past is Apache Spark, but there are parts of Spark I wish were different. I believe the Spark RDD binary format underneath is framework-specific. Using it involves a REPL, instead of <code>stdin</code>/<code>stdout</code>. Finally, while the pipeline is lazy, the pipeline constructor is monolithic.</p><p>I&rsquo;d love to have a POSIX-compatible, composable data engineering framework with something like standard Parquet files (highly structured, a small, independent type system striped alongside data, columnar formatted, binary) acting as a persistent backing. I think POSIX and Haskell paired together would be such a great combination, and it&rsquo;s where Haskell&rsquo;s strengths like bare-metal performance and non-strictness can really shine. Imagine something like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>pipelineBuilder source.parquet --conf baseConf.json \  | transformA --conf conf1.json \  | transformB -conf conf2.json \  &gt; out.parquet 
</span></span></code></pre></td></tr></table></div></div></li></ul><h2 id=conclusion>Conclusion</h2><p>One interesting section of Haskell code the author pointed out was this method, as part of <a class=link href=https://github.com/softmechanics/yesod-core target=_blank rel=noopener><strong><code>yesod-core</code></strong></a> pinned at commit <code>db5e987797768e19cb6c0e6b7f8df1f836634c3b</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>addSubWidget :: (YesodSubRoute sub master) =&gt; sub -&gt; GWidget sub master a -&gt; GWidget sub&#39; master a addSubWidget sub w = do master &lt;- liftHandler getYesod let sr = fromSubRoute sub master i &lt;- GWidget $ lift $ lift $ lift $ lift $ lift $ lift $ lift get w&#39; &lt;- liftHandler $ toMasterHandlerMaybe sr (const sub) Nothing $ flip runStateT i $ runWriterT $ runWriterT $ runWriterT $ runWriterT $ runWriterT $ runWriterT $ runWriterT $ unGWidget w let ((((((((a, body), title), scripts), stylesheets), style), jscript), h), i&#39;) = w&#39; GWidget $ do tell body lift $ tell title lift $ lift $ tell scripts lift $ lift $ lift $ tell stylesheets lift $ lift $ lift $ lift $ tell style lift $ lift $ lift $ lift $ lift $ tell jscript lift $ lift $ lift $ lift $ lift $ lift $ tell h lift $ lift $ lift $ lift $ lift $ lift $ lift $ put i&#39; return a 
</span></span></code></pre></td></tr></table></div></div><p>The author points out that this is an abuse of monad transformers, and I&rsquo;m sure you can tell this isn&rsquo;t the cleanest Haskell code out there. My goal here isn&rsquo;t to diss the maintainers or authors of this code. I&rsquo;m pretty sure <a class=link href=https://github.com/snoyberg/ target=_blank rel=noopener><strong><code>@snoyberg</code></strong></a> is one of the most pre-eminent Haskell programmers in the world and he probably had good reason to write this method the way it is. What I do want to point out is <em>Haskell isn&rsquo;t a magical elixir</em>. It&rsquo;s still a programming language. For me, I put Haskell and those who used it on a pedestal and I thought that if I just learned Haskell, all my technical problems would go away. Learning Haskell and understanding it intimately helped me take it down from its pedestal, and I realized that the fundamental truths of software engineering still hold. How you use a tool is just as important as which tool you use. There are always tradeoffs you weigh when making decisions, especially in the face of development limitations like manpower and money. Make things work, then right, then fast, in order to ship.</p><p>Getting to a bare beginner&rsquo;s level in Haskell was an informative experience for me, and I hope I can continue learning and applying Haskell in my life. I think I grew immensely, both personally and professionally, from this experience, and I&rsquo;m tremendously grateful to the Haskell community for the journey thus far. To more adventures! üç∑</p><hr><p>(If you&rsquo;re interested, here are <a class=link href=http://github.com/yingw787/thehaskellbook target=_blank rel=noopener>my notes for ‚ÄúThe Haskell Book‚Äù</a>.)</p><p><a class=link href="https://news.ycombinator.com/item?id=22195072" target=_blank rel=noopener>Hacker News</a></p><p><a class=link href=https://lobste.rs/s/ovebeq/pythonista_s_review_haskell target=_blank rel=noopener>Lobste.rs</a></p><p>from Hacker News <a class=link href=https://ift.tt/2RHeO8X target=_blank rel=noopener>https://ift.tt/2RHeO8X</a></p></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><footer class=site-footer><section class=copyright>&copy;
2020 -
2022 ZYChimne</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.11.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#background>Background</a></li><li><a href=#what-i-like-about-haskell>What I like about Haskell</a><ol><li><a href=#the-type-system>The type system</a></li><li><a href=#an-emphasis-on-structure>An emphasis on structure</a></li><li><a href=#streams-and-stream-oriented-programming-foundations>Streams and stream-oriented programming foundations</a></li><li><a href=#property-based-testing>Property-based testing</a></li><li><a href=#ghci>GHCi</a></li><li><a href=#hoogle>Hoogle</a></li></ol></li><li><a href=#what-i-dislike-about-haskell>What I dislike about Haskell</a><ol><li><a href=#cognitive-load>Cognitive load</a></li><li><a href=#indentation>Indentation</a></li><li><a href=#concurrency--parallelism>Concurrency / Parallelism</a></li><li><a href=#strictness--non-strictness>Strictness / Non-strictness</a></li><li><a href=#package-management>Package Management</a></li><li><a href=#compatibility>Compatibility</a></li><li><a href=#small-nits>Small Nits</a></li><li><a href=#community-organization>Community Organization</a></li></ol></li><li><a href=#projects-id-like-to-do-in-haskell>Projects I&rsquo;d like to do in Haskell</a></li><li><a href=#conclusion>Conclusion</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>