<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="In a post from about a year ago, I explained an algorithm for counting the number of inversions of a sequence in time. As a reminder, given a sequence , an inversion is a pair of positions such that and are in the ‚Äúwrong order‚Äù, that is, but . There can be up to inversions in the worst case, so we cannot hope to count them in faster than quadratic time by simply incrementing a counter."><title>Counting Inversions via Rank Queries</title><link rel=canonical href=https://Nexus-Security.github.io/posts/2016-09-09-counting-inversions-via-rank-queries/><link rel=stylesheet href=/scss/style.min.450926226e724574a6b936335ea06111f8aeb253d932c86cb2cc807341cd2889.css><meta property="og:title" content="Counting Inversions via Rank Queries"><meta property="og:description" content="In a post from about a year ago, I explained an algorithm for counting the number of inversions of a sequence in time. As a reminder, given a sequence , an inversion is a pair of positions such that and are in the ‚Äúwrong order‚Äù, that is, but . There can be up to inversions in the worst case, so we cannot hope to count them in faster than quadratic time by simply incrementing a counter."><meta property="og:url" content="https://Nexus-Security.github.io/posts/2016-09-09-counting-inversions-via-rank-queries/"><meta property="og:site_name" content="ZYChimne"><meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:published_time" content="2020-01-04T03:06:00+01:00"><meta property="article:modified_time" content="2020-01-04T03:06:00+01:00"><meta name=twitter:title content="Counting Inversions via Rank Queries"><meta name=twitter:description content="In a post from about a year ago, I explained an algorithm for counting the number of inversions of a sequence in time. As a reminder, given a sequence , an inversion is a pair of positions such that and are in the ‚Äúwrong order‚Äù, that is, but . There can be up to inversions in the worst case, so we cannot hope to count them in faster than quadratic time by simply incrementing a counter."></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu8b78332b6420dc9affabe23720d11e63_1937019_300x0_resize_q75_box.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a>
<span class=emoji>üçá</span></figure><div class=site-meta><h1 class=site-name><a href=/>ZYChimne</a></h1><h2 class=site-description>Computer Science, Wuhan University</h2></div></header><ol class=social-menu><li><a href=https://github.com/ZYChimne target=_blank title=GitHub><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com/ZChimne target=_blank title=Twitter><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/about-me/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>About Me</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></div></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/posts/2016-09-09-counting-inversions-via-rank-queries/>Counting Inversions via Rank Queries</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Jan 04, 2020</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>10 minute read</time></div></footer></div></header><section class=article-content><p>In a <a class=link href=https://byorgey.wordpress.com/2018/10/06/counting-inversions-with-monoidal-sparks/ target=_blank rel=noopener>post from about a year ago</a>, I explained an algorithm for counting the number of <em>inversions</em> of a sequence in <img src="https://s0.wp.com/latex.php?latex=O%28n+%5Clg+n%29&bg=ffffff&fg=333333&s=0" loading=lazy alt="O(n \lg n)"> time. As a reminder, given a sequence <img src="https://s0.wp.com/latex.php?latex=a_1%2C+a_2%2C+%5Cdots%2C+a_n&bg=ffffff&fg=333333&s=0" loading=lazy alt="a_1, a_2, \dots, a_n">, an <em>inversion</em> is a pair of positions <img src="https://s0.wp.com/latex.php?latex=i%2C+j&bg=ffffff&fg=333333&s=0" loading=lazy alt="i, j"> such that <img src="https://s0.wp.com/latex.php?latex=a_i&bg=ffffff&fg=333333&s=0" loading=lazy alt=a_i> and <img src="https://s0.wp.com/latex.php?latex=a_j&bg=ffffff&fg=333333&s=0" loading=lazy alt=a_j> are in the ‚Äúwrong order‚Äù, that is, <img src="https://s0.wp.com/latex.php?latex=i+%3C+j&bg=ffffff&fg=333333&s=0" loading=lazy alt="i < j"> but <img src="https://s0.wp.com/latex.php?latex=a_i+%3E+a_j&bg=ffffff&fg=333333&s=0" loading=lazy alt="a_i > a_j">. There can be up to <img src="https://s0.wp.com/latex.php?latex=n%28n-1%29%2F2&bg=ffffff&fg=333333&s=0" loading=lazy alt=n(n-1)/2> inversions in the worst case, so we cannot hope to count them in faster than quadratic time by simply incrementing a counter. In my previous post, I explained one way to count inversions in <img src="https://s0.wp.com/latex.php?latex=O%28n+%5Clg+n%29&bg=ffffff&fg=333333&s=0" loading=lazy alt="O(n \lg n)"> time, using a variant of merge sort.</p><p>I recently learned of an entirely different algorithm for achieving the same result. (In fact, I learned of it when I gave this problem on an exam and a student came up with an unexpected solution!) This solution does not use a divide-and-conquer approach at all, but hinges on a clever data structure.</p><p>Suppose we have a bag of values (<em>i.e.</em> a collection where duplicates are allowed) on which we can perform the following two operations:</p><ol><li>Insert a new value into the bag.</li><li>Count how many values in the bag are <em>strictly greater than</em> a given value.</li></ol><p>We‚Äôll call the second operation a <em>rank query</em> because it really amounts to finding the <em>rank</em> or <em>index</em> of a given value in the bag‚Äîhow many values are greater than it (and thus how many are less than or equal to it)?</p><p>If we can do these two operations in logarithmic time (<em>i.e.</em> logarithmic in the number of values in the bag), then we can count inversions in <img src="https://s0.wp.com/latex.php?latex=O%28n+%5Clg+n%29&bg=ffffff&fg=333333&s=0" loading=lazy alt="O(n \lg n)"> time. Can you see how before reading on? You might also like to think about how we could actually implement a data structure that supports these operations.</p><h2 id=counting-inversions-with-bags-and-rank-queries>Counting inversions with bags and rank queries</h2><p>So, let‚Äôs see how to use a bag with logarithmic insertion and rank queries to count inversions. Start with an empty bag. For each element in the sequence, see how many things in the bag are strictly greater than it, and add this count to a running total; then insert the element into the bag, and repeat with the next element. That is, for each element we compute the number of inversions of which it is the right end, by counting how many elements that came before it (and are hence in the bag already) are strictly greater than it. It‚Äôs easy to see that this will count every inversion exactly once. It‚Äôs also easy to see that it will take <img src="https://s0.wp.com/latex.php?latex=O%28n+%5Clg+n%29&bg=ffffff&fg=333333&s=0" loading=lazy alt="O(n \lg n)"> time: for each of the <img src="https://s0.wp.com/latex.php?latex=n&bg=ffffff&fg=333333&s=0" loading=lazy alt=n> elements, we do two <img src="https://s0.wp.com/latex.php?latex=O%28%5Clg+n%29&bg=ffffff&fg=333333&s=0" loading=lazy alt="O(\lg n)"> operations (one rank query and one insertion).</p><p>In fact, we can do a lot more with this data structure than just count inversions; it sometimes comes in handy for competitive programming problems. More in a future post, perhaps!</p><p>So how do we implement this magical data structure? First of all, we can use a balanced binary search tree to store the values in the bag; clearly this will allow us to insert in logarithmic time. However, a plain binary search tree wouldn‚Äôt allow us to quickly count the number of values strictly greater than a given query value. The trick is to augment the tree so that each node also caches the size of the subtree rooted at that node, being careful to maintain these counts while inserting and balancing.</p><h2 id=augmented-red-black-trees-in-haskell>Augmented red-black trees in Haskell</h2><p>Let‚Äôs see some code! In Haskell, probably the easiest type of balanced BST to implement is a red-black tree. (If I were implementing this in an imperative language I might use <a class=link href=https://en.wikipedia.org/wiki/Splay_tree target=_blank rel=noopener>splay trees</a> instead, but they are super annoying to implement in Haskell. (At least as far as I know. I will definitely take you out for a social beverage of your choice if you can show me an elegant Haskell implementation of splay trees! <a class=link href=https://gist.github.com/m2ym/4232390 target=_blank rel=noopener>This</a> is cool but somehow feels too complex.)) However, this isn‚Äôt going to be some <a class=link href=https://github.com/sweirich/dth/tree/master/depending-on-types target=_blank rel=noopener>fancy, type-indexed, correct-by-construction implementation</a> of red-black trees, although that is certainly fun. I am actually going to implement <em>left-leaning</em> red-black trees, mostly following <a class=link href=https://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf target=_blank rel=noopener>Sedgewick</a>; see those slides for more explanation and proof. This is one of the simplest ways I know to implement red-black trees (though it‚Äôs not necessarily the most efficient).</p><p>First, a red-black tree is either empty, or a node with a color (which we imagine as the color of the incoming edge), a cached size, a value, and two subtrees.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt; {-# LANGUAGE PatternSynonyms #-} &gt; &gt; data Color = R | B &gt; deriving Show &gt; &gt; otherColor :: Color -&gt; Color &gt; otherColor R = B &gt; otherColor B = R &gt; &gt; data RBTree a &gt; = Empty &gt; | Node Color Int (RBTree a) a (RBTree a) &gt; deriving Show 
</span></span></code></pre></td></tr></table></div></div><p>To make some of the tree manipulation code easier to read, we make some convenient patterns for matching on the structure of a tree when we don‚Äôt care about the values or cached sizes: <code>ANY</code> matches any tree and its subtrees, while <code>RED</code> and <code>BLACK</code> only match on nodes of the appropriate color. We also make a function to extract the cached <code>size</code> of a subtree.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt; pattern ANY l r &lt;- Node _ _ l _ r &gt; pattern RED l r &lt;- Node R _ l _ r &gt; pattern BLACK l r &lt;- Node B _ l _ r &gt; &gt; size :: RBTree a -&gt; Int &gt; size Empty = 0 &gt; size (Node _ n _ _ _) = n 
</span></span></code></pre></td></tr></table></div></div><p>The next thing to implement is the workhorse of most balanced binary tree implementations: rotations. The fiddliest bit here is managing the cached sizes appropriately. When rotating, the size of the root node remains unchanged, but the new child node, as compared to the original, has lost one subtree and gained another. Note also that we will only ever rotate around red edges, so we pattern-match on the color as a sanity check, although this is not strictly necessary. The <code>error</code> cases below should never happen.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt; rotateL :: RBTree a -&gt; RBTree a &gt; rotateL (Node c n t1 x (Node R m t2 y t3)) &gt; = Node c n (Node R (m + size t1 - size t3) t1 x t2) y t3 &gt; rotateL _ = error &#34;rotateL on non-rotatable tree!&#34; &gt; &gt; rotateR :: RBTree a -&gt; RBTree a &gt; rotateR (Node c n (Node R m t1 x t2) y t3) &gt; = Node c n t1 x (Node R (m - size t1 + size t3) t2 y t3) &gt; rotateR _ = error &#34;rotateR on non-rotatable tree!&#34; 
</span></span></code></pre></td></tr></table></div></div><p>To <code>recolor</code> a node, we just flip its color. We can then <code>split</code> a tree with two red subtrees by recoloring all three nodes. (The ‚Äúsplit‚Äù terminology comes from the isomorphism between red-black trees and 2-3-4 trees; red edges can be thought of as ‚Äúgluing‚Äù nodes together into a larger node, and this recoloring operation corresponds to splitting a 4-node into three 2-nodes.)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt; recolor :: RBTree a -&gt; RBTree a &gt; recolor Empty = Empty &gt; recolor (Node c n l x r) = Node (otherColor c) n l x r &gt; &gt; split :: RBTree a -&gt; RBTree a &gt; split (Node c n l@(RED _ _) x r@(RED _ _)) &gt; = (Node (otherColor c) n (recolor l) x (recolor r)) &gt; split _ = error &#34;split on non-splittable tree!&#34; 
</span></span></code></pre></td></tr></table></div></div><p>Finally, we implement a function to ‚Äúfix up‚Äù the invariants by doing rotations as necessary: if we have two red subtrees we don‚Äôt touch them; if we have only one <em>right</em> red subtree we rotate it to the left (this is where the name ‚Äúleft-leaning‚Äù comes from), and if we have a left red child which itself has a left red child, we rotate right. (This function probably seems quite mysterious on its own; see <a class=link href=https://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf target=_blank rel=noopener>Sedgewick</a> for some nice pictures which explain it very well!)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt; fixup :: RBTree a -&gt; RBTree a &gt; fixup t@(ANY (RED _ _) (RED _ _)) = t &gt; fixup t@(ANY _ (RED _ _)) = rotateL t &gt; fixup t@(ANY (RED (RED _ _) _) _) = rotateR t &gt; fixup t = t 
</span></span></code></pre></td></tr></table></div></div><p>We can finally implement insertion. First, to insert into an empty tree, we create a red node with size 1.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt; insert :: Ord a =&gt; a -&gt; RBTree a -&gt; RBTree a &gt; insert a Empty = Node R 1 Empty a Empty 
</span></span></code></pre></td></tr></table></div></div><p>If we encounter a node with two red children, we perform a split before continuing. This may violate the red-black invariants above us, but we will fix it up later on our way back up the tree.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt; insert a t@(ANY (RED _ _) (RED _ _)) = insert a (split t) 
</span></span></code></pre></td></tr></table></div></div><p>Otherwise, we compare the element to be inserted with the root, insert on the left or right as appropriate, increment the cached size, and <code>fixup</code> the result. Notice that we don‚Äôt stop recursing upon encountering a value that is equal to the value to be inserted, because our goal is to implement a <em>bag</em> rather than a <em>set</em>. Here I have chosen to put values equal to the root in the left subtree, but it really doesn‚Äôt matter.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt; insert a (Node c n l x r) &gt; | a &lt;= x = fixup (Node c (n+1) (insert a l) x r) &gt; | otherwise = fixup (Node c (n+1) l x (insert a r)) 
</span></span></code></pre></td></tr></table></div></div><h2 id=implementing-rank-queries>Implementing rank queries</h2><p>Now, thanks to the cached sizes, we can count the values greater than a query value.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt; numGT :: Ord a =&gt; RBTree a -&gt; a -&gt; Int 
</span></span></code></pre></td></tr></table></div></div><p>The empty tree contains 0 values strictly greater than anything.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt; numGT Empty _ = 0 
</span></span></code></pre></td></tr></table></div></div><p>For a non-empty tree, we distinguish two cases:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt; numGT (Node _ n l x r) q 
</span></span></code></pre></td></tr></table></div></div><p>If the query value <code>q</code> is less than the root, then we know that the root along with <em>everything</em> in the right subtree is strictly greater than <code>q</code>, so we can just add <code>1 + size r</code> without recursing into the right subtree. We also recurse into the left subtree to count any values greater than <code>q</code> it contains.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt; | q &lt; x = numGT l q + 1 + size r 
</span></span></code></pre></td></tr></table></div></div><p>Otherwise, if <code>q</code> is greater than or equal to the root, any values strictly greater than <code>q</code> must be in the right subtree, so we recurse to count them.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt; | otherwise = numGT r q 
</span></span></code></pre></td></tr></table></div></div><p>By inspection we can see that <code>numGT</code> calls itself at most once, moving one level down the tree with each recursive call, so it makes a logarithmic number of calls, with only a constant amount of work at each call‚Äîthanks to the fact that <code>size</code> takes only constant time to look up a cached value.</p><h2 id=counting-inversions>Counting inversions</h2><p>Finally, we can put together the pieces to count inversions. The code is quite simple: recurse through the list with an accumulating red-black tree, doing a rank query on each value, and sum the results.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt; inversions :: Ord a =&gt; [a] -&gt; Int &gt; inversions = go Empty &gt; where &gt; go _ [] = 0 &gt; go t (a:as) = numGT t a + go (insert a t) as 
</span></span></code></pre></td></tr></table></div></div><p>Let‚Äôs try it out!</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Œª&gt; inversions [3,5,1,4,2] 6 Œª&gt; inversions [2,2,2,2,2,1] 5 Œª&gt; :set +s Œª&gt; inversions [3000, 2999 .. 1] 4498500 (0.19 secs, 96,898,384 bytes)
</span></span></code></pre></td></tr></table></div></div><p>It seems to work, and is reasonably fast!</p><h2 id=exercises>Exercises</h2><ol><li><p>Further augment each node with a counter representing the number of copies of the given value which are contained in the bag, and maintain the invariant that each distinct value occurs in only a single node.</p></li><li><p>Rewrite <code>inversions</code> without a recursive helper function, using a scan, a zip, and a fold.</p></li><li><p>It should be possible to implement bags with rank queries using <a class=link href=http://hackage.haskell.org/package/fingertree-0.1.4.2/docs/Data-FingerTree.html target=_blank rel=noopener>fingertrees</a> instead of building our own custom balanced tree type (though it seems kind of overkill).</p></li><li><p>My intuition tells me that it is not possible to count inversions faster than <img src="https://s0.wp.com/latex.php?latex=n+%5Clg+n&bg=ffffff&fg=333333&s=0" loading=lazy alt="n \lg n">. Prove it.</p></li></ol><p>from Hacker News <a class=link href=https://ift.tt/34yYBFY target=_blank rel=noopener>https://ift.tt/34yYBFY</a></p></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><footer class=site-footer><section class=copyright>&copy;
2020 -
2022 ZYChimne</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.11.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#counting-inversions-with-bags-and-rank-queries>Counting inversions with bags and rank queries</a></li><li><a href=#augmented-red-black-trees-in-haskell>Augmented red-black trees in Haskell</a></li><li><a href=#implementing-rank-queries>Implementing rank queries</a></li><li><a href=#counting-inversions>Counting inversions</a></li><li><a href=#exercises>Exercises</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>