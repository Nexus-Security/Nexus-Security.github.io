<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=robots content="index,follow"><meta name=googlebot content="index,follow"><link rel=sitemap type=application/xml title=Sitemap href=https://nexus-security.github.io/sitemap.xml><meta property="og:type" content="article"><meta name=author content="0x000216"><meta property="og:locale" content="en"><meta name=language content="English"><base href=https://Nexus-Security.github.io/posts/2016-09-09-atari-8-bit-display-list-interrupts/><link rel=icon href=/fav.ico type=image/x-icon><link rel=alternate type=application/rss+xml title=RSS href=https://nexus-security.github.io/index.xml><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A Crash Course on Advanced DLIs Atari 8-bit Display List Interrupts: An Advanced Tutorial
Revision 1, updated 3 Dec 2019
This is a tutorial on advanced Display List Interrupts (DLIs) for the Atari 8-bit series of computers. In a nutshell, DLIs provide a way to notify your program when a particular scan line is reached, allowing you to make changes mid-screen.
DLIs are an advanced programming technique in the sense that they require knowledge of 6502 assembly language, so this tutorial is going to assume that you are comfortable with that."><title>Atari 8-Bit Display List Interrupts: An Advanced Tutorial</title><link rel=canonical href=https://Nexus-Security.github.io/posts/2016-09-09-atari-8-bit-display-list-interrupts/><link rel=stylesheet href=/scss/style.min.1f3200acb41251d94439982f0ccc8f6599efd31eaa9b4d6412b905bc3d5fa0b8.css><meta property="og:title" content="Atari 8-Bit Display List Interrupts: An Advanced Tutorial"><meta property="og:description" content="A Crash Course on Advanced DLIs Atari 8-bit Display List Interrupts: An Advanced Tutorial
Revision 1, updated 3 Dec 2019
This is a tutorial on advanced Display List Interrupts (DLIs) for the Atari 8-bit series of computers. In a nutshell, DLIs provide a way to notify your program when a particular scan line is reached, allowing you to make changes mid-screen.
DLIs are an advanced programming technique in the sense that they require knowledge of 6502 assembly language, so this tutorial is going to assume that you are comfortable with that."><meta property="og:url" content="https://Nexus-Security.github.io/posts/2016-09-09-atari-8-bit-display-list-interrupts/"><meta property="og:site_name" content="0x000216"><meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:published_time" content="2019-12-05T04:01:00+01:00"><meta property="article:modified_time" content="2019-12-05T04:01:00+01:00"><meta name=twitter:title content="Atari 8-Bit Display List Interrupts: An Advanced Tutorial"><meta name=twitter:description content="A Crash Course on Advanced DLIs Atari 8-bit Display List Interrupts: An Advanced Tutorial
Revision 1, updated 3 Dec 2019
This is a tutorial on advanced Display List Interrupts (DLIs) for the Atari 8-bit series of computers. In a nutshell, DLIs provide a way to notify your program when a particular scan line is reached, allowing you to make changes mid-screen.
DLIs are an advanced programming technique in the sense that they require knowledge of 6502 assembly language, so this tutorial is going to assume that you are comfortable with that."><link rel="shortcut icon" href=/fav.ico></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"light")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hue825486955cd7c56d95e38b4bd2a8e3c_229979_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>0x000216</a></h1><h2 class=site-description>Where Do Russian Hackers Store Their Exploits? ü§ì /ussr/bin/ üòã</h2></div></header><ol class=social-menu><li><a href=https://github.com/Nexus-Security target=_blank title=GitHub><svg width="72" height="72" viewBox="0 0 72 72" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><path d="M36 72c19.882251.0 36-16.117749 36-36 0-19.882251-16.117749-36-36-36-19.882251 365231026e-23-36 16.117749-36 36C24348735e-22 55.882251 16.117749 72 36 72z" fill="#3e75c3"/><path d="M35.9985 12C22.746 12 12 22.7870921 12 36.096644c0 10.6440272 6.876 19.6751861 16.4145 22.8617681C29.6145 59.1797862 30.0525 58.4358488 30.0525 57.7973276 30.0525 57.2250681 30.0315 55.7100863 30.0195 53.6996482c-6.6765 1.4562499-8.085-3.2302544-8.085-3.2302544-1.0905-2.7829884-2.664-3.5239139-2.664-3.5239139C17.091 45.4500754 19.4355 45.4801943 19.4355 45.4801943c2.4075.1701719 3.675 2.4833051 3.675 2.4833051 2.142 3.6820383 5.6175 2.6188404 6.9855 2.0014024C30.3135 48.4077535 30.9345 47.3460615 31.62 46.7436831 26.2905 46.1352808 20.688 44.0691228 20.688 34.8361671c0-2.6308879.9345-4.781379 2.4705-6.4665327C22.911 27.7597262 22.0875 25.3110578 23.3925 21.9934585c0 0 2.016-.6475568 6.6 2.4697516C31.908 23.9285993 33.96 23.6620468 36.0015 23.6515052 38.04 23.6620468 40.0935 23.9285993 42.0105 24.4632101c4.581-3.1173084 6.5925-2.4697516 6.5925-2.4697516C49.9125 25.3110578 49.089 27.7597262 48.8415 28.3696344 50.3805 30.0547881 51.309 32.2052792 51.309 34.8361671c0 9.2555448-5.6115 11.29309-10.9575 11.8894446.860999999999997.7439374 1.629 2.2137408 1.629 4.4621184C41.9805 54.4089489 41.9505 57.0067059 41.9505 57.7973276 41.9505 58.4418726 42.3825 59.1918338 43.6005 58.9554002 53.13 55.7627944 60 46.7376593 60 36.096644 60 22.7870921 49.254 12 35.9985 12" fill="#fff"/></g></svg></a></li><li><a href=mailto:0x000216@gmail.com target=_blank title=Email><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" style="enable-background:new 0 0 512 512"><path style="fill:#e6f3ff" d="M512 105.739v300.522c0 27.715-22.372 50.087-50.087 50.087H50.087C22.372 456.348.0 433.976.0 406.261V105.739c0-.89.0-1.781.111-2.671 1.336-25.6 21.704-45.969 47.304-47.304.89-.111 1.781-.111 2.671-.111h411.826c.89.0 1.892.0 2.783.111 25.489 1.336 45.857 21.704 47.193 47.193C512 103.847 512 104.849 512 105.739z"/><path style="fill:#cfdbe6" d="M464.696 55.763c-.892-.111-1.891-.111-2.783-.111H256v400.696h205.913c27.715.0 50.087-22.372 50.087-50.087V105.739c0-.89.0-1.892-.111-2.783C510.553 77.468 490.184 57.099 464.696 55.763z"/><path style="fill:#ff4b26" d="M511.889 102.957c-1.336-25.489-21.704-45.857-47.193-47.193C382.89 137.569 336.951 183.509 256 264.459 225.291 233.732 77.61 85.958 47.416 55.763c-25.6 1.336-45.969 21.704-47.304 47.304C0 103.958.0 104.849.0 105.739v300.522c0 27.715 22.372 50.087 50.087 50.087h16.696V169.739l165.621 165.51c6.456 6.567 15.026 9.795 23.597 9.795 8.57.0 17.141-3.228 23.597-9.795l165.621-165.621v286.72h16.696c27.715.0 50.087-22.372 50.087-50.087V105.739C512 104.849 512 103.847 511.889 102.957z"/><path style="fill:#d93f21" d="M279.596 335.249l165.621-165.621v286.72h16.696c27.715.0 50.087-22.372 50.087-50.087V105.739c0-.89.0-1.892-.111-2.783-1.336-25.489-21.704-45.857-47.193-47.193C382.891 137.569 336.951 183.509 256 264.459v80.584C264.57 345.043 273.141 341.816 279.596 335.249z"/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/></svg></a></li><li><a href=https://nexus-security.github.io/index.xml target=_blank title=RSS><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" style="enable-background:new 0 0 512 512"><path style="fill:#f78c20" d="M78.333 355.334C35.14 355.334.0 390.474.0 433.667S35.14 512 78.333 512s78.333-35.14 78.333-78.333-35.14-78.333-78.333-78.333z"/><g><path style="fill:#ffa929" d="M78.333 381.445c-28.795.0-52.222 23.427-52.222 52.222s23.427 52.222 52.222 52.222 52.222-23.427 52.222-52.222-23.427-52.222-52.222-52.222z"/><path style="fill:#ffa929" d="M477.918 264.861c-21.843-51.641-53.111-98.019-92.936-137.842-39.824-39.824-86.201-71.093-137.843-92.935C193.669 11.468 136.874.0 78.333.0c-4.807.0-8.704 3.897-8.704 8.704v85.519c0 4.807 3.897 8.704 8.704 8.704 182.37.0 330.74 148.369 330.74 330.74.0 4.807 3.897 8.704 8.704 8.704h85.52c4.807.0 8.704-3.897 8.704-8.704C512 375.126 500.533 318.331 477.918 264.861z"/><path style="fill:#ffa929" d="M78.333 163.853c-4.807.0-8.704 3.897-8.704 8.704v95.74c0 4.807 3.897 8.704 8.704 8.704 86.386.0 156.666 70.281 156.666 156.666.0 4.807 3.897 8.704 8.704 8.704h95.74c4.807.0 8.704-3.897 8.704-8.704.0-72.07-28.065-139.826-79.027-190.787-50.961-50.961-118.717-79.027-190.787-79.027z"/></g><g><path style="fill:#f78c20" d="M78.333 242.186c-2.918.0-5.817.076-8.704.206v25.905c0 4.807 3.897 8.704 8.704 8.704 86.386.0 156.666 70.281 156.666 156.666.0 4.807 3.897 8.704 8.704 8.704h25.905c.129-2.886.206-5.786.206-8.704.0-105.752-85.729-191.481-191.481-191.481z"/><path style="fill:#f78c20" d="M78.333 68.113c-2.91.0-5.81.042-8.704.11v26.001c0 4.807 3.897 8.704 8.704 8.704 182.37.0 330.74 148.369 330.74 330.74.0 4.807 3.897 8.704 8.704 8.704h26.001c.067-2.894.11-5.793.11-8.704C443.887 231.777 280.223 68.113 78.333 68.113z"/></g><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/></svg></a></li><li><a href target=_blank title=Slack><svg width="256" height="256" viewBox="0 0 256 256" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid"><path d="M165.964 15.838c-3.89-11.975-16.752-18.528-28.725-14.636-11.975 3.89-18.528 16.752-14.636 28.725l58.947 181.365c4.048 11.187 16.132 17.473 27.732 14.135 12.1-3.483 19.475-16.334 15.614-28.217L165.964 15.838" fill="#dfa22f"/><path d="M74.626 45.516C70.734 33.542 57.873 26.989 45.9 30.879 33.924 34.77 27.37 47.631 31.263 59.606l58.948 181.366c4.047 11.186 16.132 17.473 27.732 14.132 12.099-3.481 19.474-16.332 15.613-28.217L74.626 45.516" fill="#3cb187"/><path d="M240.162 166.045c11.975-3.89 18.526-16.75 14.636-28.726-3.89-11.973-16.752-18.527-28.725-14.636L44.708 181.632c-11.187 4.046-17.473 16.13-14.135 27.73 3.483 12.099 16.334 19.475 28.217 15.614l181.372-58.93" fill="#ce1e5b"/><path d="M82.508 217.27l43.347-14.084-14.086-43.352-43.35 14.09 14.089 43.347" fill="#392538"/><path d="M173.847 187.591c16.388-5.323 31.62-10.273 43.348-14.084l-14.088-43.36-43.35 14.09 14.09 43.354" fill="#bb242a"/><path d="M210.484 74.706c11.974-3.89 18.527-16.751 14.637-28.727-3.89-11.973-16.752-18.526-28.727-14.636L15.028 90.293C3.842 94.337-2.445 106.422.896 118.022c3.481 12.098 16.332 19.474 28.217 15.613l181.371-58.93" fill="#72c5cd"/><path d="M52.822 125.933c11.805-3.836 27.025-8.782 43.354-14.086-5.323-16.39-10.273-31.622-14.084-43.352l-43.36 14.092 14.09 43.346" fill="#248c73"/><path d="M144.16 96.256l43.356-14.088a546179.21 546179.21.0 00-14.089-43.36L130.07 52.9l14.09 43.356" fill="#62803a"/></svg></a></li><li><a href=https://www.minds.com/0x000216/ target=_blank title=Minds><svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" style="enable-background:new 0 0 512 512"><g><g><path style="fill:#ffe1b2" d="M256 33.085C245.078 13.38 224.079.0 2e2.0c-23.781.0-45.57 13.293-56.594 34.184C115.711 41.602 96 66.977 96 96c0 .059.0.113.0.172-9.977 7.512-16 19.301-16 31.828.0 1.316.078 2.637.234 3.992C60.211 145.266 48 167.758 48 192c0 14.07 4.039 27.543 11.719 39.262C57.273 236.512 56 242.207 56 248c0 2.738.281 5.445.828 8.098C36.672 267.308 24 288.539 24 312c0 27.973 18.305 52.34 44.109 60.785C65.398 378.828 64 385.324 64 392c0 21.098 13.805 39.508 33.539 45.727C103.891 466.746 129.828 488 160 488c4.617.0 9.227-.512 13.766-1.527C181.992 502 198.141 512 216 512c16.687.0 31.396-8.567 40-21.523V33.085z"/></g><g><g><path style="fill:#ffb980" d="M264 256c-4.422.0-8-3.582-8-8 0-22.055-17.945-40-40-40-8.008.0-15.734 2.355-22.336 6.812-3.023 2.043-7.055 1.781-9.797-.652-3.156-2.809-8.477-6.16-15.867-6.16-4.422.0-8-3.582-8-8s3.578-8 8-8c7.711.0 15.234 2.293 21.719 6.539C197.773 194.246 206.758 192 216 192c30.875.0 56 25.121 56 56C272 252.418 268.422 256 264 256z"/></g></g><g><g><path style="fill:#ffb980" d="M120 120c18.977.0 36.875 7.312 50.414 20.594 3.141 3.09 8.203 3.047 11.312-.109 3.094-3.152 3.047-8.219-.109-11.312C165.07 112.941 143.187 104 120 104c-13.046.0-25.395 2.93-36.542 8.046C81.253 117.019 80 122.423 80 128c0 1.316.078 2.637.234 3.992-.094.062-.173.139-.267.202C91.423 124.501 105.193 120 120 120z"/></g></g><g><g><path style="fill:#ffb980" d="M216 360c0-4.418-3.578-8-8-8s-8 3.582-8 8c0 17.645-14.352 32-32 32-14.211.0-26.82-9.648-30.664-23.465-.703-2.512-2.578-4.523-5.039-5.395-2.453-.871-5.188-.492-7.305 1.02C114.094 371.906 101.305 376 88 376c-6.948.0-13.625-1.149-19.894-3.207-2.214 4.939-3.501 10.19-3.916 15.586C71.714 390.73 79.711 392 88 392c13.297.0 26.187-3.266 37.773-9.52C133.969 397.894 150.141 408 168 408c26.469.0 48-21.531 48-48z"/></g></g><g><path style="fill:#fdc88e" d="M488 312c0-23.461-12.672-44.691-32.828-55.902.547-2.652.828-5.359.828-8.098.0-5.793-1.273-11.488-3.719-16.738C459.961 219.543 464 206.07 464 192c0-24.242-12.211-46.734-32.234-60.008.156-1.355.234-2.676.234-3.992.0-12.527-6.023-24.316-16-31.828.0-.059.0-.113.0-.172.0-29.023-19.711-54.398-47.406-61.816C357.57 13.293 335.781.0 312 0c-24.08.0-45.078 13.38-56 33.085v457.391C264.604 503.433 279.313 512 296 512c17.859.0 34.008-10 42.234-25.527C342.773 487.488 347.383 488 352 488c30.172.0 56.109-21.254 62.461-50.273C434.195 431.508 448 413.097 448 392c0-6.676-1.398-13.172-4.109-19.215C469.695 364.34 488 339.973 488 312z"/></g><g><path style="fill:#f8ab6b" d="M272.008 151.199C272 151.465 272 151.734 272 152c0 26.469 21.531 48 48 48s48-21.531 48-48c0-4.418-3.578-8-8-8s-8 3.582-8 8c0 17.645-14.352 32-32 32s-32-14.355-32-32c0-2.184.219-4.359.656-6.465.492-2.395-.133-4.883-1.703-6.754-1.57-1.871-4.016-3.066-6.352-2.859-.453.012-.891.059-.602.078-13.234.0-24-10.766-24-24v31.813C260.673 147.348 266.061 149.988 272.008 151.199z"/></g><g><path style="fill:#f8ab6b" d="M296 328c9.242.0 18.219-2.246 26.281-6.539C328.765 325.707 336.289 328 344 328c4.422.0 8-3.582 8-8s-3.578-8-8-8c-7.391.0-12.711-3.352-15.867-6.16-2.742-2.434-6.766-2.695-9.797-.656C311.726 309.644 304 312 296 312c-22.055.0-40-17.945-40-40v39.116C266.174 321.517 280.337 328 296 328z"/></g><g><g><path style="fill:#f8ab6b" d="M431.765 131.992c.156-1.355.234-2.676.234-3.992.0-5.577-1.253-10.981-3.458-15.954C417.395 106.93 405.046 104 392 104c-4.422.0-8 3.582-8 8s3.578 8 8 8c14.807.0 28.577 4.501 40.032 12.194C431.939 132.131 431.859 132.054 431.765 131.992z"/></g></g><g><g><path style="fill:#f8ab6b" d="M447.81 388.38c-.415-5.396-1.702-10.647-3.916-15.586C437.624 374.85 430.948 376 424 376c-13.578.0-26.594-4.266-37.641-12.332-2.07-1.5-4.719-1.93-7.133-1.168-2.43.77-4.344 2.648-5.164 5.059C369.101 382.176 355.414 392 340 392c-4.422.0-8 3.582-8 8s3.578 8 8 8c18.875.0 35.961-10.191 45.094-26.156C396.976 388.512 410.258 392 424 392 432.288 392 440.285 390.73 447.81 388.38z"/></g></g></g><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/></svg></a></li><li><a href=https://www.buymeacoffee.com/0x000216 target=_blank title=Coffee><svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 340 340" style="enable-background:new 0 0 340 340"><g id="XMLID_18_"><polygon id="XMLID_138_" style="fill:#dedde0" points="76.429,290 80,340 170,340 170,290"/><polygon id="XMLID_169_" style="fill:#dedde0" points="170,80 61.429,80 65,130 170,130"/><polygon id="XMLID_197_" style="fill:#acabb1" points="170,290 170,340 260,340 263.571,290"/><polygon id="XMLID_221_" style="fill:#acabb1" points="170,80 170,130 275,130 278.571,80"/><path id="XMLID_222_" style="fill:#ffda44" d="M170 260c-22.091.0-40-22.386-40-50s17.909-50 40-50v-30H65 50l10 160h16.429H170V260z"/><path id="XMLID_33_" style="fill:#ff9811" d="M170 130v30c22.091.0 40 22.386 40 50s-17.909 50-40 50v30h93.571H280l10-160h-15H170z"/><path id="XMLID_223_" style="fill:#50412e" d="M210 210c0-27.614-17.909-50-40-50v1e2c22.091.0 40-22.386 40-50z"/><path id="XMLID_224_" style="fill:#786145" d="M130 210c0 27.614 17.909 50 40 50V160c-22.091.0-40 22.386-40 50z"/><polygon id="XMLID_225_" style="fill:#50412e" points="278.571,80 300,80 300,40 260,40 260,0 80,0 80,40 40,40 40,80 61.429,80 170,80"/></g><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/about/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>About Us</span></a></li><li><a href=/termsofservice/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-pencil" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 20h4L18.5 9.5a1.5 1.5.0 00-4-4L4 16v4"/><line x1="13.5" y1="6.5" x2="17.5" y2="10.5"/></svg><span>Terms Of Service</span></a></li><li><a href=/privacypolicy/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Privacy Policy</span></a></li><li><a href=/disclaimer/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg><span>Disclaimer</span></a></li><li><a href=/contact/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-mail" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><rect x="3" y="5" width="18" height="14" rx="2"/><polyline points="3 7 12 13 21 7"/></svg><span>Contact Us</span></a></li><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></div></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/posts/2016-09-09-atari-8-bit-display-list-interrupts/>Atari 8-Bit Display List Interrupts: An Advanced Tutorial</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Dec 05, 2019</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>43 minute read</time></div></footer></div></header><section class=article-content><h1 id=a-crash-course-on-advanced-dlis>A Crash Course on Advanced DLIs</h1><p><strong><strong>Atari 8-bit Display List Interrupts: An Advanced Tutorial</strong></strong></p><p><strong>Revision 1, updated 3 Dec 2019</strong></p><p>This is a tutorial on advanced Display List Interrupts (DLIs) for the Atari 8-bit series of computers. In a nutshell, DLIs provide a way to notify your program when a particular scan line is reached, allowing you to make changes mid-screen.</p><p>DLIs are an advanced programming technique in the sense that they require knowledge of 6502 assembly language, so this tutorial is going to assume that you are comfortable with that. All the examples here are assembled using the MAC/65-compatible assembler <a class=link href=https://atari.miribilist.com/atasm/index.html target=_blank rel=noopener>ATasm</a> (and more specifically to this tutorial, the version built-in to <a class=link href=https://github.com/robmcmullen/omnivore target=_blank rel=noopener>Omnivore</a>).</p><p>Before diving into DLIs, it is helpful to understand that they are very accurately named: Display List Interrupts literally interrupt the display list ‚Äì they cause an event that is processed by your program while the ANTIC is drawing the screen. So it is necessary to understand what display lists are before understanding what it means to interrupt one.</p><p>See also</p><p>Here are some resources for learning more about display list interrupts:</p><h2 id=a-crash-course-on-displays>A Crash Course on Displays</h2><p>A TV screen is drawn by an electron beam tracing a path starting above the visible area, and drawing successive horizontal lines as the beam moves down the screen. Each line is drawn from left-to-right (as you look at the TV screen) and when it reaches the right hand side of the screen, the horizontal retrace starts where the beam is turned off and moved down to the next scan line below whereupon the beam is turned back on and the next line draws. When the full frame has been drawn, the beam is turned off again and the vertical retrace starts (starting the vertical blank interval). Once the beam is repositioned to the top leftmost position, the vertical blank interval ends, the beam is turned back on, and the next frame is started.</p><p>On NTSC systems, the Atari draws 262 scan lines per frame, 60 times per second. On PAL systems it draws 312 scan lines per frame, 50 times per second. In either system, it draws scan lines from the top down, and left to right within a scan line.</p><p>This simplified description is the mental model we will use to describe the video drawing process.</p><h3 id=how-interlacing-works-with-some-hand-waving-and-why-we-ignore-it>How Interlacing Works (With Some Hand Waving) and Why We Ignore It</h3><p>Real TVs are interlaced with 525 scan lines for NTSC and 625 for PAL. Because of <a class=link href=https://en.wikipedia.org/wiki/NTSC#Lines_and_refresh_rate target=_blank rel=noopener>reasons</a>, the NTSC vertical refresh interval is not exactly the whole number of 60Hz either, it‚Äôs 60/1001 Hz or 59.94Hz. PAL refresh rate is apparently <a class=link href=http://martin.hinner.info/vga/pal.html target=_blank rel=noopener>exactly 50Hz</a>.</p><p>Every refresh interval, the electron beam draws one <strong>field</strong>, starting at the top left and drawing every other scan line. When it reaches the bottom, the vertical retrace starts, but this time it positions the electron beam at the first missing scan line. Then it draws the next field, again skipping every other scan line but this time filling in the scan lines it missed.</p><p><img src=https://playermissile.com/_images/electron-beam-interlaced.png loading=lazy alt=../_images/electron-beam-interlaced.png></p><p>This drawing is a simplification, seeming to show that there are 524 scan lines. In reality, and there are 525 and each field actually draws 262 <strong>and one half</strong> scan lines (and not 262 on one field and 263 on another), but this is all very complicated and not necessary for our purposes. However, at the risk of further complicating matters, the Atari produces 262 scan lines for the even field and 262 scan lines for the odd field. In the situation where the Atari is producing an image that is not changing as time goes on, like the computer is sitting at the BASIC language READY prompt and you aren‚Äôt typing anything, the scan lines produced for the even field will be exactly the same as the scan lines produced for the odd field.</p><p>Practically speaking, you do not need to care that the screen is interlaced with 525 scan lines (for NTSC). Our mental model will be as if the Atari is drawing to a non-interlaced screen with 262 scan lines and a frame rate of 59.94Hz. (For PAL, substitute 625, 312, and 50, respectively.)</p><h3 id=how-color-works-and-theres-more-hand-waving-isnt-there>How Color Works and There‚Äôs More Hand Waving, Isn‚Äôt There?</h3><p>How TVs produce the colors that they display is very complicated and so far outside the scope of this tutorial that it might as well be magic. Suffice it to say that color happens.</p><p>On the Atari, a unit called the color clock is the smallest portion of a scan line that can be displayed with an arbitrary color. There are 228 color clocks per scan line, of which about 160 were typically visible on a cathode-ray TV display in the 1970s when the Atari was developed. This corresponds to the 160 pixel horizontal resolution of Antic Modes B through E in the standard width playfield. Antic Mode F (Graphics 8 in BASIC) has 320 addressable pixels, corresponding to half a color clock, and only artifacting color is available.</p><h3 id=how-the-cpu-frequency-was-chosen-and-why-is-there-even-more-hand-waving-oh-author-person>How The CPU Frequency Was Chosen and Why Is There Even More Hand Waving, Oh Author Person?</h3><p>For NTSC machines, each frame draws 262 scan lines with 228 color clocks per scan line, the operating frequency of the 6502 was chosen such that it takes exactly 114 machine cycles per scan line, producing 29868 machine cycles per frame. With a 59.94Hz vertical refresh rate this should result in a processor speed of 1.790287MHz. Here‚Äôs where the author does more hand waving because he doesn‚Äôt exactly understand what the subtleties are and why those numbers aren‚Äôt exact, and instead points to the Altirra Hardware Reference Manual and lets it explain what is really happening. It shows that while there <em>are</em> indeed 29868 cycles per frame, the processor speed is actually 1.790772MHz, to prevent the color subprime mortgage from investigating phantoms on each scan line. Something like that; the author didn‚Äôt understand. <em>At all</em>. At any rate, a signal is produced that can be displayed on a TV, even if it does not exactly sync up with broadcast NTSC signals.</p><p>PAL systems produce the same 228 color clocks and 114 machine cycles per line, but display 312 scan lines. This results in 35568 cycles per frame, and with the vertical refresh rate of 50Hz the processor should run at 1.778400MHz. Again, the Altirra reference manual shows slight deviations for complicated technical reasons resulting in a processor speed of 1.773447MHz. Similarly to NTSC, the computer still produces 35568 cycles per frame, just that the signal output for the TV is not exactly the same as broadcast PAL TV signals.</p><h2 id=a-crash-course-on-display-lists>A Crash Course on Display Lists</h2><p>ANTIC is the special coprocessor that handles screen drawing for the Atari computers. It is tightly coupled with the 6502 processor, and in fact can be thought of as being the driver of the 6502 because the ANTIC can halt the 6502 when needed. Since only one chip can read memory at any time, ANTIC needs to halt the 6502 when it needs access to memory, so this Direct Memory Access (DMA) can cause 6502 instructions to appear to take more cycles than documented in a 6502 reference. In fact, the amount of time ANTIC ‚Äústeals‚Äù will depend on many factors: the graphics mode, player/missiles being used, playfield size, and more.</p><p>Since there are 228 color clocks and 114 machine cycles per scan line, this means that in one machine cycle, two color clocks are drawn on the screen. A typical machine instruction might take 5 machine cycles, so 10 color clocks could pass in the time to process a single instruction! This means we don‚Äôt have much time per scan line, so DLIs that attempt to change graphics in the middle of a line will have to be well optimized.</p><p>It also means the 6502 is too slow to draw the screen itself, and this is where ANTIC‚Äôs special ‚Äúinstruction set‚Äù comes in. You program the ANTIC coprocessor using a display list, and ANTIC takes care of building the screen scan line by scan line, without any more intervention from the 6502 code. (Unless you ask for intervention! And that‚Äôs what a DLI is.)</p><p>The display list is the special sequence of bytes that ANTIC interprets as a list of instruction. Each instruction causes ANTIC to draw a certain number of scan lines in a particular way. A DLI can be set on any ANTIC instruction.</p><p>ANTIC supports display lists that produce at most 240 scan lines (even on PAL systems where many more scan lines are available), and the vertical blank interval always starts after 248 scan lines. When drawing scan lines, ANTIC skips 8 scan lines at to top of the display, so the output from the display list starts at the 9th scan line. A standard display list starts with 24 blank lines and 192 scan lines of display data, meaning that the TV will see 32 blank lines (the 8 automatically skipped plus the 24 in a standard display list) followed by 192 scan lines of display, then 24 blank lines, and finally the vertical blank that consumes the remaining 14 scan lines on NTSC (or 64 on PAL).</p><h3 id=display-list-instruction-set>Display List Instruction Set</h3><p>An ANTIC display list instruction consists of 1 byte with an optional 2 byte address. There are 3 types of instructions: blank lines, graphics modes, and jump instructions. Instructions are encoded into the byte using a bitmask where low 4 bits encode the graphics mode or feature and the high 4 bits encode the flags that affect that instruction:</p><blockquote><p>7</p><p>6</p><p>5</p><p>4</p><p>3</p><p>2</p><p>1</p><p>0</p><p>DLI</p><p>LMS</p><p>VSCROLL</p><p>HSCROLL</p><p>Mode</p></blockquote><p>The 4 flags are:</p><blockquote><ul><li><p>DLI (<code>$80</code>): enable a display list interrupt when processing this instruction</p></li><li><p>LMS (<code>$40</code>): trigger a Load Memory Scan, changing where ANTIC looks for screen data, and requires an additional 2 byte address immediately following this instruction byte.</p></li><li><p>VSCROLL (<code>$20</code>): enable vertical scrolling for this mode line</p></li><li><p>HSCROLL (<code>$10</code>): enable horizontal scrolling for this mode line</p></li></ul></blockquote><p>The 14 available graphics modes are encoded into low 4 bits using values as shown in this table:</p><p>Mode</p><p>Decimal</p><p>BASIC Mode</p><p>Description</p><p>Scan Lines</p><p>Type</p><p>Colors</p><p>2</p><p>02</p><p>0</p><p>40 x 24</p><p>8</p><p>text</p><p>2</p><p>3</p><p>03</p><p>n/a</p><p>40 x 19</p><p>10</p><p>text</p><p>2</p><p>4</p><p>04</p><p>n/a</p><p>40 x 24</p><p>8</p><p>text</p><p>4</p><p>5</p><p>05</p><p>n/a</p><p>40 x 12</p><p>16</p><p>text</p><p>4</p><p>6</p><p>06</p><p>1</p><p>20 x 24</p><p>8</p><p>text</p><p>5</p><p>7</p><p>07</p><p>2</p><p>20 x 12</p><p>16</p><p>text</p><p>5</p><p>8</p><p>08</p><p>3</p><p>40 x 24</p><p>8</p><p>bitmap</p><p>4</p><p>9</p><p>09</p><p>4</p><p>80 x 48</p><p>4</p><p>bitmap</p><p>2</p><p>A</p><p>10</p><p>5</p><p>80 x 48</p><p>4</p><p>bitmap</p><p>4</p><p>B</p><p>11</p><p>6</p><p>160 x 96</p><p>2</p><p>bitmap</p><p>2</p><p>C</p><p>12</p><p>n/a</p><p>160 x 192</p><p>1</p><p>bitmap</p><p>2</p><p>D</p><p>13</p><p>7</p><p>160 x 96</p><p>2</p><p>bitmap</p><p>4</p><p>E</p><p>14</p><p>n/a</p><p>160 x 192</p><p>1</p><p>bitmap</p><p>4</p><p>F</p><p>15</p><p>8</p><p>320 x 192</p><p>1</p><p>bitmap*</p><p>2</p><p><a class=link href=https://playermissile.com/dli_tutorial/#id1 target=_blank rel=noopener>*</a>mode F is also used as the basis for the GTIA modes (BASIC Graphics modes 9, 10, & 11), but this is a topic outside the scope of this tutorial.</p><p>Blank lines are encoded as a mode value of zero, the bits 6, 5, and 4 taking the meaning of the number of blank lines rather than LMS, VSCROLL, and HSCROLL. Note that the DLI bit is still available on blank lines, as bit 7 is not co-opted by the blank line instruction.</p><p>Blank Line Instructions</p><p>Hex</p><p>Decimal</p><p>Blank Lines</p><p>0</p><p>0</p><p>1</p><p>10</p><p>16</p><p>2</p><p>20</p><p>32</p><p>3</p><p>30</p><p>48</p><p>4</p><p>40</p><p>64</p><p>5</p><p>50</p><p>80</p><p>6</p><p>60</p><p>96</p><p>7</p><p>70</p><p>112</p><p>8</p><p>Jumps provide the capability to split a display list into multiple parts in different memory locations. They are encoded using a mode value of one, and require an additional 2 byte address where ANTIC will look for the next display list instruction. If bit 6 is also set, it becomes the Jump and wait for Vertical Blank (JVB) instruction, which is how ANTIC knows that the display list is finished. The DLI bit may also be set on a jump instruction, but if set on the JVB instruction it triggers a DLI on every scan line from there until the vertical blank starts on the 249th scan line.</p><p>Note</p><p>Apart from the <code>$41</code> JVB instruction, splitting display lists using other jumps like the <code>$01</code> instruction is not common. It has a side-effect of producing a single blank line in the display list.</p><p>The typical method to change the currently active display list is to change the address stored at <code>SDLSTL</code> (in low byte/high byte format in addresses <code>$230</code> and <code>$231</code>). At the next vertical blank, the hardware display list at <code>DLISTL</code> (<code>$d402</code> and <code>$d403</code>) will be updated with the values stored here and the screen drawing will commence using the new display list.</p><p>See also</p><p>More resources about display lists are available:</p><h3 id=a-sample-display-list>A Sample Display List</h3><p>Here is a display list that contains different text modes mixed in a single screen.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>dlist .byte $70,$70,$70 ; 24 blank lines .byte $46,$00,$40 ; Mode 6 + LMS, setting screen memory to $4000 .byte 6 ; Mode 6 .byte $70 ; 8 blank lines .byte 7,7,7,7,7 ; 5 lines of Mode 7 .byte $70 ; 8 blank lines .byte 2 ; single line of Mode 2 .byte $70,$70,$70 ; 24 blank lines .byte 2,4 ; Mode 2 followed by mode 4 .byte $70 ; 8 blank lines .byte 2,5 ; Mode 2 followed by mode 5 .byte $41,&lt;dlist,\&gt;dlist ; JVB, restart same display list on next frame 
</span></span></code></pre></td></tr></table></div></div><h3 id=cycle-stealing-by-antic>Cycle Stealing by ANTIC</h3><p>The ANTIC coprocessor needs to access memory to perform its functions, and since the 6502 and ANTIC can‚Äôt both access at once, ANTIC will pause execution of the 6502 when it needs to read memory. It happens at specific points within the 114 cycles of each scan line, but where it happens (and how many times the 6502 gets paused during the scan line) depends on the graphics mode.</p><p>For overhead, ANTIC will typically steal 3 cycles to read the display list, 5 cycles if player/missile graphics are enabled, and 9 cycles for memory refreshing. Scrolling requires additional cycle stealing because ANTIC needs to fetch more memory.</p><p>Bitmapped modes (modes 8 - F) have cycles stolen corresponding to the number of bytes per line used in that mode. For example, mode E will use an additional 40 cycles, so in the context of writing a DLI for a game, the typical number of stolen cycles could be 57 out of the 114 cycles per scan line: 17 cycles for ANTIC overhead and 40 for the number of bytes per line.</p><p>Text modes require additional cycles over bitmapped graphics modes, because ANTIC must fetch the font glyphs in addition to its other work. The first scan line of a font mode is almost entirely used by ANTIC and only a small number of cycles is available to the 6502. For normal 40-byte wide playfields, the first line of ANTIC modes 2 through 5 will yield at most about 30 cycles and subsequent lines about 60 cycles per scan line.</p><p>About the worst-case scenario is one of the best modes for games: ANTIC mode 4. This text mode, combined with scrolling and player/missile graphics and can reduce the available cycles to fewer than 10 on the first line and about 50 on subsequent lines!</p><h2 id=a-crash-course-on-display-list-interrupts>A Crash Course on Display List Interrupts</h2><p>DLIs are non-maskable interrupts (NMIs), meaning they cannot be ignored. When an NMI occurs, the 6502 jumps to the address stored at <code>$fffa</code>, which points to an OS routine that checks the type of interrupt (either a DLI or a VBI) and vectors through the appropriate user vector. The NMI handler takes care of saving the processor status register and sets the interrupt flag, but <em>does not</em> save any processor registers. The user routine is responsible for saving any registers that it uses, restoring them when it is done using them, and must exit using the <code>RTI</code> instruction.</p><p>Display list interrupts are not enabled by default. To use a DLI, the address vector at <code>VDLSLT</code> (<code>$200</code> and <code>$201</code>) must be set to your routine, and then they must be enabled through a write to <code>NMIEN</code> at <code>$d40e</code>.</p><p>Warning</p><p>You must set the address of your DLI before enabling them, otherwise the DLI could be called and use whatever address is stored at <code>$200</code>.</p><p>This initialization code can look like the following, where the constants <code>NMIEN_VBI</code> and <code>NMIEN_DLI</code> are defined as <code>$40</code> and <code>$80</code>, respectively, in hardware.s in the sample repository. Since <code>NMIEN</code> also controls the vertical blank interrupt, you must make sure that the VBI enable flag is also set.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>; load display list interrupt address lda #&lt;dli sta VDSLST lda #\&gt;dli sta VDSLST+1 ; activate display list interrupt and vertical blank interrupt lda #NMIEN\_DLI | NMIEN\_VBI sta NMIEN 
</span></span></code></pre></td></tr></table></div></div><p>If your program has multiple DLIs, it may be necessary to set your DLIs in a vertical blank interrupt to guarantee that ANTIC will process them in the right order. Outside the VBI, your code could be running at an arbitrary scan line, perhaps between display list instructions that have their DLI bits set. In Yaron Nir‚Äôs tutorial a different technique is used, one not requiring a vertical blank interrupt but instead using the <code>RTCLOK</code> 3-byte zero page variable to instead infer that a VBI has <em>just</em> occurred. The last of the bytes, location <code>$14</code>, is incremented every vertical blank, so that technique is to wait until location <code>$14</code> changes, then set <code>NMIEN</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> lda RTCLOK+2 ?loop cmp RTCLOK+2 ; will be equal until incremented in VB beq ?loop ; activate display list interrupt and vertical blank interrupt lda #NMIEN\_DLI | NMIEN\_VBI sta NMIEN 
</span></span></code></pre></td></tr></table></div></div><h3 id=hardware--shadow-registers>Hardware & Shadow Registers</h3><p>The Atari is a memory-mapped system, where hardware devices like the ANTIC and GTIA chips are <em>mapped</em> to locations in memory and data is passed back and forth by reading or writing to specific addresses. They are usually either read-only or write-only, and many times an address is used for wildly different features depending on whether the address is read from or written to.</p><p>Some of these hardware locations also have <em>shadow</em> registers in low RAM (typically page 2) that are labeled as performing the same function as a hardware register, with two important differences.</p><p>First, they can be both read and written to, so (assuming you always use the shadow register to update the hardware register) it is possible to find out the current state of a hardware register by reading its shadow.</p><p>Second, the hardware register is only updated <strong>once every vertical blank</strong> by an operating system routine that copies the shadow value to its hardware counterpart. Note that it does not happen the other way around, so changing a hardware register <em>does not</em> update a shadow register.</p><p>The shadow registers are a convenience for development in higher level languages like BASIC where speed is not paramount. But code within a DLI must use hardware registers directly to affect change on a scan line.</p><p>The shadow registers can still be useful in DLI development, in that they will automatically reset the hardware registers to the values in the shadow registers every vertical blank. This can be used to reset features like graphics colors and the character set address for the top of the screen at the next frame.</p><p>Note</p><p>This only works if the operating system‚Äôs immediate vertical blank routine has not been replaced (i.e. you are only using the deferred vertical blank <code>VVBLKD</code> at <code>$224</code> and haven‚Äôt replaced the immediate vertical blank rountine <code>VVBLKI</code> at <code>$222</code>).</p><p>Some hardware registers have no shadows, like player position and size, so your own code (in the deferred VBI or the final DLI) must reset these to their correct values for the top of the screen.</p><p>Some Useful Shadow Registers</p><p>Shadow</p><p>Hex</p><p>Hardware</p><p>Hex</p><p>Description</p><p>GPRIOR</p><p>26f</p><p>PRIOR</p><p>d01b</p><p>Player/playfield priority selection register</p><p>PCOLR0</p><p>2c0</p><p>COLPM0</p><p>d012</p><p>Color of player/missile 0</p><p>PCOLR1</p><p>2c1</p><p>COLPM1</p><p>d013</p><p>Color of player/missile 1</p><p>PCOLR2</p><p>2c2</p><p>COLPM2</p><p>d014</p><p>Color of player/missile 2</p><p>PCOLR3</p><p>2c3</p><p>COLPM3</p><p>d015</p><p>Color of player/missile 3</p><p>COLOR0</p><p>2c4</p><p>COLPF0</p><p>d016</p><p>Color of playfield 0</p><p>COLOR1</p><p>2c5</p><p>COLPF1</p><p>d017</p><p>Color of playfield 1</p><p>COLOR2</p><p>2c6</p><p>COLPF2</p><p>d018</p><p>Color of playfield 2</p><p>COLOR3</p><p>2c7</p><p>COLPF3</p><p>d019</p><p>Color of playfield 3</p><p>COLOR4</p><p>2c8</p><p>COLBK</p><p>d01a</p><p>Background color</p><p>CHACT</p><p>2f3</p><p>CHACTL</p><p>d401</p><p>Character mode (inverse, upside-down characters)</p><p>CHBAS</p><p>2f4</p><p>CHBASE</p><p>d409</p><p>Character base (page number of font)</p><h3 id=a-simple-example>A Simple Example</h3><p>A common use of display lists is to change colors in the middle of the screen.</p><p>Here is our first display list interrupt:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>dli pha ; only using A register, so save old value to the stack lda #$7a ; new background color sta COLBK ; store it in the hardware register pla ; restore the A register rti ; always end DLI with RTI! 
</span></span></code></pre></td></tr></table></div></div><p>This is all the code it takes to change the color of the background. The obvious effect is the flickering line in the background, which we will solve in the next section.</p><p>Examining the code shows the boilerplate discussed <a class=link href=https://playermissile.com/dli_tutorial/#a-crash-course-on-display-list-interrupts target=_blank rel=noopener>above</a> where DLIs always end with the <code>RTI</code> instruction and any registers used must be saved before your code changes them, and restored upon exit.</p><p>The work performed in the interrupt is just two instructions: a load of a color value and a store where it puts it in the <em>hardware</em> register for the background color. Again, as noted <a class=link href=https://playermissile.com/dli_tutorial/#hardware-shadow-registers target=_blank rel=noopener>above</a>, hardware registers must be used in DLIs, not the shadow registers as shadow registers are ignored until the vertical blank.</p><h3 id=a-simple-example-with-wsync>A Simple Example with WSYNC</h3><p>The Atari provides a way to sync with a scan line to avoid the flickering effect of the previous example.</p><p>The flickering is avoided by saving some value (any value, the bit pattern is not important) to the <code>WSYNC</code> memory location at <code>$d40a</code>. This causes the 6502 to stop processing instructions until the electron beam nears the end of the scan line, at which point the 6502 will resume executing instructions. Because the electron beam is usually off-screen at this point, it is safe to change color registers for at least the next several instructions without artifacts appearing on screen.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>dli pha ; only using A register, so save old value to the stack lda #$7a ; new background color sta WSYNC ; any value saved to WSYNC will trigger the pause sta COLBK ; store it in the hardware register pla ; restore the A register rti ; always end DLI with RTI! 
</span></span></code></pre></td></tr></table></div></div><p>Note</p><p><code>WSYNC</code> (wait for horizontal blank) usually restarts the 6502 on or about cycle 105 out of 114, but there are cases that can delay that. See the Altirra Hardware Reference Manual for more information.</p><h3 id=a-dli-can-affect-many-scan-lines>A DLI Can Affect Many Scan Lines</h3><p>DLIs can really be thought of as a way for your program to be told when a certain display list instruction is reached. Apart from the setup and teardown of the DLI subroutine itself and some timing limitations discussed in the next section, arbitrary amounts of code can be executed in a DLI.</p><p>Note</p><p>Author‚Äôs note: thinking that DLIs had to be short was a great source of confusion to me when trying to figure out how rainbow effects were generated. My thinking was that DLIs could only affect a single line, and for instance I could not figure out how to get a color change in the middle of a text mode. I don‚Äôt know why I thought that something bad would happen if a DLI went long, but I did.</p><p>This example shows how to have a single DLI affect multiple scan lines, even crossing into subsequent ANTIC mode 4 lines in the display list:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>dli pha ; save A &amp; X registers to stack txa pha ldx #16 ; make 16 color changes lda #$a ; initial color sta WSYNC ; first WSYNC gets us to start of scan line we want ?loop sta COLBK ; change background color clc adc #$11 ; change color value, luminance remains the same dex ; update iteration count sta WSYNC ; make it the color change last ... sta WSYNC ; for two scan lines bne ?loop ; sta doesn&#39;t affect flags so this still checks result of dex lda #$00 ; reset background color to black sta COLBK pla ; restore X &amp; A registers from stack tax pla rti ; always end DLI with RTI! 
</span></span></code></pre></td></tr></table></div></div><p>It changes background colors 16 times, where each color change lasts 2 scan lines. So 32 scan lines means that it covers 4 display list entries of ANTIC mode 4.</p><h2 id=a-crash-course-on-display-list-interrupts-getting-interrupted>A Crash Course on Display List Interrupts Getting Interrupted</h2><blockquote><ul><li><p>DLIs can be interrupted by other DLIs</p></li><li><p>DLIs can be interrupted by the vertical blank</p></li><li><p>a DLI on a JVB instruction will cause interrupts on every scan line until the vertical blank</p></li></ul></blockquote><h3 id=dli-interrupting-another-dli>DLI Interrupting Another DLI</h3><p>When a DLI is interrupted, its state is saved just as if a normal program was interrupted. The interrupting code is then executed, and upon its completion, the control returns to the DLI at the point where it left off. But at this point, due to the interrupting event, the restored DLI will be resumed some number of scan lines below where it was interrupted, likely resulting in unplanned behavior.</p><p>Here‚Äôs a similar DLI to the above, except it changes the luminance value instead of the color value to make the effect easier to see. It starts with a bright pink and gets dimmer down to a dark red after 32 scan lines:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>dli pha ; save A &amp; X registers to stack txa pha ldx #16 ; make 16 color changes lda #$5f ; initial bright pink color sta WSYNC ; first WSYNC gets us to start of scan line we want ?loop sta COLBK ; change background color sec sbc #1 ; make dimmer by decrementing luminance value dex ; update iteration count sta WSYNC ; make it the color change last ... sta WSYNC ; for two scan lines bne ?loop ; sta doesn&#39;t affect processor flags so we are still checking result of dex lda #$00 ; reset background color to black sta COLBK pla ; restore X &amp; A registers from stack tax pla rti ; always end DLI with RTI! 
</span></span></code></pre></td></tr></table></div></div><p>But this time, the display list has <em>two</em> lines that have the DLI bit set:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>dlist .byte $70,$70,$70 .byte $44,$00,$40 .byte $c4 ; first DLI triggered on last scan line .byte $44 .byte $c4 ; second DLI triggered on last scan line .byte $44,$44,$44,$44,$44,$44,$44,$44 .byte $44,$44,$44,$44,$44,$44,$44,$44 .byte $44,$44,$44,$44 .byte $41,&lt;dlist,\&gt;dlist 
</span></span></code></pre></td></tr></table></div></div><p>Because the <code>VDLSTL</code> pointer is not changed, the same code will be called each time an interrupt occurs.</p><p>The first DLI hits and starts with a bright background color on the first scan line of the third line of text. But because this display list takes a long time, the second DLI on the 4th text line gets triggered before the first DLI has hit its <code>RTI</code> instruction. ANTIC interrupts the first DLI and starts the 2nd DLI anyway. This effect is visible in the 5th line of text: the background color is bright again.</p><p>But notice another artifact: the effect on the 5th line of text isn‚Äôt on its first scan line, but its second:</p><p>This is due to the fact that a WSYNC was called on the previous scan line, but the interrupt happened as well. The interrupt takes some cycles to begin, and by the time that happened <strong>and</strong> ANTIC stole all of its cycles to set up the text mode line, there weren‚Äôt enough cycles left for the first <code>WSYNC</code> in the DLI code to happen on the same scan line. This forces that <code>WSYNC</code> to happen on the next line, causing the delay and the appearance of a 3rd scan line of the same color before the second DLI starts its color cycling.</p><p>The second DLI completes and performs its <code>RTI</code>, but then it returns control to the first DLI, which is already halfway done with its color cycling. When it resumes control, it is in 9th line of text on the screen, so it has four more color changes before it hits its own <code>RTI</code>.</p><h3 id=emulator-differences>Emulator Differences</h3><p>The DLI interrupting another DLI is clearly an edge case, and edge cases are always good stress tests for emulators. A difference is clearly visible below when comparing a zoomed in portion of the display generated by the Altirra emulator as compared to the atari800 emulator (standalone or as embedded in Omnivore, they are the same code and produce the same result):</p><p><img src=https://playermissile.com/_images/emulator-differences.png loading=lazy alt=../_images/emulator-differences.png></p><p>Notice how Altirra gets the color from the first DLI for two scan lines, 64 and 65, before the correct color appears on scan line 66. The output from Altirra shows that the NMI doesn‚Äôt happen until between scan line 63 and 64. But clearly, the <code>sta COLBK</code> at scan line 63 is taking effect on scan line 64, because scan line 64 has the background color <code>$57</code>. It appears the store of <code>$5f</code> on scan line 65, started on cycle 1 of that line, isn‚Äôt actually executed until much, much later since the <code>sec</code> doesn‚Äôt begin until cycle 108. This puts that color change in the horizontal blank period of scan line 65, which would seem to explain why Altirra shows two scan lines with the background color from the first DLI.</p><p>This is the CPU history from the Altirra emulator:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> 60: 3 | A=58 X=09 Y=00 ( I C) | 3030: 8D 0A D4 STA WSYNC 60: 7 | A=58 X=09 Y=00 ( I C) | 3033: 8D 0A D4 STA WSYNC 60:108 | A=58 X=09 Y=00 ( I C) | 3036: D0 F1 BNE $3029 61:107 | A=58 X=09 Y=00 ( I C) | 3029: 8D 1A D0 L3029 STA COLBK 61:111 | A=58 X=09 Y=00 ( I C) | 302C: 38 SEC 61:113 | A=58 X=09 Y=00 ( I C) | 302D: E9 01 SBC #$01 62: 1 | A=57 X=09 Y=00 ( I C) | 302F: CA DEX 62: 3 | A=57 X=08 Y=00 ( I C) | 3030: 8D 0A D4 STA WSYNC 62: 7 | A=57 X=08 Y=00 ( I C) | 3033: 8D 0A D4 STA WSYNC 62:108 | A=57 X=08 Y=00 ( I C) | 3036: D0 F1 BNE $3029 63:107 | A=57 X=08 Y=00 ( I C) | 3029: 8D 1A D0 L3029 STA COLBK - NMI interrupt (DLI) 64: 5 | A=57 X=08 Y=00 ( I C) | E791: 2C 0F D4 LE791 BIT NMIST 64: 11 | A=57 X=08 Y=00 (N I C) | E794: 10 03 BPL $E799 64: 13 | A=57 X=08 Y=00 (N I C) | E796: 6C 00 02 JMP (VDSLST) 64: 19 | A=57 X=08 Y=00 (N I C) | 301F: 48 PHA 64:102 | A=57 X=08 Y=00 (N I C) | 3020: 8A TXA 64:104 | A=08 X=08 Y=00 ( I C) | 3021: 48 PHA 64:107 | A=08 X=08 Y=00 ( I C) | 3022: A2 10 LDX #$10 64:109 | A=08 X=10 Y=00 ( I C) | 3024: A9 5F LDA #$5F 64:111 | A=5F X=10 Y=00 ( I C) | 3026: 8D 0A D4 STA WSYNC 65: 1 | A=5F X=10 Y=00 ( I C) | 3029: 8D 1A D0 L3029 STA COLBK 65:108 | A=5F X=10 Y=00 ( I C) | 302C: 38 SEC 65:110 | A=5F X=10 Y=00 ( I C) | 302D: E9 01 SBC #$01 65:112 | A=5E X=10 Y=00 ( I C) | 302F: CA DEX 66: 0 | A=5E X=0F Y=00 ( I C) | 3030: 8D 0A D4 STA WSYNC 66: 4 | A=5E X=0F Y=00 ( I C) | 3033: 8D 0A D4 STA WSYNC 66:108 | A=5E X=0F Y=00 ( I C) | 3036: D0 F1 BNE $3029 67:107 | A=5E X=0F Y=00 ( I C) | 3029: 8D 1A D0 L3029 STA COLBK 
</span></span></code></pre></td></tr></table></div></div><p>The atari800 emulator hits the DLI two instructions earlier than Altirra, immediately after the two <code>sta WSYNC</code> commands (and therefore before the <code>sta COLBK</code> that causes Altirra to have a new color on scan line 64). In the atari800/Omnivore instruction history below:</p><p>the DLI starts late on scan line 63 as (naively) expected and gets to the <code>sta WSYNC</code> early in scan line 64 while there is still time to hit the <code>sta COLBK</code> while still on scan line 64. This changes scan line 65 to be the correct background color for the second DLI.</p><p>Note</p><p>I‚Äôm not sure what‚Äôs going on with the differences in the WSYNC behavior between the two emulators. On Altirra, the two WSYNC commands seem to occur on scan line 62, but their effects aren‚Äôt felt immediately, so perhaps this is what‚Äôs causing the DLI to hit on scan line 64 instead of scan line 63. On atari800, the WSYNC commands cause their effects to be felt immediately, in the next command. I would presume that Altirra is closer to what‚Äôs going on with real hardware, as the author of Altirra has written the definitive guide to the internals of the machine, and Altirra has always been the leader in cycle-exact emulation.</p><p>I think the takeaway from this section is: don‚Äôt let your DLI get interrupted by anything else, or it is likely that you will encounter emulation differences.</p><h3 id=vbi-interrupting-a-dli>VBI Interrupting A DLI</h3><p>For completeness, here is an example of the vertical blank interrupting a DLI.</p><p>The DLI is started at the bottom of the screen, gets interrupted by the VBI, and picks up again when VBI ends. Even though the electron beam is turned off, <code>WSYNC</code> is still called and performs its delay function when the scan line is off screen. The resulting image resumes its color cycling background on the top of the screen, stopping after 128 scan lines even though only a fraction of those are actually visible on screen.</p><h3 id=dli-on-the-jvb-instruction>DLI on the JVB Instruction</h3><p>A DLI on the JVB instruction at the end of the display list is possible, but has an interesting property: it triggers DLIs on every scan line until the vertical blank.</p><p>If your DLI is not short enough, it will keep getting interrupted by the DLI on triggered by the next scan line, stacking up interrupts until mercifully the triggering process is stopped by the vertical blank after 248 scan lines have been generated.</p><p>Note</p><p>As each new frame is generated in an emulator, it will enumerate the scan lines starting from zero. There are 248 scan lines before the vertical blank, which will be displayed as scan lines 0 - 247. The scan line labeled 248 will be the first scan line of the vertical blank.</p><p>After the vertical blank routine exits, the stacked-up DLI calls will have to unwind themselves so the most recently interrupted DLI (from scan line 247, the scan line just before the vertical blank) will resume and execute code until its <code>RTI</code>. This will pop data off the stack and return control to the DLI that was interrupted on scan line 246, and so-forth until all the interrupted DLIs have issued their <code>RTI</code> instructions.</p><p>On a standard length display list that generates 24 blank lines followed by 192 output lines, the JVB instruction will be on scan line 224. Since the JVB technically generates a single blank line in the display list, the DLI will also be triggered on scan line 224. This case would produce 24 DLIs before the vertical blank.</p><h2 id=dlis-in-a-nutshell>DLIs in a Nutshell</h2><p>DLIs provide you with a way to notify your program at a particular vertical location on the screen. They pause (or interrupt) the normal flow of program code, save the state of the machine, call your DLI subroutine, and restore the state of the computer before returning control to the code that was interrupted.</p><p>Warning</p><p>Here are the requirements for successful use of DLIs:</p><ul><li><p>your DLI routine must save any registers it clobbers</p></li><li><p>restore any registers you save before exiting</p></li><li><p>exit with an <code>RTI</code></p></li><li><p>use <code>WSYNC</code> if necessary</p></li><li><p>be aware of cycles stolen by ANTIC: you could have only 60 cycles per scan line in higher resolution graphics modes, and as few as 10 (<strong>!</strong>) on the first line of text modes</p></li><li><p>store the address of your routine in <code>VDSLST</code> before enabling DLIs with <code>NMIEN</code></p></li><li><p>guard against the DLI itself being interrupted</p></li></ul><p>Note that nowhere in that list was the requirement that the DLI be short. It doesn‚Äôt have to be, and in fact DLIs that span multiple scan lines are similar to kernels used in Atari 2600 programming. The difference is that ANTIC steals cycles depending on a bunch of factors, so the total cycle counting approach (or <a class=link href=https://mitpress.mit.edu/books/racing-beam target=_blank rel=noopener>Racing the Beam</a>) is usually not possible.</p><p>However, most DLIs that you will run across in the wild <em>are</em> short, because they typically don‚Äôt do a lot of calculations. Most of the setup work will generally be done outside of the DLI and the DLI itself just handles the result of that work.</p><p><img src=https://playermissile.com/_static/Atari_logo_hr.png loading=lazy></p><h2 id=advanced-dli-examples>Advanced DLI Examples</h2><p>The following examples are available in both source code form and as XEX files at the <a class=link href=https://github.com/playermissile/dli_tutorial target=_blank rel=noopener>dli_tutorial source code repository</a> on github.</p><p>They are coded using MAC/65 assembler syntax, but very few assembler-specific features are actually used, so they should be trivially ported to other assemblers.</p><p>To get a copy of all the examples and source code, you can download and install <a class=link href=https://git-scm.com/ target=_blank rel=noopener>git</a> for your platform. Then open a command line prompt on your computer and enter the command: <code>git clone https://github.com/playermissile/dli_tutorial.git</code> to download the complete repository.</p><p>You can also download individual assembly source and XEX files from links in each section.</p><p>In an attempt to de-clutter the examples as much as possible, most of the boilerplate code (for initialization and setup tasks) has been placed in libraries that are included during the compilation process. These are files like <code>util.s</code>, <code>util_dli.s</code> and so forth, and are available in the source code repository or directly <a class=link href=https://github.com/playermissile/dli_tutorial/src target=_blank rel=noopener>here</a>.</p><h2 id=1-multiple-dlis>#1: Multiple DLIs</h2><p>One of the problems with having a single DLI vector is: what do you do when you want to have more than one DLI?</p><p>Some techniques that you will see in the wild:</p><blockquote><ul><li><p>use <code>VCOUNT</code> to check where you are on screen and branch accordingly</p></li><li><p>increment an index value and use that to determine which DLI has been called</p></li><li><p>change the <code>VDLSTL</code> vector to point to the next DLI in the chain</p></li></ul></blockquote><p>Here‚Äôs an optimization of the last technique that can save some valuable cycles: put your DLIs in the same page of memory and only change the low byte.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> \*= (\* &amp; $ff00) + 256 ; next page boundary dli pha ; only using A register, so save it to the stack lda #$55 ; new background color sta WSYNC ; first WSYNC gets us to start of scan line we want sta COLBK ; change background color lda #&lt;dli2 ; point to second DLI sta VDSLST pla ; restore A register from stack rti ; always end DLI with RTI! dli2 pha ; only using A register, so save it to the stack lda #$88 ; new background color sta WSYNC ; first WSYNC gets us to start of scan line we want sta COLBK ; change background color pla ; restore A register from stack rti ; always end DLI with RTI! vbi lda #&lt;dli ; set DLI pointer to first in chain sta VDSLST lda #\&gt;dli sta VDSLST+1 jmp XITVBV ; always exit deferred VBI with jump here 
</span></span></code></pre></td></tr></table></div></div><p>This is a simplistic example, but keeping the high byte constant inside the DLI saves 6 cycles (by obviating the need for changing the high byte with <code>LDA #>dli2; STA VDLSTL+1</code>). That may be enough for this optimization to be useful.</p><h2 id=2-moving-the-dli-up-and-down-the-screen>#2: Moving the DLI Up and Down the Screen</h2><p>The DLI subroutine itself doesn‚Äôt directly know what scan line caused the interrupt because all DLIs are routed through the same vector at <code>VDLSTL</code>. The only trigger is in the display list: the DLI bit on the display list instruction.</p><p>The display list can be modified in place to move the DLI to different lines without changing any DLI code. The code to move the DLI should be performed in the vertical blank to prevent the display list from being modified as ANTIC is using it to create the display:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>move\_dli\_line ldx last\_dli\_line ; get line number on screen of old DLI lda dlist\_line\_lookup,x ; get offset into display list of that line number tax lda dlist\_first,x ; remove DLI bit and #$7f sta dlist\_first,x ldx dli\_line ; get line number on screen of new DLI stx last\_dli\_line ; remember lda dlist\_line\_lookup,x ; get offset into display list of that line number tax lda dlist\_first,x ; set DLI bit ora #$80 sta dlist\_first,x rts 
</span></span></code></pre></td></tr></table></div></div><p>The example allows the display list to be set on blank lines at the top of the display, and on the last mode 4 line in the display list which displays the background below the last mode 4 line on the screen.</p><h2 id=interlude-a-playermissile-graphics-refresher>Interlude: A Player/Missile Graphics Refresher</h2><p>Player/Missile Graphics is the sprite system provided by the GTIA: independently positioned overlays on the playfield graphics that don‚Äôt disturb the playfield.</p><p>Note</p><p>the word <em>sprite</em> in this sense wasn‚Äôt in use when the Atari was designed, and <a class=link href=https://graphics.fandom.com/wiki/Sprite target=_blank rel=noopener>several</a> <a class=link href=https://en.wikipedia.org/wiki/Sprite_%28computer_graphics%29 target=_blank rel=noopener>sources</a> <a class=link href=http://groups.google.com/group/comp.sys.ti/msg/73e2451bcae4d91a target=_blank rel=noopener>claim</a> that it was coined by the designers of the Texas Instruments TI 9918 graphics chip at about the same timeframe.</p><p>The GTIA provides 4 players with independent colors (from each other or the playfield) and 4 missiles with colors matching their respective player, or the 4 missiles can be combined into a 5th player with its own color (although this reuses one playfield color). The players are 8 bits wide and can be displayed as one, two, or four color clocks wide per bit. This corresponds a width on screen of 8, 16, and 32 color clocks, respectively. Widths for all players and missiles can be set independently.</p><p>Each player and missile can be positioned at an arbitrary horizontal location by setting a hardware register, but vertical positioning requires copying data to particular locations in the memory area reserved for it. Each player spans the height of the screen, and it is only the bit pattern in its storage area that determines what is drawn on a particular scan line.</p><p>Missiles are two bits wide each with all 4 missiles packed into a single byte for a particular scan line. Bit masking is required to set data for one missile without affecting the others.</p><p>The quick summary for our purposes is that horizontal repositioning of players is fast, it takes only a single store instruction. Vertical repositioning of player image data is slow, it requires copying memory around.</p><h2 id=3-multiplexing-players-vertically>#3: Multiplexing Players Vertically</h2><p>Reusing players (multiplexing) vertically is straightforward, meaning that a single player can be used to display arbitrary images at different vertical locations on the screen, provided that there is no vertical overlap.</p><p>Using the hardware <code>HPOSPn</code> or <code>HPOSMn</code> registers, the DLI will immediately change where ANTIC will draw the player or missile. The next time ANTIC draws the player on a scan line, it will use this new position.</p><p>in the appropriate player or missile X position register. This demo uses the page-alignment trick for the second DLI, and changes the position and size of the players at each interrupt.</p><p>This demo splits the screen vertically into 3 horizontal bands, A, B & C, with the players extending the full height of the screen and labeled 0 through 3. This example uses the VBI to set the players for band A, the <code>dli</code> routine is the bottom of band A (and the top of band B) and therefore sets the players for band B, and the <code>dli2</code> routine is the bottom of band B (and the top of band C) and controls the players for band C.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vbi lda #&lt;dli ; set DLI pointer to first in chain sta VDSLST lda #\&gt;dli sta VDSLST+1 lda #$40 ; set player positions and sizes ... sta HPOSP0 ; for the top of the screen lda #$60 sta HPOSP1 lda #$80 sta HPOSP2 lda #$a0 sta HPOSP3 lda #0 sta SIZEP0 sta SIZEP1 sta SIZEP2 sta SIZEP3 jmp XITVBV ; always exit deferred VBI with jump here \*= (\* &amp; $ff00) + 256 ; next page boundary dli pha ; only using A register, so save it to the stack lda #$55 ; new background color sta WSYNC ; first WSYNC gets us to start of scan line we want sta COLBK ; change background color lda #$30 ; change position and sizes of players sta HPOSP0 lda #$40 sta HPOSP1 lda #$50 sta HPOSP2 lda #$60 sta HPOSP3 lda #1 sta SIZEP0 sta SIZEP1 sta SIZEP2 sta SIZEP3 lda #&lt;dli2 ; point to second DLI sta VDSLST pla ; restore A register from stack rti ; always end DLI with RTI! dli2 pha ; only using A register, so save it to the stack lda #$84 ; new background color sta WSYNC ; first WSYNC gets us to start of scan line we want sta COLBK ; change background color lda #$40 ; change position and sizes of players sta HPOSP0 lda #$70 sta HPOSP1 lda #$90 sta HPOSP2 lda #$b0 sta HPOSP3 lda #3 sta SIZEP0 sta SIZEP1 sta SIZEP2 sta SIZEP3 pla ; restore A register from stack rti ; always end DLI with RTI! 
</span></span></code></pre></td></tr></table></div></div><p>In discussing the timing issues that cause errors at the band boundaries, the players in band A are positioned by the VBI, and so are in place from well off the top of the screen and are correctly positioned at the first scan line. Players 0, 1, and 2 are correct at the bottom of the band, but player 3 extends one scan line too far, into band B.</p><p>The top of band B shows both position and size errors. When the first DLI hits on the last scan line of the 6th line of text, the background color is changed at the <code>WSYNC</code> and ANTIC moves on to start drawing the first scan line of the 7th line of text (which is the first line of text in band B.) Players 0, 1, and 2 are positioned correctly, which means their horizontal positions were set before ANTIC reached that portion of the scan line. The 3rd player remains in the same position as it was in band A, meaning that its horizontal position wasn‚Äôt set in time. ANTIC had stolen enough cycles setting up the mode 4 font that the 6502 didn‚Äôt get a chance to process the <code>sta HPOS3</code> before ANTIC had to draw that portion of the scan line. Since the code sets sizes after the horizontal positions, none of the sizes are set until the 2nd scan line of band B.</p><p>The transition to band C with the <code>dli2</code> routine produces similar results, there just isn‚Äôt enough time with the <code>WSYNC</code> used for the color change <em>and</em> all the cycles stolen by ANTIC mode 4 to process the all of the player changes in the first scan line of the band. Players 0, 1, and 2 are moved, player 3 is not, and all 4 players don‚Äôt get the correct size until the 2nd scan line of the band.</p><p>It‚Äôs possible to imagine a scenario where a scan line of a player is not visible at all. For example, if player 3 above had been positioned very far to the right and <code>HPOSP3</code> was changed to move player 3 to the far left side, it could be possible that ANTIC has already drawn the left side of the screen but hadn‚Äôt yet reached the right side where player 3 had been positioned. Because <code>HPOSP3</code> is now showing that player 3 is on the left side of the screen, ANTIC would not draw it at its old location on the right side of the screen.</p><p>It‚Äôs also possible, with careful timing, to reuse a player on a single line. However, purposeful use of this would difficult given all the different horizontal locations of ANTIC‚Äôs cycle stealing.</p><p>Mode 4 was chosen (in all of its cycle-stealing glory) for these examples to get an idea of the worst-case scenerio. Taking out the <code>WSYNC</code> and the color change did allow enough time that both the positions and sizes were changed without visible artifacts:</p><p>but this is very simple code and the more real-world example in the next section will show that a buffer zone of several scan lines is necessary to make sure a player isn‚Äôt split across a band boundary or, as described above, even duplicating a line of the player or missing a scan line.</p><h2 id=4-multiplexing-with-horizontal-motion>#4: Multiplexing With Horizontal Motion</h2><p>Increasing the number of bands and adding independent player movement within each band requires some data structures and a DLI to control placement in each band.</p><p>The approach used in this example is to use a single DLI that uses an index value to determine which band it is operating within. This index value is used as an offset into arrays that hold the sprite X position, size, color, etc.</p><p>There are a lot of independently moving objects in this demo: 12 bands, each with 4 players. There are very obvious timing issues in most bands on the first scan line after the DLI as sometimes the hardware registers for a player hasn‚Äôt been updated fully until the second scan line.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>; same DLI routine is used for each band, the band\_dli\_index is used to set ; player information for the appropriate band dli\_band pha ; using A &amp; X txa pha inc band\_dli\_index ; increment band index, VBI initialized to $ff, ldx band\_dli\_index ; so will become 0 for band A ; control band X positions of players lda bandp0\_x,x ; x position of player 0 in this band sta HPOSP0 lda bandp0\_color,x ; color of player 0 for this band sta COLPM0 lda bandp0\_size,x ; size of player 0 for this band sta SIZEP0 lda bandp1\_x,x ; as above, but for players 1 - 3 sta HPOSP1 lda bandp1\_color,x sta COLPM1 lda bandp1\_size,x sta SIZEP1 lda bandp2\_x,x sta HPOSP2 lda bandp2\_color,x sta COLPM2 lda bandp2\_size,x sta SIZEP2 lda bandp3\_x,x sta HPOSP3 lda bandp3\_color,x sta COLPM3 lda bandp3\_size,x sta SIZEP3 ?done pla ; restore A &amp; X tax pla rti ; always end DLI with RTI! 
</span></span></code></pre></td></tr></table></div></div><p>The addreses <code>bandpN_x</code>, <code>bandpN_color</code>, and <code>bandpN_size</code> (where N is the player number) are declared as lists with the number of entries equal to the number of bands. <code>band_dli_index</code> is incremented each time the DLI starts, and uses that index into the lists so it places the players in the correct location for that band.</p><p>Notice that is <em>all</em> the DLI does. It does not calculate movement or perform any player logic, it simply puts players on the screen in the appropriate place for that band. All the calculation is done in the vertical blank:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>; calculate new positions of players in all bands vbi ldx #0 ?move lda bandp0\_x,x ; update X coordinate clc ; by adding velocity. adc bandp0\_dx,x ; Note that velocity of $ff sta bandp0\_x,x ; is same as -1 cmp #$30 ; check left edge bcs ?right ; if &gt;=, it is still in playfield lda #1 ; nope, &lt;, so make velocity positive sta bandp0\_dx,x bne ?cont ?right cmp #$c0 ; check right edge bcc ?cont ; if &lt;, it is still in playfield lda #$ff ; nope, &gt;=, so make velocity negative sta bandp0\_dx,x ?cont inx ; next player cpx #num\_dli\_bands \* 4 ; loop through 12 bands \* 4 players each bcc ?move lda #$ff ; initialize band index to get ready for band A sta band\_dli\_index jmp XITVBV ; always exit deferred VBI with jump here 
</span></span></code></pre></td></tr></table></div></div><p>Unlike the simple multiplexing demo in the previous section, this VBI does not set any positions of players. Instead, this demo sets the DLI bit on the last group of 8 blank lines at the beginning of the display list, before any mode 4 lines. This initial DLI will set the players for band A, and as you can see in the demo the players above band A use the same X position and size as band L. The colors are not the same as band L, however, because of the use of the shadow registers to set the initial color in the <code>init_pmg</code> subroutine.</p><h2 id=n-multiplexing-with-arbitrary-motion>#n: Multiplexing with Arbitrary Motion</h2><p>Vertical movement within bands requires the moving memory around the player/missile graphics area (pointed to by <code>PMBASE</code>) as in normal usage, with the following limitations:</p><blockquote><ul><li><p>players must stay within their assigned band, otherwise they will get split across bands when the DLI occurs.</p></li><li><p>players should avoid the first few scan lines below the top of the band boundary to prevent splitting</p></li><li><p>when moving a player vertically within a band, only erase data from that band to prevent affecting the multiplexed players in other bands</p></li></ul></blockquote><h2 id=n-multiplexing-with-collision-detection>#n: Multiplexing With Collision Detection</h2><p>If it is important to tell in which band a has collided occurred, the DLI that starts a new band will be required to save the collision status registers, which will determine if a collision happened in the <em>previous</em> band. It will then reset the collision registers so the following DLI can check what happened in this band.</p><p>If the knowledge of the band is not important, you can just check the collision registers in the vertical blank, which will report if there have been any collisions with anything in any band.</p><h2 id=n-multiplexing-players-horizontally>#n: Multiplexing Players Horizontally</h2><p>Reusing players on the same scan line is possible, but its usefulness may be limited to mostly static cases.</p><p>from Hacker News <a class=link href=https://ift.tt/361GQA7 target=_blank rel=noopener>https://ift.tt/361GQA7</a></p></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><footer class=site-footer><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3987358164777632" crossorigin=anonymous></script>
<script data-name=BMC-Widget src=https://cdn.buymeacoffee.com/widget/1.0.0/prod/widget.prod.min.js data-id=0x000216 data-description=coffee! data-message=coffee! data-color=#FF813F data-position=right data-x_margin=28 data-y_margin=18></script></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#a-crash-course-on-displays>A Crash Course on Displays</a><ol><li><a href=#how-interlacing-works-with-some-hand-waving-and-why-we-ignore-it>How Interlacing Works (With Some Hand Waving) and Why We Ignore It</a></li><li><a href=#how-color-works-and-theres-more-hand-waving-isnt-there>How Color Works and There‚Äôs More Hand Waving, Isn‚Äôt There?</a></li><li><a href=#how-the-cpu-frequency-was-chosen-and-why-is-there-even-more-hand-waving-oh-author-person>How The CPU Frequency Was Chosen and Why Is There Even More Hand Waving, Oh Author Person?</a></li></ol></li><li><a href=#a-crash-course-on-display-lists>A Crash Course on Display Lists</a><ol><li><a href=#display-list-instruction-set>Display List Instruction Set</a></li><li><a href=#a-sample-display-list>A Sample Display List</a></li><li><a href=#cycle-stealing-by-antic>Cycle Stealing by ANTIC</a></li></ol></li><li><a href=#a-crash-course-on-display-list-interrupts>A Crash Course on Display List Interrupts</a><ol><li><a href=#hardware--shadow-registers>Hardware & Shadow Registers</a></li><li><a href=#a-simple-example>A Simple Example</a></li><li><a href=#a-simple-example-with-wsync>A Simple Example with WSYNC</a></li><li><a href=#a-dli-can-affect-many-scan-lines>A DLI Can Affect Many Scan Lines</a></li></ol></li><li><a href=#a-crash-course-on-display-list-interrupts-getting-interrupted>A Crash Course on Display List Interrupts Getting Interrupted</a><ol><li><a href=#dli-interrupting-another-dli>DLI Interrupting Another DLI</a></li><li><a href=#emulator-differences>Emulator Differences</a></li><li><a href=#vbi-interrupting-a-dli>VBI Interrupting A DLI</a></li><li><a href=#dli-on-the-jvb-instruction>DLI on the JVB Instruction</a></li></ol></li><li><a href=#dlis-in-a-nutshell>DLIs in a Nutshell</a></li><li><a href=#advanced-dli-examples>Advanced DLI Examples</a></li><li><a href=#1-multiple-dlis>#1: Multiple DLIs</a></li><li><a href=#2-moving-the-dli-up-and-down-the-screen>#2: Moving the DLI Up and Down the Screen</a></li><li><a href=#interlude-a-playermissile-graphics-refresher>Interlude: A Player/Missile Graphics Refresher</a></li><li><a href=#3-multiplexing-players-vertically>#3: Multiplexing Players Vertically</a></li><li><a href=#4-multiplexing-with-horizontal-motion>#4: Multiplexing With Horizontal Motion</a></li><li><a href=#n-multiplexing-with-arbitrary-motion>#n: Multiplexing with Arbitrary Motion</a></li><li><a href=#n-multiplexing-with-collision-detection>#n: Multiplexing With Collision Detection</a></li><li><a href=#n-multiplexing-players-horizontally>#n: Multiplexing Players Horizontally</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>