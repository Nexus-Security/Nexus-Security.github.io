<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A Crash Course on Advanced DLIs Atari 8-bit Display List Interrupts: An Advanced Tutorial
Revision 1, updated 3 Dec 2019
This is a tutorial on advanced Display List Interrupts (DLIs) for the Atari 8-bit series of computers. In a nutshell, DLIs provide a way to notify your program when a particular scan line is reached, allowing you to make changes mid-screen.
DLIs are an advanced programming technique in the sense that they require knowledge of 6502 assembly language, so this tutorial is going to assume that you are comfortable with that."><title>Atari 8-Bit Display List Interrupts: An Advanced Tutorial</title><link rel=canonical href=https://Nexus-Security.github.io/posts/2016-09-09-atari-8-bit-display-list-interrupts/><link rel=stylesheet href=/scss/style.min.450926226e724574a6b936335ea06111f8aeb253d932c86cb2cc807341cd2889.css><meta property="og:title" content="Atari 8-Bit Display List Interrupts: An Advanced Tutorial"><meta property="og:description" content="A Crash Course on Advanced DLIs Atari 8-bit Display List Interrupts: An Advanced Tutorial
Revision 1, updated 3 Dec 2019
This is a tutorial on advanced Display List Interrupts (DLIs) for the Atari 8-bit series of computers. In a nutshell, DLIs provide a way to notify your program when a particular scan line is reached, allowing you to make changes mid-screen.
DLIs are an advanced programming technique in the sense that they require knowledge of 6502 assembly language, so this tutorial is going to assume that you are comfortable with that."><meta property="og:url" content="https://Nexus-Security.github.io/posts/2016-09-09-atari-8-bit-display-list-interrupts/"><meta property="og:site_name" content="ZYChimne"><meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:published_time" content="2019-12-05T04:01:00+01:00"><meta property="article:modified_time" content="2019-12-05T04:01:00+01:00"><meta name=twitter:title content="Atari 8-Bit Display List Interrupts: An Advanced Tutorial"><meta name=twitter:description content="A Crash Course on Advanced DLIs Atari 8-bit Display List Interrupts: An Advanced Tutorial
Revision 1, updated 3 Dec 2019
This is a tutorial on advanced Display List Interrupts (DLIs) for the Atari 8-bit series of computers. In a nutshell, DLIs provide a way to notify your program when a particular scan line is reached, allowing you to make changes mid-screen.
DLIs are an advanced programming technique in the sense that they require knowledge of 6502 assembly language, so this tutorial is going to assume that you are comfortable with that."></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hue825486955cd7c56d95e38b4bd2a8e3c_229979_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>ZYChimne</a></h1><h2 class=site-description>Computer Science, Wuhan University</h2></div></header><ol class=social-menu><li><a href=https://github.com/Nexus-Security target=_blank title=GitHub><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=mailto:0x000216@gmail.com target=_blank title=Email><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-gmail" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M16 20h3a1 1 0 001-1V5a1 1 0 00-1-1h-3v16z"/><path d="M5 20h3V4H5A1 1 0 004 5v14a1 1 0 001 1z"/><path d="M16 4l-4 4-4-4"/><path d="M4 6.5l8 7.5 8-7.5"/></svg></a></li><li><a href=https://www.buymeacoffee.com/0x000216 target=_blank title=Coffee><svg width="884" height="1279" viewBox="0 0 884 1279" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg"><defs><path d="M0 0H884V1279H0V0z" id="path_1"/><clipPath id="mask_1"><use xlink:href="#path_1"/></clipPath></defs><g id="buymeacoffee"><path d="M0 0H884V1279H0V0z" id="Background" fill="none" fill-rule="evenodd" stroke="none"/><g clip-path="url(#mask_1)"><path d="M791.109 297.518 790.231 297.002 788.201 296.383C789.018 297.072 790.04 297.472 791.109 297.518z" id="Shape" fill="#0d0c22" stroke="none"/><path d="M803.916 388.891l-1 1 1-1z" id="Shape" fill="#0d0c22" stroke="none"/><path d="M792.113 297.647C791.776 297.581 791.447 297.462 791.127 297.29 791.108 297.622 791.108 297.958 791.127 298.29 791.488 298.216 791.83 297.995 792.113 297.647z" id="Shape" fill="#0d0c22" stroke="none"/><path d="M791.113 298.447h1v-1l-1 1z" id="Shape" fill="#0d0c22" stroke="none"/><path d="M803.111 388.726 804.591 387.883 805.142 387.573 805.641 387.04C804.702 387.444 803.846 388.016 803.111 388.726z" id="Shape" fill="#0d0c22" stroke="none"/><path d="M793.669 299.515 792.223 298.138 791.243 297.605C791.77 298.535 792.641 299.221 793.669 299.515z" id="Shape" fill="#0d0c22" stroke="none"/><path d="M430.019 1186.18C428.864 1186.68 427.852 1187.46 427.076 1188.45L427.988 1187.87C428.608 1187.3 429.485 1186.63 430.019 1186.18z" id="Shape" fill="#0d0c22" stroke="none"/><path d="M641.681 1144.63C641.681 1143.33 640.424 1143.57 640.729 1148.21 640.729 1147.84 641.035 1147.46 641.171 1147.1 641.341 1146.27 641.477 1145.46 641.681 1144.63z" id="Shape" fill="#0d0c22" stroke="none"/><path d="M619.284 1186.18C618.129 1186.68 617.118 1187.46 616.342 1188.45L617.254 1187.87C617.873 1187.3 618.751 1186.63 619.284 1186.18z" id="Shape" fill="#0d0c22" stroke="none"/><path d="M281.304 1196.06C280.427 1195.3 279.354 1194.8 278.207 1194.61 279.136 1195.06 280.065 1195.51 280.684 1195.85L281.304 1196.06z" id="Shape" fill="#0d0c22" stroke="none"/><path d="M247.841 1164.01C247.704 1162.66 247.288 1161.35 246.619 1160.16 247.093 1161.39 247.489 1162.66 247.806 1163.94L247.841 1164.01z" id="Shape" fill="#0d0c22" stroke="none"/><path d="M472.623 590.836c-45.941 19.667-98.077 41.966-165.647 41.966C278.71 632.746 250.58 628.868 223.353 621.274l46.733 479.806C271.74 1121.13 280.876 1139.83 295.679 1153.46 310.482 1167.09 329.87 1174.65 349.992 1174.65 349.992 1174.65 416.254 1178.09 438.365 1178.09 462.161 1178.09 533.516 1174.65 533.516 1174.65c20.12.0 39.503-7.57000000000016 54.303-21.2C602.619 1139.82 611.752 1121.13 613.406 1101.08l50.053-530.204C641.091 563.237 618.516 558.161 593.068 558.161 549.054 558.144 513.591 573.303 472.623 590.836z" id="Shape" fill="#fff" stroke="none"/><path d="M78.6885 386.132 79.4799 386.872 79.9962 387.182C79.5987 386.787 79.1603 386.435 78.6885 386.132z" id="Shape" fill="#0d0c22" stroke="none"/><path d="M879.567 341.849 872.53 306.352C866.215 274.503 851.882 244.409 819.19 232.898 808.711 229.215 796.821 227.633 788.786 220.01 780.751 212.388 778.376 200.55 776.518 189.572 773.076 169.423 769.842 149.257 766.314 129.143 763.269 111.85 760.86 92.4243 752.928 76.56c-10.324-21.3016-31.746-33.7591-53.048-42.001C688.965 30.4844 677.826 27.0375 666.517 24.2352 613.297 10.1947 557.342 5.03277 502.591 2.09047 436.875-1.53577 370.983-.443233 305.422 5.35968 256.625 9.79894 205.229 15.1674 158.858 32.0469c-16.948 6.1771-34.413 13.593-47.3 26.6872C95.7448 74.8221 90.5829 99.7026 102.128 119.765c8.208 14.247 22.111 24.313 36.857 30.972C158.192 159.317 178.251 165.846 198.829 170.215c57.297 12.664 116.642 17.636 175.178 19.753C438.887 192.586 503.87 190.464 568.44 183.618 584.408 181.863 600.347 179.758 616.257 177.304 634.995 174.43 647.022 149.928 641.499 132.859 634.891 112.453 617.134 104.538 597.055 107.618 594.095 108.082 591.153 108.512 588.193 108.942L586.06 109.252C579.257 110.113 572.455 110.915 565.653 111.661c-14.052 1.514-28.138 2.753-42.259 3.717C491.768 117.58 460.057 118.595 428.363 118.647c-31.144.0-62.305-.878-93.38-2.92500000000001C320.805 114.793 306.661 113.611 292.552 112.177 286.134 111.506 279.733 110.801 273.333 110.009L267.241 109.235 265.917 109.046 259.602 108.134C246.697 106.189 233.792 103.953 221.025 101.251 219.737 100.965 218.584 100.249 217.758 99.2193 216.932 98.1901 216.482 96.9099 216.482 95.5903 216.482 94.2706 216.932 92.9904 217.758 91.9612 218.584 90.9319 219.737 90.2152 221.025 89.9293H221.266C232.33 87.5721 243.479 85.5589 254.663 83.8038 258.392 83.2188 262.131 82.6453 265.882 82.0832H265.985C272.988 81.6186 280.026 80.3625 286.994 79.5366 347.624 73.2302 408.614 71.0801 469.538 73.1014 499.115 73.9618 528.676 75.6996 558.116 78.6935 564.448 79.3474 570.746 80.0357 577.043 80.8099 579.452 81.1025 581.878 81.4465 584.305 81.7391L589.191 82.4445C603.438 84.5667 617.61 87.1419 631.708 90.1703 652.597 94.7128 679.422 96.1925 688.713 119.077 691.673 126.338 693.015 134.408 694.649 142.03L696.731 151.752C696.786 151.926 696.826 152.105 696.852 152.285 701.773 175.227 706.7 198.169 711.632 221.111 711.994 222.806 712.002 224.557 711.657 226.255 711.312 227.954 710.621 229.562 709.626 230.982 708.632 232.401 707.355 233.6 705.877 234.504 704.398 235.408 702.75 235.997 701.033 236.236H700.895L697.884 236.649 694.908 237.044C685.478 238.272 676.038 239.419 666.586 240.486 647.968 242.608 629.322 244.443 610.648 245.992 573.539 249.077 536.356 251.102 499.098 252.066 480.114 252.57 461.135 252.806 442.162 252.771 366.643 252.712 291.189 248.322 216.173 239.625 208.051 238.662 199.93 237.629 191.808 236.58 198.106 237.389 187.231 235.96 185.029 235.651 179.867 234.928 174.705 234.177 169.543 233.397 152.216 230.798 134.993 227.598 117.7 224.793 96.7944 221.352 76.8005 223.073 57.8906 233.397c-15.5221 8.494-28.0851 21.519-36.013 37.338-8.1559 16.862-10.582 35.221-14.22974 53.34-3.64777 18.118-9.32591 37.613-7.17511 56.213C5.10128 420.431 33.165 453.054 73.5313 460.35 111.506 467.232 149.687 472.807 187.971 477.556 338.361 495.975 490.294 498.178 641.155 484.129 653.44 482.982 665.708 481.732 677.959 480.378 681.786 479.958 685.658 480.398 689.292 481.668S696.23 485.005 698.962 487.717 703.784 493.718 705.08 497.342C706.377 500.967 706.846 504.836 706.453 508.665L702.633 545.797c-7.697 75.031-15.394 150.057-23.091 225.077-8.029 78.783-16.111 157.56-24.244 236.326C653.004 1029.39 650.71 1051.57 648.416 1073.74 646.213 1095.58 645.904 1118.1 641.757 1139.68 635.218 1173.61 612.248 1194.45 578.73 1202.07 548.022 1209.06 516.652 1212.73 485.161 1213.01 450.249 1213.2 415.355 1211.65 380.443 1211.84 343.173 1212.05 297.525 1208.61 268.756 1180.87 243.479 1156.51 239.986 1118.36 236.545 1085.37 231.957 1041.7 227.409 998.039 222.9 954.381L197.607 711.615 181.244 554.538C180.968 551.94 180.693 549.376 180.435 546.76 178.473 528.023 165.207 509.681 144.301 510.627 126.407 511.418 106.069 526.629 108.168 546.76l12.13 116.454 25.087 240.89C152.532 972.528 159.661 1040.96 166.773 1109.41 168.15 1122.52 169.44 1135.67 170.885 1148.78 178.749 1220.43 233.465 1259.04 301.224 1269.91 340.799 1276.28 381.337 1277.59 421.497 1278.24 472.979 1279.07 524.977 1281.05 575.615 1271.72 650.653 1257.95 706.952 1207.85 714.987 1130.13 717.282 1107.69 719.576 1085.25 721.87 1062.8 729.498 988.559 737.115 914.313 744.72 840.061l24.881-242.61 11.408-111.188C781.577 480.749 783.905 475.565 787.649 471.478 791.392 467.391 796.352 464.617 801.794 463.567 823.25 459.386 843.761 452.245 859.023 435.916c24.295-25.998 29.13-59.895 20.544-94.067zM72.7365 365.835C73.247 365.68 72.3065 368.484 71.9034 369.792 71.8229 367.813 71.984 366.058 72.7365 365.835zm1.7756 16.105C74.6842 381.819 75.2003 382.508 75.7337 383.334 74.925 382.576 74.4089 382.009 74.4949 381.94H74.5121zM76.5597 384.641C77.6004 385.897 78.1569 386.689 76.5597 384.641zM80.7002 387.979h.2727C80.9729 388.313 81.473 388.645 81.6548 388.979 81.3533 388.612 81.0186 388.277 80.6548 387.979H80.7002zM800.796 382.989C793.088 390.319 781.473 393.726 769.996 395.43c-128.704 19.099-259.283 28.769-389.399 24.502C287.476 416.749 195.336 406.407 103.144 393.382 94.1102 392.109 84.3197 390.457 78.1082 383.798c-11.7004-12.561-5.9534-37.854-2.9079-53.03C77.9878 316.865 83.3218 298.334 99.8572 296.355 125.667 293.327 155.64 304.218 181.175 308.09 211.917 312.781 242.774 316.538 273.745 319.36 405.925 331.405 540.325 329.529 671.92 311.91 695.905 308.686 719.805 304.941 743.619 300.674 764.835 296.871 788.356 289.731 801.175 311.703 809.967 326.673 811.137 346.701 809.778 363.615 809.359 370.984 806.139 377.915 800.779 382.989H800.796z" id="Shape" fill="#fff" fill-rule="evenodd" stroke="none"/></g></g></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/about-me/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>About Me</span></a></li><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></div></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/posts/2016-09-09-atari-8-bit-display-list-interrupts/>Atari 8-Bit Display List Interrupts: An Advanced Tutorial</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Dec 05, 2019</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>43 minute read</time></div></footer></div></header><section class=article-content><h1 id=a-crash-course-on-advanced-dlis>A Crash Course on Advanced DLIs</h1><p><strong><strong>Atari 8-bit Display List Interrupts: An Advanced Tutorial</strong></strong></p><p><strong>Revision 1, updated 3 Dec 2019</strong></p><p>This is a tutorial on advanced Display List Interrupts (DLIs) for the Atari 8-bit series of computers. In a nutshell, DLIs provide a way to notify your program when a particular scan line is reached, allowing you to make changes mid-screen.</p><p>DLIs are an advanced programming technique in the sense that they require knowledge of 6502 assembly language, so this tutorial is going to assume that you are comfortable with that. All the examples here are assembled using the MAC/65-compatible assembler <a class=link href=https://atari.miribilist.com/atasm/index.html target=_blank rel=noopener>ATasm</a> (and more specifically to this tutorial, the version built-in to <a class=link href=https://github.com/robmcmullen/omnivore target=_blank rel=noopener>Omnivore</a>).</p><p>Before diving into DLIs, it is helpful to understand that they are very accurately named: Display List Interrupts literally interrupt the display list – they cause an event that is processed by your program while the ANTIC is drawing the screen. So it is necessary to understand what display lists are before understanding what it means to interrupt one.</p><p>See also</p><p>Here are some resources for learning more about display list interrupts:</p><h2 id=a-crash-course-on-displays>A Crash Course on Displays</h2><p>A TV screen is drawn by an electron beam tracing a path starting above the visible area, and drawing successive horizontal lines as the beam moves down the screen. Each line is drawn from left-to-right (as you look at the TV screen) and when it reaches the right hand side of the screen, the horizontal retrace starts where the beam is turned off and moved down to the next scan line below whereupon the beam is turned back on and the next line draws. When the full frame has been drawn, the beam is turned off again and the vertical retrace starts (starting the vertical blank interval). Once the beam is repositioned to the top leftmost position, the vertical blank interval ends, the beam is turned back on, and the next frame is started.</p><p>On NTSC systems, the Atari draws 262 scan lines per frame, 60 times per second. On PAL systems it draws 312 scan lines per frame, 50 times per second. In either system, it draws scan lines from the top down, and left to right within a scan line.</p><p>This simplified description is the mental model we will use to describe the video drawing process.</p><h3 id=how-interlacing-works-with-some-hand-waving-and-why-we-ignore-it>How Interlacing Works (With Some Hand Waving) and Why We Ignore It</h3><p>Real TVs are interlaced with 525 scan lines for NTSC and 625 for PAL. Because of <a class=link href=https://en.wikipedia.org/wiki/NTSC#Lines_and_refresh_rate target=_blank rel=noopener>reasons</a>, the NTSC vertical refresh interval is not exactly the whole number of 60Hz either, it’s 60/1001 Hz or 59.94Hz. PAL refresh rate is apparently <a class=link href=http://martin.hinner.info/vga/pal.html target=_blank rel=noopener>exactly 50Hz</a>.</p><p>Every refresh interval, the electron beam draws one <strong>field</strong>, starting at the top left and drawing every other scan line. When it reaches the bottom, the vertical retrace starts, but this time it positions the electron beam at the first missing scan line. Then it draws the next field, again skipping every other scan line but this time filling in the scan lines it missed.</p><p><img src=https://playermissile.com/_images/electron-beam-interlaced.png loading=lazy alt=../_images/electron-beam-interlaced.png></p><p>This drawing is a simplification, seeming to show that there are 524 scan lines. In reality, and there are 525 and each field actually draws 262 <strong>and one half</strong> scan lines (and not 262 on one field and 263 on another), but this is all very complicated and not necessary for our purposes. However, at the risk of further complicating matters, the Atari produces 262 scan lines for the even field and 262 scan lines for the odd field. In the situation where the Atari is producing an image that is not changing as time goes on, like the computer is sitting at the BASIC language READY prompt and you aren’t typing anything, the scan lines produced for the even field will be exactly the same as the scan lines produced for the odd field.</p><p>Practically speaking, you do not need to care that the screen is interlaced with 525 scan lines (for NTSC). Our mental model will be as if the Atari is drawing to a non-interlaced screen with 262 scan lines and a frame rate of 59.94Hz. (For PAL, substitute 625, 312, and 50, respectively.)</p><h3 id=how-color-works-and-theres-more-hand-waving-isnt-there>How Color Works and There’s More Hand Waving, Isn’t There?</h3><p>How TVs produce the colors that they display is very complicated and so far outside the scope of this tutorial that it might as well be magic. Suffice it to say that color happens.</p><p>On the Atari, a unit called the color clock is the smallest portion of a scan line that can be displayed with an arbitrary color. There are 228 color clocks per scan line, of which about 160 were typically visible on a cathode-ray TV display in the 1970s when the Atari was developed. This corresponds to the 160 pixel horizontal resolution of Antic Modes B through E in the standard width playfield. Antic Mode F (Graphics 8 in BASIC) has 320 addressable pixels, corresponding to half a color clock, and only artifacting color is available.</p><h3 id=how-the-cpu-frequency-was-chosen-and-why-is-there-even-more-hand-waving-oh-author-person>How The CPU Frequency Was Chosen and Why Is There Even More Hand Waving, Oh Author Person?</h3><p>For NTSC machines, each frame draws 262 scan lines with 228 color clocks per scan line, the operating frequency of the 6502 was chosen such that it takes exactly 114 machine cycles per scan line, producing 29868 machine cycles per frame. With a 59.94Hz vertical refresh rate this should result in a processor speed of 1.790287MHz. Here’s where the author does more hand waving because he doesn’t exactly understand what the subtleties are and why those numbers aren’t exact, and instead points to the Altirra Hardware Reference Manual and lets it explain what is really happening. It shows that while there <em>are</em> indeed 29868 cycles per frame, the processor speed is actually 1.790772MHz, to prevent the color subprime mortgage from investigating phantoms on each scan line. Something like that; the author didn’t understand. <em>At all</em>. At any rate, a signal is produced that can be displayed on a TV, even if it does not exactly sync up with broadcast NTSC signals.</p><p>PAL systems produce the same 228 color clocks and 114 machine cycles per line, but display 312 scan lines. This results in 35568 cycles per frame, and with the vertical refresh rate of 50Hz the processor should run at 1.778400MHz. Again, the Altirra reference manual shows slight deviations for complicated technical reasons resulting in a processor speed of 1.773447MHz. Similarly to NTSC, the computer still produces 35568 cycles per frame, just that the signal output for the TV is not exactly the same as broadcast PAL TV signals.</p><h2 id=a-crash-course-on-display-lists>A Crash Course on Display Lists</h2><p>ANTIC is the special coprocessor that handles screen drawing for the Atari computers. It is tightly coupled with the 6502 processor, and in fact can be thought of as being the driver of the 6502 because the ANTIC can halt the 6502 when needed. Since only one chip can read memory at any time, ANTIC needs to halt the 6502 when it needs access to memory, so this Direct Memory Access (DMA) can cause 6502 instructions to appear to take more cycles than documented in a 6502 reference. In fact, the amount of time ANTIC “steals” will depend on many factors: the graphics mode, player/missiles being used, playfield size, and more.</p><p>Since there are 228 color clocks and 114 machine cycles per scan line, this means that in one machine cycle, two color clocks are drawn on the screen. A typical machine instruction might take 5 machine cycles, so 10 color clocks could pass in the time to process a single instruction! This means we don’t have much time per scan line, so DLIs that attempt to change graphics in the middle of a line will have to be well optimized.</p><p>It also means the 6502 is too slow to draw the screen itself, and this is where ANTIC’s special “instruction set” comes in. You program the ANTIC coprocessor using a display list, and ANTIC takes care of building the screen scan line by scan line, without any more intervention from the 6502 code. (Unless you ask for intervention! And that’s what a DLI is.)</p><p>The display list is the special sequence of bytes that ANTIC interprets as a list of instruction. Each instruction causes ANTIC to draw a certain number of scan lines in a particular way. A DLI can be set on any ANTIC instruction.</p><p>ANTIC supports display lists that produce at most 240 scan lines (even on PAL systems where many more scan lines are available), and the vertical blank interval always starts after 248 scan lines. When drawing scan lines, ANTIC skips 8 scan lines at to top of the display, so the output from the display list starts at the 9th scan line. A standard display list starts with 24 blank lines and 192 scan lines of display data, meaning that the TV will see 32 blank lines (the 8 automatically skipped plus the 24 in a standard display list) followed by 192 scan lines of display, then 24 blank lines, and finally the vertical blank that consumes the remaining 14 scan lines on NTSC (or 64 on PAL).</p><h3 id=display-list-instruction-set>Display List Instruction Set</h3><p>An ANTIC display list instruction consists of 1 byte with an optional 2 byte address. There are 3 types of instructions: blank lines, graphics modes, and jump instructions. Instructions are encoded into the byte using a bitmask where low 4 bits encode the graphics mode or feature and the high 4 bits encode the flags that affect that instruction:</p><blockquote><p>7</p><p>6</p><p>5</p><p>4</p><p>3</p><p>2</p><p>1</p><p>0</p><p>DLI</p><p>LMS</p><p>VSCROLL</p><p>HSCROLL</p><p>Mode</p></blockquote><p>The 4 flags are:</p><blockquote><ul><li><p>DLI (<code>$80</code>): enable a display list interrupt when processing this instruction</p></li><li><p>LMS (<code>$40</code>): trigger a Load Memory Scan, changing where ANTIC looks for screen data, and requires an additional 2 byte address immediately following this instruction byte.</p></li><li><p>VSCROLL (<code>$20</code>): enable vertical scrolling for this mode line</p></li><li><p>HSCROLL (<code>$10</code>): enable horizontal scrolling for this mode line</p></li></ul></blockquote><p>The 14 available graphics modes are encoded into low 4 bits using values as shown in this table:</p><p>Mode</p><p>Decimal</p><p>BASIC Mode</p><p>Description</p><p>Scan Lines</p><p>Type</p><p>Colors</p><p>2</p><p>02</p><p>0</p><p>40 x 24</p><p>8</p><p>text</p><p>2</p><p>3</p><p>03</p><p>n/a</p><p>40 x 19</p><p>10</p><p>text</p><p>2</p><p>4</p><p>04</p><p>n/a</p><p>40 x 24</p><p>8</p><p>text</p><p>4</p><p>5</p><p>05</p><p>n/a</p><p>40 x 12</p><p>16</p><p>text</p><p>4</p><p>6</p><p>06</p><p>1</p><p>20 x 24</p><p>8</p><p>text</p><p>5</p><p>7</p><p>07</p><p>2</p><p>20 x 12</p><p>16</p><p>text</p><p>5</p><p>8</p><p>08</p><p>3</p><p>40 x 24</p><p>8</p><p>bitmap</p><p>4</p><p>9</p><p>09</p><p>4</p><p>80 x 48</p><p>4</p><p>bitmap</p><p>2</p><p>A</p><p>10</p><p>5</p><p>80 x 48</p><p>4</p><p>bitmap</p><p>4</p><p>B</p><p>11</p><p>6</p><p>160 x 96</p><p>2</p><p>bitmap</p><p>2</p><p>C</p><p>12</p><p>n/a</p><p>160 x 192</p><p>1</p><p>bitmap</p><p>2</p><p>D</p><p>13</p><p>7</p><p>160 x 96</p><p>2</p><p>bitmap</p><p>4</p><p>E</p><p>14</p><p>n/a</p><p>160 x 192</p><p>1</p><p>bitmap</p><p>4</p><p>F</p><p>15</p><p>8</p><p>320 x 192</p><p>1</p><p>bitmap*</p><p>2</p><p><a class=link href=https://playermissile.com/dli_tutorial/#id1 target=_blank rel=noopener>*</a>mode F is also used as the basis for the GTIA modes (BASIC Graphics modes 9, 10, & 11), but this is a topic outside the scope of this tutorial.</p><p>Blank lines are encoded as a mode value of zero, the bits 6, 5, and 4 taking the meaning of the number of blank lines rather than LMS, VSCROLL, and HSCROLL. Note that the DLI bit is still available on blank lines, as bit 7 is not co-opted by the blank line instruction.</p><p>Blank Line Instructions</p><p>Hex</p><p>Decimal</p><p>Blank Lines</p><p>0</p><p>0</p><p>1</p><p>10</p><p>16</p><p>2</p><p>20</p><p>32</p><p>3</p><p>30</p><p>48</p><p>4</p><p>40</p><p>64</p><p>5</p><p>50</p><p>80</p><p>6</p><p>60</p><p>96</p><p>7</p><p>70</p><p>112</p><p>8</p><p>Jumps provide the capability to split a display list into multiple parts in different memory locations. They are encoded using a mode value of one, and require an additional 2 byte address where ANTIC will look for the next display list instruction. If bit 6 is also set, it becomes the Jump and wait for Vertical Blank (JVB) instruction, which is how ANTIC knows that the display list is finished. The DLI bit may also be set on a jump instruction, but if set on the JVB instruction it triggers a DLI on every scan line from there until the vertical blank starts on the 249th scan line.</p><p>Note</p><p>Apart from the <code>$41</code> JVB instruction, splitting display lists using other jumps like the <code>$01</code> instruction is not common. It has a side-effect of producing a single blank line in the display list.</p><p>The typical method to change the currently active display list is to change the address stored at <code>SDLSTL</code> (in low byte/high byte format in addresses <code>$230</code> and <code>$231</code>). At the next vertical blank, the hardware display list at <code>DLISTL</code> (<code>$d402</code> and <code>$d403</code>) will be updated with the values stored here and the screen drawing will commence using the new display list.</p><p>See also</p><p>More resources about display lists are available:</p><h3 id=a-sample-display-list>A Sample Display List</h3><p>Here is a display list that contains different text modes mixed in a single screen.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>dlist .byte $70,$70,$70 ; 24 blank lines .byte $46,$00,$40 ; Mode 6 + LMS, setting screen memory to $4000 .byte 6 ; Mode 6 .byte $70 ; 8 blank lines .byte 7,7,7,7,7 ; 5 lines of Mode 7 .byte $70 ; 8 blank lines .byte 2 ; single line of Mode 2 .byte $70,$70,$70 ; 24 blank lines .byte 2,4 ; Mode 2 followed by mode 4 .byte $70 ; 8 blank lines .byte 2,5 ; Mode 2 followed by mode 5 .byte $41,&lt;dlist,\&gt;dlist ; JVB, restart same display list on next frame 
</span></span></code></pre></td></tr></table></div></div><h3 id=cycle-stealing-by-antic>Cycle Stealing by ANTIC</h3><p>The ANTIC coprocessor needs to access memory to perform its functions, and since the 6502 and ANTIC can’t both access at once, ANTIC will pause execution of the 6502 when it needs to read memory. It happens at specific points within the 114 cycles of each scan line, but where it happens (and how many times the 6502 gets paused during the scan line) depends on the graphics mode.</p><p>For overhead, ANTIC will typically steal 3 cycles to read the display list, 5 cycles if player/missile graphics are enabled, and 9 cycles for memory refreshing. Scrolling requires additional cycle stealing because ANTIC needs to fetch more memory.</p><p>Bitmapped modes (modes 8 - F) have cycles stolen corresponding to the number of bytes per line used in that mode. For example, mode E will use an additional 40 cycles, so in the context of writing a DLI for a game, the typical number of stolen cycles could be 57 out of the 114 cycles per scan line: 17 cycles for ANTIC overhead and 40 for the number of bytes per line.</p><p>Text modes require additional cycles over bitmapped graphics modes, because ANTIC must fetch the font glyphs in addition to its other work. The first scan line of a font mode is almost entirely used by ANTIC and only a small number of cycles is available to the 6502. For normal 40-byte wide playfields, the first line of ANTIC modes 2 through 5 will yield at most about 30 cycles and subsequent lines about 60 cycles per scan line.</p><p>About the worst-case scenario is one of the best modes for games: ANTIC mode 4. This text mode, combined with scrolling and player/missile graphics and can reduce the available cycles to fewer than 10 on the first line and about 50 on subsequent lines!</p><h2 id=a-crash-course-on-display-list-interrupts>A Crash Course on Display List Interrupts</h2><p>DLIs are non-maskable interrupts (NMIs), meaning they cannot be ignored. When an NMI occurs, the 6502 jumps to the address stored at <code>$fffa</code>, which points to an OS routine that checks the type of interrupt (either a DLI or a VBI) and vectors through the appropriate user vector. The NMI handler takes care of saving the processor status register and sets the interrupt flag, but <em>does not</em> save any processor registers. The user routine is responsible for saving any registers that it uses, restoring them when it is done using them, and must exit using the <code>RTI</code> instruction.</p><p>Display list interrupts are not enabled by default. To use a DLI, the address vector at <code>VDLSLT</code> (<code>$200</code> and <code>$201</code>) must be set to your routine, and then they must be enabled through a write to <code>NMIEN</code> at <code>$d40e</code>.</p><p>Warning</p><p>You must set the address of your DLI before enabling them, otherwise the DLI could be called and use whatever address is stored at <code>$200</code>.</p><p>This initialization code can look like the following, where the constants <code>NMIEN_VBI</code> and <code>NMIEN_DLI</code> are defined as <code>$40</code> and <code>$80</code>, respectively, in hardware.s in the sample repository. Since <code>NMIEN</code> also controls the vertical blank interrupt, you must make sure that the VBI enable flag is also set.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>; load display list interrupt address lda #&lt;dli sta VDSLST lda #\&gt;dli sta VDSLST+1 ; activate display list interrupt and vertical blank interrupt lda #NMIEN\_DLI | NMIEN\_VBI sta NMIEN 
</span></span></code></pre></td></tr></table></div></div><p>If your program has multiple DLIs, it may be necessary to set your DLIs in a vertical blank interrupt to guarantee that ANTIC will process them in the right order. Outside the VBI, your code could be running at an arbitrary scan line, perhaps between display list instructions that have their DLI bits set. In Yaron Nir’s tutorial a different technique is used, one not requiring a vertical blank interrupt but instead using the <code>RTCLOK</code> 3-byte zero page variable to instead infer that a VBI has <em>just</em> occurred. The last of the bytes, location <code>$14</code>, is incremented every vertical blank, so that technique is to wait until location <code>$14</code> changes, then set <code>NMIEN</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> lda RTCLOK+2 ?loop cmp RTCLOK+2 ; will be equal until incremented in VB beq ?loop ; activate display list interrupt and vertical blank interrupt lda #NMIEN\_DLI | NMIEN\_VBI sta NMIEN 
</span></span></code></pre></td></tr></table></div></div><h3 id=hardware--shadow-registers>Hardware & Shadow Registers</h3><p>The Atari is a memory-mapped system, where hardware devices like the ANTIC and GTIA chips are <em>mapped</em> to locations in memory and data is passed back and forth by reading or writing to specific addresses. They are usually either read-only or write-only, and many times an address is used for wildly different features depending on whether the address is read from or written to.</p><p>Some of these hardware locations also have <em>shadow</em> registers in low RAM (typically page 2) that are labeled as performing the same function as a hardware register, with two important differences.</p><p>First, they can be both read and written to, so (assuming you always use the shadow register to update the hardware register) it is possible to find out the current state of a hardware register by reading its shadow.</p><p>Second, the hardware register is only updated <strong>once every vertical blank</strong> by an operating system routine that copies the shadow value to its hardware counterpart. Note that it does not happen the other way around, so changing a hardware register <em>does not</em> update a shadow register.</p><p>The shadow registers are a convenience for development in higher level languages like BASIC where speed is not paramount. But code within a DLI must use hardware registers directly to affect change on a scan line.</p><p>The shadow registers can still be useful in DLI development, in that they will automatically reset the hardware registers to the values in the shadow registers every vertical blank. This can be used to reset features like graphics colors and the character set address for the top of the screen at the next frame.</p><p>Note</p><p>This only works if the operating system’s immediate vertical blank routine has not been replaced (i.e. you are only using the deferred vertical blank <code>VVBLKD</code> at <code>$224</code> and haven’t replaced the immediate vertical blank rountine <code>VVBLKI</code> at <code>$222</code>).</p><p>Some hardware registers have no shadows, like player position and size, so your own code (in the deferred VBI or the final DLI) must reset these to their correct values for the top of the screen.</p><p>Some Useful Shadow Registers</p><p>Shadow</p><p>Hex</p><p>Hardware</p><p>Hex</p><p>Description</p><p>GPRIOR</p><p>26f</p><p>PRIOR</p><p>d01b</p><p>Player/playfield priority selection register</p><p>PCOLR0</p><p>2c0</p><p>COLPM0</p><p>d012</p><p>Color of player/missile 0</p><p>PCOLR1</p><p>2c1</p><p>COLPM1</p><p>d013</p><p>Color of player/missile 1</p><p>PCOLR2</p><p>2c2</p><p>COLPM2</p><p>d014</p><p>Color of player/missile 2</p><p>PCOLR3</p><p>2c3</p><p>COLPM3</p><p>d015</p><p>Color of player/missile 3</p><p>COLOR0</p><p>2c4</p><p>COLPF0</p><p>d016</p><p>Color of playfield 0</p><p>COLOR1</p><p>2c5</p><p>COLPF1</p><p>d017</p><p>Color of playfield 1</p><p>COLOR2</p><p>2c6</p><p>COLPF2</p><p>d018</p><p>Color of playfield 2</p><p>COLOR3</p><p>2c7</p><p>COLPF3</p><p>d019</p><p>Color of playfield 3</p><p>COLOR4</p><p>2c8</p><p>COLBK</p><p>d01a</p><p>Background color</p><p>CHACT</p><p>2f3</p><p>CHACTL</p><p>d401</p><p>Character mode (inverse, upside-down characters)</p><p>CHBAS</p><p>2f4</p><p>CHBASE</p><p>d409</p><p>Character base (page number of font)</p><h3 id=a-simple-example>A Simple Example</h3><p>A common use of display lists is to change colors in the middle of the screen.</p><p>Here is our first display list interrupt:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>dli pha ; only using A register, so save old value to the stack lda #$7a ; new background color sta COLBK ; store it in the hardware register pla ; restore the A register rti ; always end DLI with RTI! 
</span></span></code></pre></td></tr></table></div></div><p>This is all the code it takes to change the color of the background. The obvious effect is the flickering line in the background, which we will solve in the next section.</p><p>Examining the code shows the boilerplate discussed <a class=link href=https://playermissile.com/dli_tutorial/#a-crash-course-on-display-list-interrupts target=_blank rel=noopener>above</a> where DLIs always end with the <code>RTI</code> instruction and any registers used must be saved before your code changes them, and restored upon exit.</p><p>The work performed in the interrupt is just two instructions: a load of a color value and a store where it puts it in the <em>hardware</em> register for the background color. Again, as noted <a class=link href=https://playermissile.com/dli_tutorial/#hardware-shadow-registers target=_blank rel=noopener>above</a>, hardware registers must be used in DLIs, not the shadow registers as shadow registers are ignored until the vertical blank.</p><h3 id=a-simple-example-with-wsync>A Simple Example with WSYNC</h3><p>The Atari provides a way to sync with a scan line to avoid the flickering effect of the previous example.</p><p>The flickering is avoided by saving some value (any value, the bit pattern is not important) to the <code>WSYNC</code> memory location at <code>$d40a</code>. This causes the 6502 to stop processing instructions until the electron beam nears the end of the scan line, at which point the 6502 will resume executing instructions. Because the electron beam is usually off-screen at this point, it is safe to change color registers for at least the next several instructions without artifacts appearing on screen.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>dli pha ; only using A register, so save old value to the stack lda #$7a ; new background color sta WSYNC ; any value saved to WSYNC will trigger the pause sta COLBK ; store it in the hardware register pla ; restore the A register rti ; always end DLI with RTI! 
</span></span></code></pre></td></tr></table></div></div><p>Note</p><p><code>WSYNC</code> (wait for horizontal blank) usually restarts the 6502 on or about cycle 105 out of 114, but there are cases that can delay that. See the Altirra Hardware Reference Manual for more information.</p><h3 id=a-dli-can-affect-many-scan-lines>A DLI Can Affect Many Scan Lines</h3><p>DLIs can really be thought of as a way for your program to be told when a certain display list instruction is reached. Apart from the setup and teardown of the DLI subroutine itself and some timing limitations discussed in the next section, arbitrary amounts of code can be executed in a DLI.</p><p>Note</p><p>Author’s note: thinking that DLIs had to be short was a great source of confusion to me when trying to figure out how rainbow effects were generated. My thinking was that DLIs could only affect a single line, and for instance I could not figure out how to get a color change in the middle of a text mode. I don’t know why I thought that something bad would happen if a DLI went long, but I did.</p><p>This example shows how to have a single DLI affect multiple scan lines, even crossing into subsequent ANTIC mode 4 lines in the display list:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>dli pha ; save A &amp; X registers to stack txa pha ldx #16 ; make 16 color changes lda #$a ; initial color sta WSYNC ; first WSYNC gets us to start of scan line we want ?loop sta COLBK ; change background color clc adc #$11 ; change color value, luminance remains the same dex ; update iteration count sta WSYNC ; make it the color change last ... sta WSYNC ; for two scan lines bne ?loop ; sta doesn&#39;t affect flags so this still checks result of dex lda #$00 ; reset background color to black sta COLBK pla ; restore X &amp; A registers from stack tax pla rti ; always end DLI with RTI! 
</span></span></code></pre></td></tr></table></div></div><p>It changes background colors 16 times, where each color change lasts 2 scan lines. So 32 scan lines means that it covers 4 display list entries of ANTIC mode 4.</p><h2 id=a-crash-course-on-display-list-interrupts-getting-interrupted>A Crash Course on Display List Interrupts Getting Interrupted</h2><blockquote><ul><li><p>DLIs can be interrupted by other DLIs</p></li><li><p>DLIs can be interrupted by the vertical blank</p></li><li><p>a DLI on a JVB instruction will cause interrupts on every scan line until the vertical blank</p></li></ul></blockquote><h3 id=dli-interrupting-another-dli>DLI Interrupting Another DLI</h3><p>When a DLI is interrupted, its state is saved just as if a normal program was interrupted. The interrupting code is then executed, and upon its completion, the control returns to the DLI at the point where it left off. But at this point, due to the interrupting event, the restored DLI will be resumed some number of scan lines below where it was interrupted, likely resulting in unplanned behavior.</p><p>Here’s a similar DLI to the above, except it changes the luminance value instead of the color value to make the effect easier to see. It starts with a bright pink and gets dimmer down to a dark red after 32 scan lines:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>dli pha ; save A &amp; X registers to stack txa pha ldx #16 ; make 16 color changes lda #$5f ; initial bright pink color sta WSYNC ; first WSYNC gets us to start of scan line we want ?loop sta COLBK ; change background color sec sbc #1 ; make dimmer by decrementing luminance value dex ; update iteration count sta WSYNC ; make it the color change last ... sta WSYNC ; for two scan lines bne ?loop ; sta doesn&#39;t affect processor flags so we are still checking result of dex lda #$00 ; reset background color to black sta COLBK pla ; restore X &amp; A registers from stack tax pla rti ; always end DLI with RTI! 
</span></span></code></pre></td></tr></table></div></div><p>But this time, the display list has <em>two</em> lines that have the DLI bit set:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>dlist .byte $70,$70,$70 .byte $44,$00,$40 .byte $c4 ; first DLI triggered on last scan line .byte $44 .byte $c4 ; second DLI triggered on last scan line .byte $44,$44,$44,$44,$44,$44,$44,$44 .byte $44,$44,$44,$44,$44,$44,$44,$44 .byte $44,$44,$44,$44 .byte $41,&lt;dlist,\&gt;dlist 
</span></span></code></pre></td></tr></table></div></div><p>Because the <code>VDLSTL</code> pointer is not changed, the same code will be called each time an interrupt occurs.</p><p>The first DLI hits and starts with a bright background color on the first scan line of the third line of text. But because this display list takes a long time, the second DLI on the 4th text line gets triggered before the first DLI has hit its <code>RTI</code> instruction. ANTIC interrupts the first DLI and starts the 2nd DLI anyway. This effect is visible in the 5th line of text: the background color is bright again.</p><p>But notice another artifact: the effect on the 5th line of text isn’t on its first scan line, but its second:</p><p>This is due to the fact that a WSYNC was called on the previous scan line, but the interrupt happened as well. The interrupt takes some cycles to begin, and by the time that happened <strong>and</strong> ANTIC stole all of its cycles to set up the text mode line, there weren’t enough cycles left for the first <code>WSYNC</code> in the DLI code to happen on the same scan line. This forces that <code>WSYNC</code> to happen on the next line, causing the delay and the appearance of a 3rd scan line of the same color before the second DLI starts its color cycling.</p><p>The second DLI completes and performs its <code>RTI</code>, but then it returns control to the first DLI, which is already halfway done with its color cycling. When it resumes control, it is in 9th line of text on the screen, so it has four more color changes before it hits its own <code>RTI</code>.</p><h3 id=emulator-differences>Emulator Differences</h3><p>The DLI interrupting another DLI is clearly an edge case, and edge cases are always good stress tests for emulators. A difference is clearly visible below when comparing a zoomed in portion of the display generated by the Altirra emulator as compared to the atari800 emulator (standalone or as embedded in Omnivore, they are the same code and produce the same result):</p><p><img src=https://playermissile.com/_images/emulator-differences.png loading=lazy alt=../_images/emulator-differences.png></p><p>Notice how Altirra gets the color from the first DLI for two scan lines, 64 and 65, before the correct color appears on scan line 66. The output from Altirra shows that the NMI doesn’t happen until between scan line 63 and 64. But clearly, the <code>sta COLBK</code> at scan line 63 is taking effect on scan line 64, because scan line 64 has the background color <code>$57</code>. It appears the store of <code>$5f</code> on scan line 65, started on cycle 1 of that line, isn’t actually executed until much, much later since the <code>sec</code> doesn’t begin until cycle 108. This puts that color change in the horizontal blank period of scan line 65, which would seem to explain why Altirra shows two scan lines with the background color from the first DLI.</p><p>This is the CPU history from the Altirra emulator:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> 60: 3 | A=58 X=09 Y=00 ( I C) | 3030: 8D 0A D4 STA WSYNC 60: 7 | A=58 X=09 Y=00 ( I C) | 3033: 8D 0A D4 STA WSYNC 60:108 | A=58 X=09 Y=00 ( I C) | 3036: D0 F1 BNE $3029 61:107 | A=58 X=09 Y=00 ( I C) | 3029: 8D 1A D0 L3029 STA COLBK 61:111 | A=58 X=09 Y=00 ( I C) | 302C: 38 SEC 61:113 | A=58 X=09 Y=00 ( I C) | 302D: E9 01 SBC #$01 62: 1 | A=57 X=09 Y=00 ( I C) | 302F: CA DEX 62: 3 | A=57 X=08 Y=00 ( I C) | 3030: 8D 0A D4 STA WSYNC 62: 7 | A=57 X=08 Y=00 ( I C) | 3033: 8D 0A D4 STA WSYNC 62:108 | A=57 X=08 Y=00 ( I C) | 3036: D0 F1 BNE $3029 63:107 | A=57 X=08 Y=00 ( I C) | 3029: 8D 1A D0 L3029 STA COLBK - NMI interrupt (DLI) 64: 5 | A=57 X=08 Y=00 ( I C) | E791: 2C 0F D4 LE791 BIT NMIST 64: 11 | A=57 X=08 Y=00 (N I C) | E794: 10 03 BPL $E799 64: 13 | A=57 X=08 Y=00 (N I C) | E796: 6C 00 02 JMP (VDSLST) 64: 19 | A=57 X=08 Y=00 (N I C) | 301F: 48 PHA 64:102 | A=57 X=08 Y=00 (N I C) | 3020: 8A TXA 64:104 | A=08 X=08 Y=00 ( I C) | 3021: 48 PHA 64:107 | A=08 X=08 Y=00 ( I C) | 3022: A2 10 LDX #$10 64:109 | A=08 X=10 Y=00 ( I C) | 3024: A9 5F LDA #$5F 64:111 | A=5F X=10 Y=00 ( I C) | 3026: 8D 0A D4 STA WSYNC 65: 1 | A=5F X=10 Y=00 ( I C) | 3029: 8D 1A D0 L3029 STA COLBK 65:108 | A=5F X=10 Y=00 ( I C) | 302C: 38 SEC 65:110 | A=5F X=10 Y=00 ( I C) | 302D: E9 01 SBC #$01 65:112 | A=5E X=10 Y=00 ( I C) | 302F: CA DEX 66: 0 | A=5E X=0F Y=00 ( I C) | 3030: 8D 0A D4 STA WSYNC 66: 4 | A=5E X=0F Y=00 ( I C) | 3033: 8D 0A D4 STA WSYNC 66:108 | A=5E X=0F Y=00 ( I C) | 3036: D0 F1 BNE $3029 67:107 | A=5E X=0F Y=00 ( I C) | 3029: 8D 1A D0 L3029 STA COLBK 
</span></span></code></pre></td></tr></table></div></div><p>The atari800 emulator hits the DLI two instructions earlier than Altirra, immediately after the two <code>sta WSYNC</code> commands (and therefore before the <code>sta COLBK</code> that causes Altirra to have a new color on scan line 64). In the atari800/Omnivore instruction history below:</p><p>the DLI starts late on scan line 63 as (naively) expected and gets to the <code>sta WSYNC</code> early in scan line 64 while there is still time to hit the <code>sta COLBK</code> while still on scan line 64. This changes scan line 65 to be the correct background color for the second DLI.</p><p>Note</p><p>I’m not sure what’s going on with the differences in the WSYNC behavior between the two emulators. On Altirra, the two WSYNC commands seem to occur on scan line 62, but their effects aren’t felt immediately, so perhaps this is what’s causing the DLI to hit on scan line 64 instead of scan line 63. On atari800, the WSYNC commands cause their effects to be felt immediately, in the next command. I would presume that Altirra is closer to what’s going on with real hardware, as the author of Altirra has written the definitive guide to the internals of the machine, and Altirra has always been the leader in cycle-exact emulation.</p><p>I think the takeaway from this section is: don’t let your DLI get interrupted by anything else, or it is likely that you will encounter emulation differences.</p><h3 id=vbi-interrupting-a-dli>VBI Interrupting A DLI</h3><p>For completeness, here is an example of the vertical blank interrupting a DLI.</p><p>The DLI is started at the bottom of the screen, gets interrupted by the VBI, and picks up again when VBI ends. Even though the electron beam is turned off, <code>WSYNC</code> is still called and performs its delay function when the scan line is off screen. The resulting image resumes its color cycling background on the top of the screen, stopping after 128 scan lines even though only a fraction of those are actually visible on screen.</p><h3 id=dli-on-the-jvb-instruction>DLI on the JVB Instruction</h3><p>A DLI on the JVB instruction at the end of the display list is possible, but has an interesting property: it triggers DLIs on every scan line until the vertical blank.</p><p>If your DLI is not short enough, it will keep getting interrupted by the DLI on triggered by the next scan line, stacking up interrupts until mercifully the triggering process is stopped by the vertical blank after 248 scan lines have been generated.</p><p>Note</p><p>As each new frame is generated in an emulator, it will enumerate the scan lines starting from zero. There are 248 scan lines before the vertical blank, which will be displayed as scan lines 0 - 247. The scan line labeled 248 will be the first scan line of the vertical blank.</p><p>After the vertical blank routine exits, the stacked-up DLI calls will have to unwind themselves so the most recently interrupted DLI (from scan line 247, the scan line just before the vertical blank) will resume and execute code until its <code>RTI</code>. This will pop data off the stack and return control to the DLI that was interrupted on scan line 246, and so-forth until all the interrupted DLIs have issued their <code>RTI</code> instructions.</p><p>On a standard length display list that generates 24 blank lines followed by 192 output lines, the JVB instruction will be on scan line 224. Since the JVB technically generates a single blank line in the display list, the DLI will also be triggered on scan line 224. This case would produce 24 DLIs before the vertical blank.</p><h2 id=dlis-in-a-nutshell>DLIs in a Nutshell</h2><p>DLIs provide you with a way to notify your program at a particular vertical location on the screen. They pause (or interrupt) the normal flow of program code, save the state of the machine, call your DLI subroutine, and restore the state of the computer before returning control to the code that was interrupted.</p><p>Warning</p><p>Here are the requirements for successful use of DLIs:</p><ul><li><p>your DLI routine must save any registers it clobbers</p></li><li><p>restore any registers you save before exiting</p></li><li><p>exit with an <code>RTI</code></p></li><li><p>use <code>WSYNC</code> if necessary</p></li><li><p>be aware of cycles stolen by ANTIC: you could have only 60 cycles per scan line in higher resolution graphics modes, and as few as 10 (<strong>!</strong>) on the first line of text modes</p></li><li><p>store the address of your routine in <code>VDSLST</code> before enabling DLIs with <code>NMIEN</code></p></li><li><p>guard against the DLI itself being interrupted</p></li></ul><p>Note that nowhere in that list was the requirement that the DLI be short. It doesn’t have to be, and in fact DLIs that span multiple scan lines are similar to kernels used in Atari 2600 programming. The difference is that ANTIC steals cycles depending on a bunch of factors, so the total cycle counting approach (or <a class=link href=https://mitpress.mit.edu/books/racing-beam target=_blank rel=noopener>Racing the Beam</a>) is usually not possible.</p><p>However, most DLIs that you will run across in the wild <em>are</em> short, because they typically don’t do a lot of calculations. Most of the setup work will generally be done outside of the DLI and the DLI itself just handles the result of that work.</p><p><img src=https://playermissile.com/_static/Atari_logo_hr.png loading=lazy></p><h2 id=advanced-dli-examples>Advanced DLI Examples</h2><p>The following examples are available in both source code form and as XEX files at the <a class=link href=https://github.com/playermissile/dli_tutorial target=_blank rel=noopener>dli_tutorial source code repository</a> on github.</p><p>They are coded using MAC/65 assembler syntax, but very few assembler-specific features are actually used, so they should be trivially ported to other assemblers.</p><p>To get a copy of all the examples and source code, you can download and install <a class=link href=https://git-scm.com/ target=_blank rel=noopener>git</a> for your platform. Then open a command line prompt on your computer and enter the command: <code>git clone https://github.com/playermissile/dli_tutorial.git</code> to download the complete repository.</p><p>You can also download individual assembly source and XEX files from links in each section.</p><p>In an attempt to de-clutter the examples as much as possible, most of the boilerplate code (for initialization and setup tasks) has been placed in libraries that are included during the compilation process. These are files like <code>util.s</code>, <code>util_dli.s</code> and so forth, and are available in the source code repository or directly <a class=link href=https://github.com/playermissile/dli_tutorial/src target=_blank rel=noopener>here</a>.</p><h2 id=1-multiple-dlis>#1: Multiple DLIs</h2><p>One of the problems with having a single DLI vector is: what do you do when you want to have more than one DLI?</p><p>Some techniques that you will see in the wild:</p><blockquote><ul><li><p>use <code>VCOUNT</code> to check where you are on screen and branch accordingly</p></li><li><p>increment an index value and use that to determine which DLI has been called</p></li><li><p>change the <code>VDLSTL</code> vector to point to the next DLI in the chain</p></li></ul></blockquote><p>Here’s an optimization of the last technique that can save some valuable cycles: put your DLIs in the same page of memory and only change the low byte.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> \*= (\* &amp; $ff00) + 256 ; next page boundary dli pha ; only using A register, so save it to the stack lda #$55 ; new background color sta WSYNC ; first WSYNC gets us to start of scan line we want sta COLBK ; change background color lda #&lt;dli2 ; point to second DLI sta VDSLST pla ; restore A register from stack rti ; always end DLI with RTI! dli2 pha ; only using A register, so save it to the stack lda #$88 ; new background color sta WSYNC ; first WSYNC gets us to start of scan line we want sta COLBK ; change background color pla ; restore A register from stack rti ; always end DLI with RTI! vbi lda #&lt;dli ; set DLI pointer to first in chain sta VDSLST lda #\&gt;dli sta VDSLST+1 jmp XITVBV ; always exit deferred VBI with jump here 
</span></span></code></pre></td></tr></table></div></div><p>This is a simplistic example, but keeping the high byte constant inside the DLI saves 6 cycles (by obviating the need for changing the high byte with <code>LDA #>dli2; STA VDLSTL+1</code>). That may be enough for this optimization to be useful.</p><h2 id=2-moving-the-dli-up-and-down-the-screen>#2: Moving the DLI Up and Down the Screen</h2><p>The DLI subroutine itself doesn’t directly know what scan line caused the interrupt because all DLIs are routed through the same vector at <code>VDLSTL</code>. The only trigger is in the display list: the DLI bit on the display list instruction.</p><p>The display list can be modified in place to move the DLI to different lines without changing any DLI code. The code to move the DLI should be performed in the vertical blank to prevent the display list from being modified as ANTIC is using it to create the display:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>move\_dli\_line ldx last\_dli\_line ; get line number on screen of old DLI lda dlist\_line\_lookup,x ; get offset into display list of that line number tax lda dlist\_first,x ; remove DLI bit and #$7f sta dlist\_first,x ldx dli\_line ; get line number on screen of new DLI stx last\_dli\_line ; remember lda dlist\_line\_lookup,x ; get offset into display list of that line number tax lda dlist\_first,x ; set DLI bit ora #$80 sta dlist\_first,x rts 
</span></span></code></pre></td></tr></table></div></div><p>The example allows the display list to be set on blank lines at the top of the display, and on the last mode 4 line in the display list which displays the background below the last mode 4 line on the screen.</p><h2 id=interlude-a-playermissile-graphics-refresher>Interlude: A Player/Missile Graphics Refresher</h2><p>Player/Missile Graphics is the sprite system provided by the GTIA: independently positioned overlays on the playfield graphics that don’t disturb the playfield.</p><p>Note</p><p>the word <em>sprite</em> in this sense wasn’t in use when the Atari was designed, and <a class=link href=https://graphics.fandom.com/wiki/Sprite target=_blank rel=noopener>several</a> <a class=link href=https://en.wikipedia.org/wiki/Sprite_%28computer_graphics%29 target=_blank rel=noopener>sources</a> <a class=link href=http://groups.google.com/group/comp.sys.ti/msg/73e2451bcae4d91a target=_blank rel=noopener>claim</a> that it was coined by the designers of the Texas Instruments TI 9918 graphics chip at about the same timeframe.</p><p>The GTIA provides 4 players with independent colors (from each other or the playfield) and 4 missiles with colors matching their respective player, or the 4 missiles can be combined into a 5th player with its own color (although this reuses one playfield color). The players are 8 bits wide and can be displayed as one, two, or four color clocks wide per bit. This corresponds a width on screen of 8, 16, and 32 color clocks, respectively. Widths for all players and missiles can be set independently.</p><p>Each player and missile can be positioned at an arbitrary horizontal location by setting a hardware register, but vertical positioning requires copying data to particular locations in the memory area reserved for it. Each player spans the height of the screen, and it is only the bit pattern in its storage area that determines what is drawn on a particular scan line.</p><p>Missiles are two bits wide each with all 4 missiles packed into a single byte for a particular scan line. Bit masking is required to set data for one missile without affecting the others.</p><p>The quick summary for our purposes is that horizontal repositioning of players is fast, it takes only a single store instruction. Vertical repositioning of player image data is slow, it requires copying memory around.</p><h2 id=3-multiplexing-players-vertically>#3: Multiplexing Players Vertically</h2><p>Reusing players (multiplexing) vertically is straightforward, meaning that a single player can be used to display arbitrary images at different vertical locations on the screen, provided that there is no vertical overlap.</p><p>Using the hardware <code>HPOSPn</code> or <code>HPOSMn</code> registers, the DLI will immediately change where ANTIC will draw the player or missile. The next time ANTIC draws the player on a scan line, it will use this new position.</p><p>in the appropriate player or missile X position register. This demo uses the page-alignment trick for the second DLI, and changes the position and size of the players at each interrupt.</p><p>This demo splits the screen vertically into 3 horizontal bands, A, B & C, with the players extending the full height of the screen and labeled 0 through 3. This example uses the VBI to set the players for band A, the <code>dli</code> routine is the bottom of band A (and the top of band B) and therefore sets the players for band B, and the <code>dli2</code> routine is the bottom of band B (and the top of band C) and controls the players for band C.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vbi lda #&lt;dli ; set DLI pointer to first in chain sta VDSLST lda #\&gt;dli sta VDSLST+1 lda #$40 ; set player positions and sizes ... sta HPOSP0 ; for the top of the screen lda #$60 sta HPOSP1 lda #$80 sta HPOSP2 lda #$a0 sta HPOSP3 lda #0 sta SIZEP0 sta SIZEP1 sta SIZEP2 sta SIZEP3 jmp XITVBV ; always exit deferred VBI with jump here \*= (\* &amp; $ff00) + 256 ; next page boundary dli pha ; only using A register, so save it to the stack lda #$55 ; new background color sta WSYNC ; first WSYNC gets us to start of scan line we want sta COLBK ; change background color lda #$30 ; change position and sizes of players sta HPOSP0 lda #$40 sta HPOSP1 lda #$50 sta HPOSP2 lda #$60 sta HPOSP3 lda #1 sta SIZEP0 sta SIZEP1 sta SIZEP2 sta SIZEP3 lda #&lt;dli2 ; point to second DLI sta VDSLST pla ; restore A register from stack rti ; always end DLI with RTI! dli2 pha ; only using A register, so save it to the stack lda #$84 ; new background color sta WSYNC ; first WSYNC gets us to start of scan line we want sta COLBK ; change background color lda #$40 ; change position and sizes of players sta HPOSP0 lda #$70 sta HPOSP1 lda #$90 sta HPOSP2 lda #$b0 sta HPOSP3 lda #3 sta SIZEP0 sta SIZEP1 sta SIZEP2 sta SIZEP3 pla ; restore A register from stack rti ; always end DLI with RTI! 
</span></span></code></pre></td></tr></table></div></div><p>In discussing the timing issues that cause errors at the band boundaries, the players in band A are positioned by the VBI, and so are in place from well off the top of the screen and are correctly positioned at the first scan line. Players 0, 1, and 2 are correct at the bottom of the band, but player 3 extends one scan line too far, into band B.</p><p>The top of band B shows both position and size errors. When the first DLI hits on the last scan line of the 6th line of text, the background color is changed at the <code>WSYNC</code> and ANTIC moves on to start drawing the first scan line of the 7th line of text (which is the first line of text in band B.) Players 0, 1, and 2 are positioned correctly, which means their horizontal positions were set before ANTIC reached that portion of the scan line. The 3rd player remains in the same position as it was in band A, meaning that its horizontal position wasn’t set in time. ANTIC had stolen enough cycles setting up the mode 4 font that the 6502 didn’t get a chance to process the <code>sta HPOS3</code> before ANTIC had to draw that portion of the scan line. Since the code sets sizes after the horizontal positions, none of the sizes are set until the 2nd scan line of band B.</p><p>The transition to band C with the <code>dli2</code> routine produces similar results, there just isn’t enough time with the <code>WSYNC</code> used for the color change <em>and</em> all the cycles stolen by ANTIC mode 4 to process the all of the player changes in the first scan line of the band. Players 0, 1, and 2 are moved, player 3 is not, and all 4 players don’t get the correct size until the 2nd scan line of the band.</p><p>It’s possible to imagine a scenario where a scan line of a player is not visible at all. For example, if player 3 above had been positioned very far to the right and <code>HPOSP3</code> was changed to move player 3 to the far left side, it could be possible that ANTIC has already drawn the left side of the screen but hadn’t yet reached the right side where player 3 had been positioned. Because <code>HPOSP3</code> is now showing that player 3 is on the left side of the screen, ANTIC would not draw it at its old location on the right side of the screen.</p><p>It’s also possible, with careful timing, to reuse a player on a single line. However, purposeful use of this would difficult given all the different horizontal locations of ANTIC’s cycle stealing.</p><p>Mode 4 was chosen (in all of its cycle-stealing glory) for these examples to get an idea of the worst-case scenerio. Taking out the <code>WSYNC</code> and the color change did allow enough time that both the positions and sizes were changed without visible artifacts:</p><p>but this is very simple code and the more real-world example in the next section will show that a buffer zone of several scan lines is necessary to make sure a player isn’t split across a band boundary or, as described above, even duplicating a line of the player or missing a scan line.</p><h2 id=4-multiplexing-with-horizontal-motion>#4: Multiplexing With Horizontal Motion</h2><p>Increasing the number of bands and adding independent player movement within each band requires some data structures and a DLI to control placement in each band.</p><p>The approach used in this example is to use a single DLI that uses an index value to determine which band it is operating within. This index value is used as an offset into arrays that hold the sprite X position, size, color, etc.</p><p>There are a lot of independently moving objects in this demo: 12 bands, each with 4 players. There are very obvious timing issues in most bands on the first scan line after the DLI as sometimes the hardware registers for a player hasn’t been updated fully until the second scan line.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>; same DLI routine is used for each band, the band\_dli\_index is used to set ; player information for the appropriate band dli\_band pha ; using A &amp; X txa pha inc band\_dli\_index ; increment band index, VBI initialized to $ff, ldx band\_dli\_index ; so will become 0 for band A ; control band X positions of players lda bandp0\_x,x ; x position of player 0 in this band sta HPOSP0 lda bandp0\_color,x ; color of player 0 for this band sta COLPM0 lda bandp0\_size,x ; size of player 0 for this band sta SIZEP0 lda bandp1\_x,x ; as above, but for players 1 - 3 sta HPOSP1 lda bandp1\_color,x sta COLPM1 lda bandp1\_size,x sta SIZEP1 lda bandp2\_x,x sta HPOSP2 lda bandp2\_color,x sta COLPM2 lda bandp2\_size,x sta SIZEP2 lda bandp3\_x,x sta HPOSP3 lda bandp3\_color,x sta COLPM3 lda bandp3\_size,x sta SIZEP3 ?done pla ; restore A &amp; X tax pla rti ; always end DLI with RTI! 
</span></span></code></pre></td></tr></table></div></div><p>The addreses <code>bandpN_x</code>, <code>bandpN_color</code>, and <code>bandpN_size</code> (where N is the player number) are declared as lists with the number of entries equal to the number of bands. <code>band_dli_index</code> is incremented each time the DLI starts, and uses that index into the lists so it places the players in the correct location for that band.</p><p>Notice that is <em>all</em> the DLI does. It does not calculate movement or perform any player logic, it simply puts players on the screen in the appropriate place for that band. All the calculation is done in the vertical blank:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>; calculate new positions of players in all bands vbi ldx #0 ?move lda bandp0\_x,x ; update X coordinate clc ; by adding velocity. adc bandp0\_dx,x ; Note that velocity of $ff sta bandp0\_x,x ; is same as -1 cmp #$30 ; check left edge bcs ?right ; if &gt;=, it is still in playfield lda #1 ; nope, &lt;, so make velocity positive sta bandp0\_dx,x bne ?cont ?right cmp #$c0 ; check right edge bcc ?cont ; if &lt;, it is still in playfield lda #$ff ; nope, &gt;=, so make velocity negative sta bandp0\_dx,x ?cont inx ; next player cpx #num\_dli\_bands \* 4 ; loop through 12 bands \* 4 players each bcc ?move lda #$ff ; initialize band index to get ready for band A sta band\_dli\_index jmp XITVBV ; always exit deferred VBI with jump here 
</span></span></code></pre></td></tr></table></div></div><p>Unlike the simple multiplexing demo in the previous section, this VBI does not set any positions of players. Instead, this demo sets the DLI bit on the last group of 8 blank lines at the beginning of the display list, before any mode 4 lines. This initial DLI will set the players for band A, and as you can see in the demo the players above band A use the same X position and size as band L. The colors are not the same as band L, however, because of the use of the shadow registers to set the initial color in the <code>init_pmg</code> subroutine.</p><h2 id=n-multiplexing-with-arbitrary-motion>#n: Multiplexing with Arbitrary Motion</h2><p>Vertical movement within bands requires the moving memory around the player/missile graphics area (pointed to by <code>PMBASE</code>) as in normal usage, with the following limitations:</p><blockquote><ul><li><p>players must stay within their assigned band, otherwise they will get split across bands when the DLI occurs.</p></li><li><p>players should avoid the first few scan lines below the top of the band boundary to prevent splitting</p></li><li><p>when moving a player vertically within a band, only erase data from that band to prevent affecting the multiplexed players in other bands</p></li></ul></blockquote><h2 id=n-multiplexing-with-collision-detection>#n: Multiplexing With Collision Detection</h2><p>If it is important to tell in which band a has collided occurred, the DLI that starts a new band will be required to save the collision status registers, which will determine if a collision happened in the <em>previous</em> band. It will then reset the collision registers so the following DLI can check what happened in this band.</p><p>If the knowledge of the band is not important, you can just check the collision registers in the vertical blank, which will report if there have been any collisions with anything in any band.</p><h2 id=n-multiplexing-players-horizontally>#n: Multiplexing Players Horizontally</h2><p>Reusing players on the same scan line is possible, but its usefulness may be limited to mostly static cases.</p><p>from Hacker News <a class=link href=https://ift.tt/361GQA7 target=_blank rel=noopener>https://ift.tt/361GQA7</a></p></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><footer class=site-footer><section class=copyright>&copy;
2020 -
2022 ZYChimne</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.11.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#a-crash-course-on-displays>A Crash Course on Displays</a><ol><li><a href=#how-interlacing-works-with-some-hand-waving-and-why-we-ignore-it>How Interlacing Works (With Some Hand Waving) and Why We Ignore It</a></li><li><a href=#how-color-works-and-theres-more-hand-waving-isnt-there>How Color Works and There’s More Hand Waving, Isn’t There?</a></li><li><a href=#how-the-cpu-frequency-was-chosen-and-why-is-there-even-more-hand-waving-oh-author-person>How The CPU Frequency Was Chosen and Why Is There Even More Hand Waving, Oh Author Person?</a></li></ol></li><li><a href=#a-crash-course-on-display-lists>A Crash Course on Display Lists</a><ol><li><a href=#display-list-instruction-set>Display List Instruction Set</a></li><li><a href=#a-sample-display-list>A Sample Display List</a></li><li><a href=#cycle-stealing-by-antic>Cycle Stealing by ANTIC</a></li></ol></li><li><a href=#a-crash-course-on-display-list-interrupts>A Crash Course on Display List Interrupts</a><ol><li><a href=#hardware--shadow-registers>Hardware & Shadow Registers</a></li><li><a href=#a-simple-example>A Simple Example</a></li><li><a href=#a-simple-example-with-wsync>A Simple Example with WSYNC</a></li><li><a href=#a-dli-can-affect-many-scan-lines>A DLI Can Affect Many Scan Lines</a></li></ol></li><li><a href=#a-crash-course-on-display-list-interrupts-getting-interrupted>A Crash Course on Display List Interrupts Getting Interrupted</a><ol><li><a href=#dli-interrupting-another-dli>DLI Interrupting Another DLI</a></li><li><a href=#emulator-differences>Emulator Differences</a></li><li><a href=#vbi-interrupting-a-dli>VBI Interrupting A DLI</a></li><li><a href=#dli-on-the-jvb-instruction>DLI on the JVB Instruction</a></li></ol></li><li><a href=#dlis-in-a-nutshell>DLIs in a Nutshell</a></li><li><a href=#advanced-dli-examples>Advanced DLI Examples</a></li><li><a href=#1-multiple-dlis>#1: Multiple DLIs</a></li><li><a href=#2-moving-the-dli-up-and-down-the-screen>#2: Moving the DLI Up and Down the Screen</a></li><li><a href=#interlude-a-playermissile-graphics-refresher>Interlude: A Player/Missile Graphics Refresher</a></li><li><a href=#3-multiplexing-players-vertically>#3: Multiplexing Players Vertically</a></li><li><a href=#4-multiplexing-with-horizontal-motion>#4: Multiplexing With Horizontal Motion</a></li><li><a href=#n-multiplexing-with-arbitrary-motion>#n: Multiplexing with Arbitrary Motion</a></li><li><a href=#n-multiplexing-with-collision-detection>#n: Multiplexing With Collision Detection</a></li><li><a href=#n-multiplexing-players-horizontally>#n: Multiplexing Players Horizontally</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>