<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A Crash Course on Advanced DLIs Atari 8-bit Display List Interrupts: An Advanced Tutorial
Revision 1, updated 3 Dec 2019
This is a tutorial on advanced Display List Interrupts (DLIs) for the Atari 8-bit series of computers. In a nutshell, DLIs provide a way to notify your program when a particular scan line is reached, allowing you to make changes mid-screen.
DLIs are an advanced programming technique in the sense that they require knowledge of 6502 assembly language, so this tutorial is going to assume that you are comfortable with that."><title>Atari 8-Bit Display List Interrupts: An Advanced Tutorial</title><link rel=canonical href=https://Nexus-Security.github.io/posts/2016-09-09-atari-8-bit-display-list-interrupts/><link rel=stylesheet href=/scss/style.min.450926226e724574a6b936335ea06111f8aeb253d932c86cb2cc807341cd2889.css><meta property="og:title" content="Atari 8-Bit Display List Interrupts: An Advanced Tutorial"><meta property="og:description" content="A Crash Course on Advanced DLIs Atari 8-bit Display List Interrupts: An Advanced Tutorial
Revision 1, updated 3 Dec 2019
This is a tutorial on advanced Display List Interrupts (DLIs) for the Atari 8-bit series of computers. In a nutshell, DLIs provide a way to notify your program when a particular scan line is reached, allowing you to make changes mid-screen.
DLIs are an advanced programming technique in the sense that they require knowledge of 6502 assembly language, so this tutorial is going to assume that you are comfortable with that."><meta property="og:url" content="https://Nexus-Security.github.io/posts/2016-09-09-atari-8-bit-display-list-interrupts/"><meta property="og:site_name" content="ZYChimne"><meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:published_time" content="2019-12-05T04:01:00+01:00"><meta property="article:modified_time" content="2019-12-05T04:01:00+01:00"><meta name=twitter:title content="Atari 8-Bit Display List Interrupts: An Advanced Tutorial"><meta name=twitter:description content="A Crash Course on Advanced DLIs Atari 8-bit Display List Interrupts: An Advanced Tutorial
Revision 1, updated 3 Dec 2019
This is a tutorial on advanced Display List Interrupts (DLIs) for the Atari 8-bit series of computers. In a nutshell, DLIs provide a way to notify your program when a particular scan line is reached, allowing you to make changes mid-screen.
DLIs are an advanced programming technique in the sense that they require knowledge of 6502 assembly language, so this tutorial is going to assume that you are comfortable with that."></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu8b78332b6420dc9affabe23720d11e63_1937019_300x0_resize_q75_box.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a>
<span class=emoji>üçá</span></figure><div class=site-meta><h1 class=site-name><a href=/>ZYChimne</a></h1><h2 class=site-description>Computer Science, Wuhan University</h2></div></header><ol class=social-menu><li><a href=https://github.com/ZYChimne target=_blank title=GitHub><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com/ZChimne target=_blank title=Twitter><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/about-me/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>About Me</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></div></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/posts/2016-09-09-atari-8-bit-display-list-interrupts/>Atari 8-Bit Display List Interrupts: An Advanced Tutorial</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Dec 05, 2019</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>43 minute read</time></div></footer></div></header><section class=article-content><h1 id=a-crash-course-on-advanced-dlis>A Crash Course on Advanced DLIs</h1><p><strong><strong>Atari 8-bit Display List Interrupts: An Advanced Tutorial</strong></strong></p><p><strong>Revision 1, updated 3 Dec 2019</strong></p><p>This is a tutorial on advanced Display List Interrupts (DLIs) for the Atari 8-bit series of computers. In a nutshell, DLIs provide a way to notify your program when a particular scan line is reached, allowing you to make changes mid-screen.</p><p>DLIs are an advanced programming technique in the sense that they require knowledge of 6502 assembly language, so this tutorial is going to assume that you are comfortable with that. All the examples here are assembled using the MAC/65-compatible assembler <a class=link href=https://atari.miribilist.com/atasm/index.html target=_blank rel=noopener>ATasm</a> (and more specifically to this tutorial, the version built-in to <a class=link href=https://github.com/robmcmullen/omnivore target=_blank rel=noopener>Omnivore</a>).</p><p>Before diving into DLIs, it is helpful to understand that they are very accurately named: Display List Interrupts literally interrupt the display list ‚Äì they cause an event that is processed by your program while the ANTIC is drawing the screen. So it is necessary to understand what display lists are before understanding what it means to interrupt one.</p><p>See also</p><p>Here are some resources for learning more about display list interrupts:</p><h2 id=a-crash-course-on-displays>A Crash Course on Displays</h2><p>A TV screen is drawn by an electron beam tracing a path starting above the visible area, and drawing successive horizontal lines as the beam moves down the screen. Each line is drawn from left-to-right (as you look at the TV screen) and when it reaches the right hand side of the screen, the horizontal retrace starts where the beam is turned off and moved down to the next scan line below whereupon the beam is turned back on and the next line draws. When the full frame has been drawn, the beam is turned off again and the vertical retrace starts (starting the vertical blank interval). Once the beam is repositioned to the top leftmost position, the vertical blank interval ends, the beam is turned back on, and the next frame is started.</p><p>On NTSC systems, the Atari draws 262 scan lines per frame, 60 times per second. On PAL systems it draws 312 scan lines per frame, 50 times per second. In either system, it draws scan lines from the top down, and left to right within a scan line.</p><p>This simplified description is the mental model we will use to describe the video drawing process.</p><h3 id=how-interlacing-works-with-some-hand-waving-and-why-we-ignore-it>How Interlacing Works (With Some Hand Waving) and Why We Ignore It</h3><p>Real TVs are interlaced with 525 scan lines for NTSC and 625 for PAL. Because of <a class=link href=https://en.wikipedia.org/wiki/NTSC#Lines_and_refresh_rate target=_blank rel=noopener>reasons</a>, the NTSC vertical refresh interval is not exactly the whole number of 60Hz either, it‚Äôs 60/1001 Hz or 59.94Hz. PAL refresh rate is apparently <a class=link href=http://martin.hinner.info/vga/pal.html target=_blank rel=noopener>exactly 50Hz</a>.</p><p>Every refresh interval, the electron beam draws one <strong>field</strong>, starting at the top left and drawing every other scan line. When it reaches the bottom, the vertical retrace starts, but this time it positions the electron beam at the first missing scan line. Then it draws the next field, again skipping every other scan line but this time filling in the scan lines it missed.</p><p><img src=https://playermissile.com/_images/electron-beam-interlaced.png loading=lazy alt=../_images/electron-beam-interlaced.png></p><p>This drawing is a simplification, seeming to show that there are 524 scan lines. In reality, and there are 525 and each field actually draws 262 <strong>and one half</strong> scan lines (and not 262 on one field and 263 on another), but this is all very complicated and not necessary for our purposes. However, at the risk of further complicating matters, the Atari produces 262 scan lines for the even field and 262 scan lines for the odd field. In the situation where the Atari is producing an image that is not changing as time goes on, like the computer is sitting at the BASIC language READY prompt and you aren‚Äôt typing anything, the scan lines produced for the even field will be exactly the same as the scan lines produced for the odd field.</p><p>Practically speaking, you do not need to care that the screen is interlaced with 525 scan lines (for NTSC). Our mental model will be as if the Atari is drawing to a non-interlaced screen with 262 scan lines and a frame rate of 59.94Hz. (For PAL, substitute 625, 312, and 50, respectively.)</p><h3 id=how-color-works-and-theres-more-hand-waving-isnt-there>How Color Works and There‚Äôs More Hand Waving, Isn‚Äôt There?</h3><p>How TVs produce the colors that they display is very complicated and so far outside the scope of this tutorial that it might as well be magic. Suffice it to say that color happens.</p><p>On the Atari, a unit called the color clock is the smallest portion of a scan line that can be displayed with an arbitrary color. There are 228 color clocks per scan line, of which about 160 were typically visible on a cathode-ray TV display in the 1970s when the Atari was developed. This corresponds to the 160 pixel horizontal resolution of Antic Modes B through E in the standard width playfield. Antic Mode F (Graphics 8 in BASIC) has 320 addressable pixels, corresponding to half a color clock, and only artifacting color is available.</p><h3 id=how-the-cpu-frequency-was-chosen-and-why-is-there-even-more-hand-waving-oh-author-person>How The CPU Frequency Was Chosen and Why Is There Even More Hand Waving, Oh Author Person?</h3><p>For NTSC machines, each frame draws 262 scan lines with 228 color clocks per scan line, the operating frequency of the 6502 was chosen such that it takes exactly 114 machine cycles per scan line, producing 29868 machine cycles per frame. With a 59.94Hz vertical refresh rate this should result in a processor speed of 1.790287MHz. Here‚Äôs where the author does more hand waving because he doesn‚Äôt exactly understand what the subtleties are and why those numbers aren‚Äôt exact, and instead points to the Altirra Hardware Reference Manual and lets it explain what is really happening. It shows that while there <em>are</em> indeed 29868 cycles per frame, the processor speed is actually 1.790772MHz, to prevent the color subprime mortgage from investigating phantoms on each scan line. Something like that; the author didn‚Äôt understand. <em>At all</em>. At any rate, a signal is produced that can be displayed on a TV, even if it does not exactly sync up with broadcast NTSC signals.</p><p>PAL systems produce the same 228 color clocks and 114 machine cycles per line, but display 312 scan lines. This results in 35568 cycles per frame, and with the vertical refresh rate of 50Hz the processor should run at 1.778400MHz. Again, the Altirra reference manual shows slight deviations for complicated technical reasons resulting in a processor speed of 1.773447MHz. Similarly to NTSC, the computer still produces 35568 cycles per frame, just that the signal output for the TV is not exactly the same as broadcast PAL TV signals.</p><h2 id=a-crash-course-on-display-lists>A Crash Course on Display Lists</h2><p>ANTIC is the special coprocessor that handles screen drawing for the Atari computers. It is tightly coupled with the 6502 processor, and in fact can be thought of as being the driver of the 6502 because the ANTIC can halt the 6502 when needed. Since only one chip can read memory at any time, ANTIC needs to halt the 6502 when it needs access to memory, so this Direct Memory Access (DMA) can cause 6502 instructions to appear to take more cycles than documented in a 6502 reference. In fact, the amount of time ANTIC ‚Äústeals‚Äù will depend on many factors: the graphics mode, player/missiles being used, playfield size, and more.</p><p>Since there are 228 color clocks and 114 machine cycles per scan line, this means that in one machine cycle, two color clocks are drawn on the screen. A typical machine instruction might take 5 machine cycles, so 10 color clocks could pass in the time to process a single instruction! This means we don‚Äôt have much time per scan line, so DLIs that attempt to change graphics in the middle of a line will have to be well optimized.</p><p>It also means the 6502 is too slow to draw the screen itself, and this is where ANTIC‚Äôs special ‚Äúinstruction set‚Äù comes in. You program the ANTIC coprocessor using a display list, and ANTIC takes care of building the screen scan line by scan line, without any more intervention from the 6502 code. (Unless you ask for intervention! And that‚Äôs what a DLI is.)</p><p>The display list is the special sequence of bytes that ANTIC interprets as a list of instruction. Each instruction causes ANTIC to draw a certain number of scan lines in a particular way. A DLI can be set on any ANTIC instruction.</p><p>ANTIC supports display lists that produce at most 240 scan lines (even on PAL systems where many more scan lines are available), and the vertical blank interval always starts after 248 scan lines. When drawing scan lines, ANTIC skips 8 scan lines at to top of the display, so the output from the display list starts at the 9th scan line. A standard display list starts with 24 blank lines and 192 scan lines of display data, meaning that the TV will see 32 blank lines (the 8 automatically skipped plus the 24 in a standard display list) followed by 192 scan lines of display, then 24 blank lines, and finally the vertical blank that consumes the remaining 14 scan lines on NTSC (or 64 on PAL).</p><h3 id=display-list-instruction-set>Display List Instruction Set</h3><p>An ANTIC display list instruction consists of 1 byte with an optional 2 byte address. There are 3 types of instructions: blank lines, graphics modes, and jump instructions. Instructions are encoded into the byte using a bitmask where low 4 bits encode the graphics mode or feature and the high 4 bits encode the flags that affect that instruction:</p><blockquote><p>7</p><p>6</p><p>5</p><p>4</p><p>3</p><p>2</p><p>1</p><p>0</p><p>DLI</p><p>LMS</p><p>VSCROLL</p><p>HSCROLL</p><p>Mode</p></blockquote><p>The 4 flags are:</p><blockquote><ul><li><p>DLI (<code>$80</code>): enable a display list interrupt when processing this instruction</p></li><li><p>LMS (<code>$40</code>): trigger a Load Memory Scan, changing where ANTIC looks for screen data, and requires an additional 2 byte address immediately following this instruction byte.</p></li><li><p>VSCROLL (<code>$20</code>): enable vertical scrolling for this mode line</p></li><li><p>HSCROLL (<code>$10</code>): enable horizontal scrolling for this mode line</p></li></ul></blockquote><p>The 14 available graphics modes are encoded into low 4 bits using values as shown in this table:</p><p>Mode</p><p>Decimal</p><p>BASIC Mode</p><p>Description</p><p>Scan Lines</p><p>Type</p><p>Colors</p><p>2</p><p>02</p><p>0</p><p>40 x 24</p><p>8</p><p>text</p><p>2</p><p>3</p><p>03</p><p>n/a</p><p>40 x 19</p><p>10</p><p>text</p><p>2</p><p>4</p><p>04</p><p>n/a</p><p>40 x 24</p><p>8</p><p>text</p><p>4</p><p>5</p><p>05</p><p>n/a</p><p>40 x 12</p><p>16</p><p>text</p><p>4</p><p>6</p><p>06</p><p>1</p><p>20 x 24</p><p>8</p><p>text</p><p>5</p><p>7</p><p>07</p><p>2</p><p>20 x 12</p><p>16</p><p>text</p><p>5</p><p>8</p><p>08</p><p>3</p><p>40 x 24</p><p>8</p><p>bitmap</p><p>4</p><p>9</p><p>09</p><p>4</p><p>80 x 48</p><p>4</p><p>bitmap</p><p>2</p><p>A</p><p>10</p><p>5</p><p>80 x 48</p><p>4</p><p>bitmap</p><p>4</p><p>B</p><p>11</p><p>6</p><p>160 x 96</p><p>2</p><p>bitmap</p><p>2</p><p>C</p><p>12</p><p>n/a</p><p>160 x 192</p><p>1</p><p>bitmap</p><p>2</p><p>D</p><p>13</p><p>7</p><p>160 x 96</p><p>2</p><p>bitmap</p><p>4</p><p>E</p><p>14</p><p>n/a</p><p>160 x 192</p><p>1</p><p>bitmap</p><p>4</p><p>F</p><p>15</p><p>8</p><p>320 x 192</p><p>1</p><p>bitmap*</p><p>2</p><p><a class=link href=https://playermissile.com/dli_tutorial/#id1 target=_blank rel=noopener>*</a>mode F is also used as the basis for the GTIA modes (BASIC Graphics modes 9, 10, & 11), but this is a topic outside the scope of this tutorial.</p><p>Blank lines are encoded as a mode value of zero, the bits 6, 5, and 4 taking the meaning of the number of blank lines rather than LMS, VSCROLL, and HSCROLL. Note that the DLI bit is still available on blank lines, as bit 7 is not co-opted by the blank line instruction.</p><p>Blank Line Instructions</p><p>Hex</p><p>Decimal</p><p>Blank Lines</p><p>0</p><p>0</p><p>1</p><p>10</p><p>16</p><p>2</p><p>20</p><p>32</p><p>3</p><p>30</p><p>48</p><p>4</p><p>40</p><p>64</p><p>5</p><p>50</p><p>80</p><p>6</p><p>60</p><p>96</p><p>7</p><p>70</p><p>112</p><p>8</p><p>Jumps provide the capability to split a display list into multiple parts in different memory locations. They are encoded using a mode value of one, and require an additional 2 byte address where ANTIC will look for the next display list instruction. If bit 6 is also set, it becomes the Jump and wait for Vertical Blank (JVB) instruction, which is how ANTIC knows that the display list is finished. The DLI bit may also be set on a jump instruction, but if set on the JVB instruction it triggers a DLI on every scan line from there until the vertical blank starts on the 249th scan line.</p><p>Note</p><p>Apart from the <code>$41</code> JVB instruction, splitting display lists using other jumps like the <code>$01</code> instruction is not common. It has a side-effect of producing a single blank line in the display list.</p><p>The typical method to change the currently active display list is to change the address stored at <code>SDLSTL</code> (in low byte/high byte format in addresses <code>$230</code> and <code>$231</code>). At the next vertical blank, the hardware display list at <code>DLISTL</code> (<code>$d402</code> and <code>$d403</code>) will be updated with the values stored here and the screen drawing will commence using the new display list.</p><p>See also</p><p>More resources about display lists are available:</p><h3 id=a-sample-display-list>A Sample Display List</h3><p>Here is a display list that contains different text modes mixed in a single screen.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>dlist .byte $70,$70,$70 ; 24 blank lines .byte $46,$00,$40 ; Mode 6 + LMS, setting screen memory to $4000 .byte 6 ; Mode 6 .byte $70 ; 8 blank lines .byte 7,7,7,7,7 ; 5 lines of Mode 7 .byte $70 ; 8 blank lines .byte 2 ; single line of Mode 2 .byte $70,$70,$70 ; 24 blank lines .byte 2,4 ; Mode 2 followed by mode 4 .byte $70 ; 8 blank lines .byte 2,5 ; Mode 2 followed by mode 5 .byte $41,&lt;dlist,\&gt;dlist ; JVB, restart same display list on next frame 
</span></span></code></pre></td></tr></table></div></div><h3 id=cycle-stealing-by-antic>Cycle Stealing by ANTIC</h3><p>The ANTIC coprocessor needs to access memory to perform its functions, and since the 6502 and ANTIC can‚Äôt both access at once, ANTIC will pause execution of the 6502 when it needs to read memory. It happens at specific points within the 114 cycles of each scan line, but where it happens (and how many times the 6502 gets paused during the scan line) depends on the graphics mode.</p><p>For overhead, ANTIC will typically steal 3 cycles to read the display list, 5 cycles if player/missile graphics are enabled, and 9 cycles for memory refreshing. Scrolling requires additional cycle stealing because ANTIC needs to fetch more memory.</p><p>Bitmapped modes (modes 8 - F) have cycles stolen corresponding to the number of bytes per line used in that mode. For example, mode E will use an additional 40 cycles, so in the context of writing a DLI for a game, the typical number of stolen cycles could be 57 out of the 114 cycles per scan line: 17 cycles for ANTIC overhead and 40 for the number of bytes per line.</p><p>Text modes require additional cycles over bitmapped graphics modes, because ANTIC must fetch the font glyphs in addition to its other work. The first scan line of a font mode is almost entirely used by ANTIC and only a small number of cycles is available to the 6502. For normal 40-byte wide playfields, the first line of ANTIC modes 2 through 5 will yield at most about 30 cycles and subsequent lines about 60 cycles per scan line.</p><p>About the worst-case scenario is one of the best modes for games: ANTIC mode 4. This text mode, combined with scrolling and player/missile graphics and can reduce the available cycles to fewer than 10 on the first line and about 50 on subsequent lines!</p><h2 id=a-crash-course-on-display-list-interrupts>A Crash Course on Display List Interrupts</h2><p>DLIs are non-maskable interrupts (NMIs), meaning they cannot be ignored. When an NMI occurs, the 6502 jumps to the address stored at <code>$fffa</code>, which points to an OS routine that checks the type of interrupt (either a DLI or a VBI) and vectors through the appropriate user vector. The NMI handler takes care of saving the processor status register and sets the interrupt flag, but <em>does not</em> save any processor registers. The user routine is responsible for saving any registers that it uses, restoring them when it is done using them, and must exit using the <code>RTI</code> instruction.</p><p>Display list interrupts are not enabled by default. To use a DLI, the address vector at <code>VDLSLT</code> (<code>$200</code> and <code>$201</code>) must be set to your routine, and then they must be enabled through a write to <code>NMIEN</code> at <code>$d40e</code>.</p><p>Warning</p><p>You must set the address of your DLI before enabling them, otherwise the DLI could be called and use whatever address is stored at <code>$200</code>.</p><p>This initialization code can look like the following, where the constants <code>NMIEN_VBI</code> and <code>NMIEN_DLI</code> are defined as <code>$40</code> and <code>$80</code>, respectively, in hardware.s in the sample repository. Since <code>NMIEN</code> also controls the vertical blank interrupt, you must make sure that the VBI enable flag is also set.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>; load display list interrupt address lda #&lt;dli sta VDSLST lda #\&gt;dli sta VDSLST+1 ; activate display list interrupt and vertical blank interrupt lda #NMIEN\_DLI | NMIEN\_VBI sta NMIEN 
</span></span></code></pre></td></tr></table></div></div><p>If your program has multiple DLIs, it may be necessary to set your DLIs in a vertical blank interrupt to guarantee that ANTIC will process them in the right order. Outside the VBI, your code could be running at an arbitrary scan line, perhaps between display list instructions that have their DLI bits set. In Yaron Nir‚Äôs tutorial a different technique is used, one not requiring a vertical blank interrupt but instead using the <code>RTCLOK</code> 3-byte zero page variable to instead infer that a VBI has <em>just</em> occurred. The last of the bytes, location <code>$14</code>, is incremented every vertical blank, so that technique is to wait until location <code>$14</code> changes, then set <code>NMIEN</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> lda RTCLOK+2 ?loop cmp RTCLOK+2 ; will be equal until incremented in VB beq ?loop ; activate display list interrupt and vertical blank interrupt lda #NMIEN\_DLI | NMIEN\_VBI sta NMIEN 
</span></span></code></pre></td></tr></table></div></div><h3 id=hardware--shadow-registers>Hardware & Shadow Registers</h3><p>The Atari is a memory-mapped system, where hardware devices like the ANTIC and GTIA chips are <em>mapped</em> to locations in memory and data is passed back and forth by reading or writing to specific addresses. They are usually either read-only or write-only, and many times an address is used for wildly different features depending on whether the address is read from or written to.</p><p>Some of these hardware locations also have <em>shadow</em> registers in low RAM (typically page 2) that are labeled as performing the same function as a hardware register, with two important differences.</p><p>First, they can be both read and written to, so (assuming you always use the shadow register to update the hardware register) it is possible to find out the current state of a hardware register by reading its shadow.</p><p>Second, the hardware register is only updated <strong>once every vertical blank</strong> by an operating system routine that copies the shadow value to its hardware counterpart. Note that it does not happen the other way around, so changing a hardware register <em>does not</em> update a shadow register.</p><p>The shadow registers are a convenience for development in higher level languages like BASIC where speed is not paramount. But code within a DLI must use hardware registers directly to affect change on a scan line.</p><p>The shadow registers can still be useful in DLI development, in that they will automatically reset the hardware registers to the values in the shadow registers every vertical blank. This can be used to reset features like graphics colors and the character set address for the top of the screen at the next frame.</p><p>Note</p><p>This only works if the operating system‚Äôs immediate vertical blank routine has not been replaced (i.e. you are only using the deferred vertical blank <code>VVBLKD</code> at <code>$224</code> and haven‚Äôt replaced the immediate vertical blank rountine <code>VVBLKI</code> at <code>$222</code>).</p><p>Some hardware registers have no shadows, like player position and size, so your own code (in the deferred VBI or the final DLI) must reset these to their correct values for the top of the screen.</p><p>Some Useful Shadow Registers</p><p>Shadow</p><p>Hex</p><p>Hardware</p><p>Hex</p><p>Description</p><p>GPRIOR</p><p>26f</p><p>PRIOR</p><p>d01b</p><p>Player/playfield priority selection register</p><p>PCOLR0</p><p>2c0</p><p>COLPM0</p><p>d012</p><p>Color of player/missile 0</p><p>PCOLR1</p><p>2c1</p><p>COLPM1</p><p>d013</p><p>Color of player/missile 1</p><p>PCOLR2</p><p>2c2</p><p>COLPM2</p><p>d014</p><p>Color of player/missile 2</p><p>PCOLR3</p><p>2c3</p><p>COLPM3</p><p>d015</p><p>Color of player/missile 3</p><p>COLOR0</p><p>2c4</p><p>COLPF0</p><p>d016</p><p>Color of playfield 0</p><p>COLOR1</p><p>2c5</p><p>COLPF1</p><p>d017</p><p>Color of playfield 1</p><p>COLOR2</p><p>2c6</p><p>COLPF2</p><p>d018</p><p>Color of playfield 2</p><p>COLOR3</p><p>2c7</p><p>COLPF3</p><p>d019</p><p>Color of playfield 3</p><p>COLOR4</p><p>2c8</p><p>COLBK</p><p>d01a</p><p>Background color</p><p>CHACT</p><p>2f3</p><p>CHACTL</p><p>d401</p><p>Character mode (inverse, upside-down characters)</p><p>CHBAS</p><p>2f4</p><p>CHBASE</p><p>d409</p><p>Character base (page number of font)</p><h3 id=a-simple-example>A Simple Example</h3><p>A common use of display lists is to change colors in the middle of the screen.</p><p>Here is our first display list interrupt:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>dli pha ; only using A register, so save old value to the stack lda #$7a ; new background color sta COLBK ; store it in the hardware register pla ; restore the A register rti ; always end DLI with RTI! 
</span></span></code></pre></td></tr></table></div></div><p>This is all the code it takes to change the color of the background. The obvious effect is the flickering line in the background, which we will solve in the next section.</p><p>Examining the code shows the boilerplate discussed <a class=link href=https://playermissile.com/dli_tutorial/#a-crash-course-on-display-list-interrupts target=_blank rel=noopener>above</a> where DLIs always end with the <code>RTI</code> instruction and any registers used must be saved before your code changes them, and restored upon exit.</p><p>The work performed in the interrupt is just two instructions: a load of a color value and a store where it puts it in the <em>hardware</em> register for the background color. Again, as noted <a class=link href=https://playermissile.com/dli_tutorial/#hardware-shadow-registers target=_blank rel=noopener>above</a>, hardware registers must be used in DLIs, not the shadow registers as shadow registers are ignored until the vertical blank.</p><h3 id=a-simple-example-with-wsync>A Simple Example with WSYNC</h3><p>The Atari provides a way to sync with a scan line to avoid the flickering effect of the previous example.</p><p>The flickering is avoided by saving some value (any value, the bit pattern is not important) to the <code>WSYNC</code> memory location at <code>$d40a</code>. This causes the 6502 to stop processing instructions until the electron beam nears the end of the scan line, at which point the 6502 will resume executing instructions. Because the electron beam is usually off-screen at this point, it is safe to change color registers for at least the next several instructions without artifacts appearing on screen.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>dli pha ; only using A register, so save old value to the stack lda #$7a ; new background color sta WSYNC ; any value saved to WSYNC will trigger the pause sta COLBK ; store it in the hardware register pla ; restore the A register rti ; always end DLI with RTI! 
</span></span></code></pre></td></tr></table></div></div><p>Note</p><p><code>WSYNC</code> (wait for horizontal blank) usually restarts the 6502 on or about cycle 105 out of 114, but there are cases that can delay that. See the Altirra Hardware Reference Manual for more information.</p><h3 id=a-dli-can-affect-many-scan-lines>A DLI Can Affect Many Scan Lines</h3><p>DLIs can really be thought of as a way for your program to be told when a certain display list instruction is reached. Apart from the setup and teardown of the DLI subroutine itself and some timing limitations discussed in the next section, arbitrary amounts of code can be executed in a DLI.</p><p>Note</p><p>Author‚Äôs note: thinking that DLIs had to be short was a great source of confusion to me when trying to figure out how rainbow effects were generated. My thinking was that DLIs could only affect a single line, and for instance I could not figure out how to get a color change in the middle of a text mode. I don‚Äôt know why I thought that something bad would happen if a DLI went long, but I did.</p><p>This example shows how to have a single DLI affect multiple scan lines, even crossing into subsequent ANTIC mode 4 lines in the display list:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>dli pha ; save A &amp; X registers to stack txa pha ldx #16 ; make 16 color changes lda #$a ; initial color sta WSYNC ; first WSYNC gets us to start of scan line we want ?loop sta COLBK ; change background color clc adc #$11 ; change color value, luminance remains the same dex ; update iteration count sta WSYNC ; make it the color change last ... sta WSYNC ; for two scan lines bne ?loop ; sta doesn&#39;t affect flags so this still checks result of dex lda #$00 ; reset background color to black sta COLBK pla ; restore X &amp; A registers from stack tax pla rti ; always end DLI with RTI! 
</span></span></code></pre></td></tr></table></div></div><p>It changes background colors 16 times, where each color change lasts 2 scan lines. So 32 scan lines means that it covers 4 display list entries of ANTIC mode 4.</p><h2 id=a-crash-course-on-display-list-interrupts-getting-interrupted>A Crash Course on Display List Interrupts Getting Interrupted</h2><blockquote><ul><li><p>DLIs can be interrupted by other DLIs</p></li><li><p>DLIs can be interrupted by the vertical blank</p></li><li><p>a DLI on a JVB instruction will cause interrupts on every scan line until the vertical blank</p></li></ul></blockquote><h3 id=dli-interrupting-another-dli>DLI Interrupting Another DLI</h3><p>When a DLI is interrupted, its state is saved just as if a normal program was interrupted. The interrupting code is then executed, and upon its completion, the control returns to the DLI at the point where it left off. But at this point, due to the interrupting event, the restored DLI will be resumed some number of scan lines below where it was interrupted, likely resulting in unplanned behavior.</p><p>Here‚Äôs a similar DLI to the above, except it changes the luminance value instead of the color value to make the effect easier to see. It starts with a bright pink and gets dimmer down to a dark red after 32 scan lines:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>dli pha ; save A &amp; X registers to stack txa pha ldx #16 ; make 16 color changes lda #$5f ; initial bright pink color sta WSYNC ; first WSYNC gets us to start of scan line we want ?loop sta COLBK ; change background color sec sbc #1 ; make dimmer by decrementing luminance value dex ; update iteration count sta WSYNC ; make it the color change last ... sta WSYNC ; for two scan lines bne ?loop ; sta doesn&#39;t affect processor flags so we are still checking result of dex lda #$00 ; reset background color to black sta COLBK pla ; restore X &amp; A registers from stack tax pla rti ; always end DLI with RTI! 
</span></span></code></pre></td></tr></table></div></div><p>But this time, the display list has <em>two</em> lines that have the DLI bit set:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>dlist .byte $70,$70,$70 .byte $44,$00,$40 .byte $c4 ; first DLI triggered on last scan line .byte $44 .byte $c4 ; second DLI triggered on last scan line .byte $44,$44,$44,$44,$44,$44,$44,$44 .byte $44,$44,$44,$44,$44,$44,$44,$44 .byte $44,$44,$44,$44 .byte $41,&lt;dlist,\&gt;dlist 
</span></span></code></pre></td></tr></table></div></div><p>Because the <code>VDLSTL</code> pointer is not changed, the same code will be called each time an interrupt occurs.</p><p>The first DLI hits and starts with a bright background color on the first scan line of the third line of text. But because this display list takes a long time, the second DLI on the 4th text line gets triggered before the first DLI has hit its <code>RTI</code> instruction. ANTIC interrupts the first DLI and starts the 2nd DLI anyway. This effect is visible in the 5th line of text: the background color is bright again.</p><p>But notice another artifact: the effect on the 5th line of text isn‚Äôt on its first scan line, but its second:</p><p>This is due to the fact that a WSYNC was called on the previous scan line, but the interrupt happened as well. The interrupt takes some cycles to begin, and by the time that happened <strong>and</strong> ANTIC stole all of its cycles to set up the text mode line, there weren‚Äôt enough cycles left for the first <code>WSYNC</code> in the DLI code to happen on the same scan line. This forces that <code>WSYNC</code> to happen on the next line, causing the delay and the appearance of a 3rd scan line of the same color before the second DLI starts its color cycling.</p><p>The second DLI completes and performs its <code>RTI</code>, but then it returns control to the first DLI, which is already halfway done with its color cycling. When it resumes control, it is in 9th line of text on the screen, so it has four more color changes before it hits its own <code>RTI</code>.</p><h3 id=emulator-differences>Emulator Differences</h3><p>The DLI interrupting another DLI is clearly an edge case, and edge cases are always good stress tests for emulators. A difference is clearly visible below when comparing a zoomed in portion of the display generated by the Altirra emulator as compared to the atari800 emulator (standalone or as embedded in Omnivore, they are the same code and produce the same result):</p><p><img src=https://playermissile.com/_images/emulator-differences.png loading=lazy alt=../_images/emulator-differences.png></p><p>Notice how Altirra gets the color from the first DLI for two scan lines, 64 and 65, before the correct color appears on scan line 66. The output from Altirra shows that the NMI doesn‚Äôt happen until between scan line 63 and 64. But clearly, the <code>sta COLBK</code> at scan line 63 is taking effect on scan line 64, because scan line 64 has the background color <code>$57</code>. It appears the store of <code>$5f</code> on scan line 65, started on cycle 1 of that line, isn‚Äôt actually executed until much, much later since the <code>sec</code> doesn‚Äôt begin until cycle 108. This puts that color change in the horizontal blank period of scan line 65, which would seem to explain why Altirra shows two scan lines with the background color from the first DLI.</p><p>This is the CPU history from the Altirra emulator:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> 60: 3 | A=58 X=09 Y=00 ( I C) | 3030: 8D 0A D4 STA WSYNC 60: 7 | A=58 X=09 Y=00 ( I C) | 3033: 8D 0A D4 STA WSYNC 60:108 | A=58 X=09 Y=00 ( I C) | 3036: D0 F1 BNE $3029 61:107 | A=58 X=09 Y=00 ( I C) | 3029: 8D 1A D0 L3029 STA COLBK 61:111 | A=58 X=09 Y=00 ( I C) | 302C: 38 SEC 61:113 | A=58 X=09 Y=00 ( I C) | 302D: E9 01 SBC #$01 62: 1 | A=57 X=09 Y=00 ( I C) | 302F: CA DEX 62: 3 | A=57 X=08 Y=00 ( I C) | 3030: 8D 0A D4 STA WSYNC 62: 7 | A=57 X=08 Y=00 ( I C) | 3033: 8D 0A D4 STA WSYNC 62:108 | A=57 X=08 Y=00 ( I C) | 3036: D0 F1 BNE $3029 63:107 | A=57 X=08 Y=00 ( I C) | 3029: 8D 1A D0 L3029 STA COLBK - NMI interrupt (DLI) 64: 5 | A=57 X=08 Y=00 ( I C) | E791: 2C 0F D4 LE791 BIT NMIST 64: 11 | A=57 X=08 Y=00 (N I C) | E794: 10 03 BPL $E799 64: 13 | A=57 X=08 Y=00 (N I C) | E796: 6C 00 02 JMP (VDSLST) 64: 19 | A=57 X=08 Y=00 (N I C) | 301F: 48 PHA 64:102 | A=57 X=08 Y=00 (N I C) | 3020: 8A TXA 64:104 | A=08 X=08 Y=00 ( I C) | 3021: 48 PHA 64:107 | A=08 X=08 Y=00 ( I C) | 3022: A2 10 LDX #$10 64:109 | A=08 X=10 Y=00 ( I C) | 3024: A9 5F LDA #$5F 64:111 | A=5F X=10 Y=00 ( I C) | 3026: 8D 0A D4 STA WSYNC 65: 1 | A=5F X=10 Y=00 ( I C) | 3029: 8D 1A D0 L3029 STA COLBK 65:108 | A=5F X=10 Y=00 ( I C) | 302C: 38 SEC 65:110 | A=5F X=10 Y=00 ( I C) | 302D: E9 01 SBC #$01 65:112 | A=5E X=10 Y=00 ( I C) | 302F: CA DEX 66: 0 | A=5E X=0F Y=00 ( I C) | 3030: 8D 0A D4 STA WSYNC 66: 4 | A=5E X=0F Y=00 ( I C) | 3033: 8D 0A D4 STA WSYNC 66:108 | A=5E X=0F Y=00 ( I C) | 3036: D0 F1 BNE $3029 67:107 | A=5E X=0F Y=00 ( I C) | 3029: 8D 1A D0 L3029 STA COLBK 
</span></span></code></pre></td></tr></table></div></div><p>The atari800 emulator hits the DLI two instructions earlier than Altirra, immediately after the two <code>sta WSYNC</code> commands (and therefore before the <code>sta COLBK</code> that causes Altirra to have a new color on scan line 64). In the atari800/Omnivore instruction history below:</p><p>the DLI starts late on scan line 63 as (naively) expected and gets to the <code>sta WSYNC</code> early in scan line 64 while there is still time to hit the <code>sta COLBK</code> while still on scan line 64. This changes scan line 65 to be the correct background color for the second DLI.</p><p>Note</p><p>I‚Äôm not sure what‚Äôs going on with the differences in the WSYNC behavior between the two emulators. On Altirra, the two WSYNC commands seem to occur on scan line 62, but their effects aren‚Äôt felt immediately, so perhaps this is what‚Äôs causing the DLI to hit on scan line 64 instead of scan line 63. On atari800, the WSYNC commands cause their effects to be felt immediately, in the next command. I would presume that Altirra is closer to what‚Äôs going on with real hardware, as the author of Altirra has written the definitive guide to the internals of the machine, and Altirra has always been the leader in cycle-exact emulation.</p><p>I think the takeaway from this section is: don‚Äôt let your DLI get interrupted by anything else, or it is likely that you will encounter emulation differences.</p><h3 id=vbi-interrupting-a-dli>VBI Interrupting A DLI</h3><p>For completeness, here is an example of the vertical blank interrupting a DLI.</p><p>The DLI is started at the bottom of the screen, gets interrupted by the VBI, and picks up again when VBI ends. Even though the electron beam is turned off, <code>WSYNC</code> is still called and performs its delay function when the scan line is off screen. The resulting image resumes its color cycling background on the top of the screen, stopping after 128 scan lines even though only a fraction of those are actually visible on screen.</p><h3 id=dli-on-the-jvb-instruction>DLI on the JVB Instruction</h3><p>A DLI on the JVB instruction at the end of the display list is possible, but has an interesting property: it triggers DLIs on every scan line until the vertical blank.</p><p>If your DLI is not short enough, it will keep getting interrupted by the DLI on triggered by the next scan line, stacking up interrupts until mercifully the triggering process is stopped by the vertical blank after 248 scan lines have been generated.</p><p>Note</p><p>As each new frame is generated in an emulator, it will enumerate the scan lines starting from zero. There are 248 scan lines before the vertical blank, which will be displayed as scan lines 0 - 247. The scan line labeled 248 will be the first scan line of the vertical blank.</p><p>After the vertical blank routine exits, the stacked-up DLI calls will have to unwind themselves so the most recently interrupted DLI (from scan line 247, the scan line just before the vertical blank) will resume and execute code until its <code>RTI</code>. This will pop data off the stack and return control to the DLI that was interrupted on scan line 246, and so-forth until all the interrupted DLIs have issued their <code>RTI</code> instructions.</p><p>On a standard length display list that generates 24 blank lines followed by 192 output lines, the JVB instruction will be on scan line 224. Since the JVB technically generates a single blank line in the display list, the DLI will also be triggered on scan line 224. This case would produce 24 DLIs before the vertical blank.</p><h2 id=dlis-in-a-nutshell>DLIs in a Nutshell</h2><p>DLIs provide you with a way to notify your program at a particular vertical location on the screen. They pause (or interrupt) the normal flow of program code, save the state of the machine, call your DLI subroutine, and restore the state of the computer before returning control to the code that was interrupted.</p><p>Warning</p><p>Here are the requirements for successful use of DLIs:</p><ul><li><p>your DLI routine must save any registers it clobbers</p></li><li><p>restore any registers you save before exiting</p></li><li><p>exit with an <code>RTI</code></p></li><li><p>use <code>WSYNC</code> if necessary</p></li><li><p>be aware of cycles stolen by ANTIC: you could have only 60 cycles per scan line in higher resolution graphics modes, and as few as 10 (<strong>!</strong>) on the first line of text modes</p></li><li><p>store the address of your routine in <code>VDSLST</code> before enabling DLIs with <code>NMIEN</code></p></li><li><p>guard against the DLI itself being interrupted</p></li></ul><p>Note that nowhere in that list was the requirement that the DLI be short. It doesn‚Äôt have to be, and in fact DLIs that span multiple scan lines are similar to kernels used in Atari 2600 programming. The difference is that ANTIC steals cycles depending on a bunch of factors, so the total cycle counting approach (or <a class=link href=https://mitpress.mit.edu/books/racing-beam target=_blank rel=noopener>Racing the Beam</a>) is usually not possible.</p><p>However, most DLIs that you will run across in the wild <em>are</em> short, because they typically don‚Äôt do a lot of calculations. Most of the setup work will generally be done outside of the DLI and the DLI itself just handles the result of that work.</p><p><img src=https://playermissile.com/_static/Atari_logo_hr.png loading=lazy></p><h2 id=advanced-dli-examples>Advanced DLI Examples</h2><p>The following examples are available in both source code form and as XEX files at the <a class=link href=https://github.com/playermissile/dli_tutorial target=_blank rel=noopener>dli_tutorial source code repository</a> on github.</p><p>They are coded using MAC/65 assembler syntax, but very few assembler-specific features are actually used, so they should be trivially ported to other assemblers.</p><p>To get a copy of all the examples and source code, you can download and install <a class=link href=https://git-scm.com/ target=_blank rel=noopener>git</a> for your platform. Then open a command line prompt on your computer and enter the command: <code>git clone https://github.com/playermissile/dli_tutorial.git</code> to download the complete repository.</p><p>You can also download individual assembly source and XEX files from links in each section.</p><p>In an attempt to de-clutter the examples as much as possible, most of the boilerplate code (for initialization and setup tasks) has been placed in libraries that are included during the compilation process. These are files like <code>util.s</code>, <code>util_dli.s</code> and so forth, and are available in the source code repository or directly <a class=link href=https://github.com/playermissile/dli_tutorial/src target=_blank rel=noopener>here</a>.</p><h2 id=1-multiple-dlis>#1: Multiple DLIs</h2><p>One of the problems with having a single DLI vector is: what do you do when you want to have more than one DLI?</p><p>Some techniques that you will see in the wild:</p><blockquote><ul><li><p>use <code>VCOUNT</code> to check where you are on screen and branch accordingly</p></li><li><p>increment an index value and use that to determine which DLI has been called</p></li><li><p>change the <code>VDLSTL</code> vector to point to the next DLI in the chain</p></li></ul></blockquote><p>Here‚Äôs an optimization of the last technique that can save some valuable cycles: put your DLIs in the same page of memory and only change the low byte.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> \*= (\* &amp; $ff00) + 256 ; next page boundary dli pha ; only using A register, so save it to the stack lda #$55 ; new background color sta WSYNC ; first WSYNC gets us to start of scan line we want sta COLBK ; change background color lda #&lt;dli2 ; point to second DLI sta VDSLST pla ; restore A register from stack rti ; always end DLI with RTI! dli2 pha ; only using A register, so save it to the stack lda #$88 ; new background color sta WSYNC ; first WSYNC gets us to start of scan line we want sta COLBK ; change background color pla ; restore A register from stack rti ; always end DLI with RTI! vbi lda #&lt;dli ; set DLI pointer to first in chain sta VDSLST lda #\&gt;dli sta VDSLST+1 jmp XITVBV ; always exit deferred VBI with jump here 
</span></span></code></pre></td></tr></table></div></div><p>This is a simplistic example, but keeping the high byte constant inside the DLI saves 6 cycles (by obviating the need for changing the high byte with <code>LDA #>dli2; STA VDLSTL+1</code>). That may be enough for this optimization to be useful.</p><h2 id=2-moving-the-dli-up-and-down-the-screen>#2: Moving the DLI Up and Down the Screen</h2><p>The DLI subroutine itself doesn‚Äôt directly know what scan line caused the interrupt because all DLIs are routed through the same vector at <code>VDLSTL</code>. The only trigger is in the display list: the DLI bit on the display list instruction.</p><p>The display list can be modified in place to move the DLI to different lines without changing any DLI code. The code to move the DLI should be performed in the vertical blank to prevent the display list from being modified as ANTIC is using it to create the display:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>move\_dli\_line ldx last\_dli\_line ; get line number on screen of old DLI lda dlist\_line\_lookup,x ; get offset into display list of that line number tax lda dlist\_first,x ; remove DLI bit and #$7f sta dlist\_first,x ldx dli\_line ; get line number on screen of new DLI stx last\_dli\_line ; remember lda dlist\_line\_lookup,x ; get offset into display list of that line number tax lda dlist\_first,x ; set DLI bit ora #$80 sta dlist\_first,x rts 
</span></span></code></pre></td></tr></table></div></div><p>The example allows the display list to be set on blank lines at the top of the display, and on the last mode 4 line in the display list which displays the background below the last mode 4 line on the screen.</p><h2 id=interlude-a-playermissile-graphics-refresher>Interlude: A Player/Missile Graphics Refresher</h2><p>Player/Missile Graphics is the sprite system provided by the GTIA: independently positioned overlays on the playfield graphics that don‚Äôt disturb the playfield.</p><p>Note</p><p>the word <em>sprite</em> in this sense wasn‚Äôt in use when the Atari was designed, and <a class=link href=https://graphics.fandom.com/wiki/Sprite target=_blank rel=noopener>several</a> <a class=link href=https://en.wikipedia.org/wiki/Sprite_%28computer_graphics%29 target=_blank rel=noopener>sources</a> <a class=link href=http://groups.google.com/group/comp.sys.ti/msg/73e2451bcae4d91a target=_blank rel=noopener>claim</a> that it was coined by the designers of the Texas Instruments TI 9918 graphics chip at about the same timeframe.</p><p>The GTIA provides 4 players with independent colors (from each other or the playfield) and 4 missiles with colors matching their respective player, or the 4 missiles can be combined into a 5th player with its own color (although this reuses one playfield color). The players are 8 bits wide and can be displayed as one, two, or four color clocks wide per bit. This corresponds a width on screen of 8, 16, and 32 color clocks, respectively. Widths for all players and missiles can be set independently.</p><p>Each player and missile can be positioned at an arbitrary horizontal location by setting a hardware register, but vertical positioning requires copying data to particular locations in the memory area reserved for it. Each player spans the height of the screen, and it is only the bit pattern in its storage area that determines what is drawn on a particular scan line.</p><p>Missiles are two bits wide each with all 4 missiles packed into a single byte for a particular scan line. Bit masking is required to set data for one missile without affecting the others.</p><p>The quick summary for our purposes is that horizontal repositioning of players is fast, it takes only a single store instruction. Vertical repositioning of player image data is slow, it requires copying memory around.</p><h2 id=3-multiplexing-players-vertically>#3: Multiplexing Players Vertically</h2><p>Reusing players (multiplexing) vertically is straightforward, meaning that a single player can be used to display arbitrary images at different vertical locations on the screen, provided that there is no vertical overlap.</p><p>Using the hardware <code>HPOSPn</code> or <code>HPOSMn</code> registers, the DLI will immediately change where ANTIC will draw the player or missile. The next time ANTIC draws the player on a scan line, it will use this new position.</p><p>in the appropriate player or missile X position register. This demo uses the page-alignment trick for the second DLI, and changes the position and size of the players at each interrupt.</p><p>This demo splits the screen vertically into 3 horizontal bands, A, B & C, with the players extending the full height of the screen and labeled 0 through 3. This example uses the VBI to set the players for band A, the <code>dli</code> routine is the bottom of band A (and the top of band B) and therefore sets the players for band B, and the <code>dli2</code> routine is the bottom of band B (and the top of band C) and controls the players for band C.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vbi lda #&lt;dli ; set DLI pointer to first in chain sta VDSLST lda #\&gt;dli sta VDSLST+1 lda #$40 ; set player positions and sizes ... sta HPOSP0 ; for the top of the screen lda #$60 sta HPOSP1 lda #$80 sta HPOSP2 lda #$a0 sta HPOSP3 lda #0 sta SIZEP0 sta SIZEP1 sta SIZEP2 sta SIZEP3 jmp XITVBV ; always exit deferred VBI with jump here \*= (\* &amp; $ff00) + 256 ; next page boundary dli pha ; only using A register, so save it to the stack lda #$55 ; new background color sta WSYNC ; first WSYNC gets us to start of scan line we want sta COLBK ; change background color lda #$30 ; change position and sizes of players sta HPOSP0 lda #$40 sta HPOSP1 lda #$50 sta HPOSP2 lda #$60 sta HPOSP3 lda #1 sta SIZEP0 sta SIZEP1 sta SIZEP2 sta SIZEP3 lda #&lt;dli2 ; point to second DLI sta VDSLST pla ; restore A register from stack rti ; always end DLI with RTI! dli2 pha ; only using A register, so save it to the stack lda #$84 ; new background color sta WSYNC ; first WSYNC gets us to start of scan line we want sta COLBK ; change background color lda #$40 ; change position and sizes of players sta HPOSP0 lda #$70 sta HPOSP1 lda #$90 sta HPOSP2 lda #$b0 sta HPOSP3 lda #3 sta SIZEP0 sta SIZEP1 sta SIZEP2 sta SIZEP3 pla ; restore A register from stack rti ; always end DLI with RTI! 
</span></span></code></pre></td></tr></table></div></div><p>In discussing the timing issues that cause errors at the band boundaries, the players in band A are positioned by the VBI, and so are in place from well off the top of the screen and are correctly positioned at the first scan line. Players 0, 1, and 2 are correct at the bottom of the band, but player 3 extends one scan line too far, into band B.</p><p>The top of band B shows both position and size errors. When the first DLI hits on the last scan line of the 6th line of text, the background color is changed at the <code>WSYNC</code> and ANTIC moves on to start drawing the first scan line of the 7th line of text (which is the first line of text in band B.) Players 0, 1, and 2 are positioned correctly, which means their horizontal positions were set before ANTIC reached that portion of the scan line. The 3rd player remains in the same position as it was in band A, meaning that its horizontal position wasn‚Äôt set in time. ANTIC had stolen enough cycles setting up the mode 4 font that the 6502 didn‚Äôt get a chance to process the <code>sta HPOS3</code> before ANTIC had to draw that portion of the scan line. Since the code sets sizes after the horizontal positions, none of the sizes are set until the 2nd scan line of band B.</p><p>The transition to band C with the <code>dli2</code> routine produces similar results, there just isn‚Äôt enough time with the <code>WSYNC</code> used for the color change <em>and</em> all the cycles stolen by ANTIC mode 4 to process the all of the player changes in the first scan line of the band. Players 0, 1, and 2 are moved, player 3 is not, and all 4 players don‚Äôt get the correct size until the 2nd scan line of the band.</p><p>It‚Äôs possible to imagine a scenario where a scan line of a player is not visible at all. For example, if player 3 above had been positioned very far to the right and <code>HPOSP3</code> was changed to move player 3 to the far left side, it could be possible that ANTIC has already drawn the left side of the screen but hadn‚Äôt yet reached the right side where player 3 had been positioned. Because <code>HPOSP3</code> is now showing that player 3 is on the left side of the screen, ANTIC would not draw it at its old location on the right side of the screen.</p><p>It‚Äôs also possible, with careful timing, to reuse a player on a single line. However, purposeful use of this would difficult given all the different horizontal locations of ANTIC‚Äôs cycle stealing.</p><p>Mode 4 was chosen (in all of its cycle-stealing glory) for these examples to get an idea of the worst-case scenerio. Taking out the <code>WSYNC</code> and the color change did allow enough time that both the positions and sizes were changed without visible artifacts:</p><p>but this is very simple code and the more real-world example in the next section will show that a buffer zone of several scan lines is necessary to make sure a player isn‚Äôt split across a band boundary or, as described above, even duplicating a line of the player or missing a scan line.</p><h2 id=4-multiplexing-with-horizontal-motion>#4: Multiplexing With Horizontal Motion</h2><p>Increasing the number of bands and adding independent player movement within each band requires some data structures and a DLI to control placement in each band.</p><p>The approach used in this example is to use a single DLI that uses an index value to determine which band it is operating within. This index value is used as an offset into arrays that hold the sprite X position, size, color, etc.</p><p>There are a lot of independently moving objects in this demo: 12 bands, each with 4 players. There are very obvious timing issues in most bands on the first scan line after the DLI as sometimes the hardware registers for a player hasn‚Äôt been updated fully until the second scan line.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>; same DLI routine is used for each band, the band\_dli\_index is used to set ; player information for the appropriate band dli\_band pha ; using A &amp; X txa pha inc band\_dli\_index ; increment band index, VBI initialized to $ff, ldx band\_dli\_index ; so will become 0 for band A ; control band X positions of players lda bandp0\_x,x ; x position of player 0 in this band sta HPOSP0 lda bandp0\_color,x ; color of player 0 for this band sta COLPM0 lda bandp0\_size,x ; size of player 0 for this band sta SIZEP0 lda bandp1\_x,x ; as above, but for players 1 - 3 sta HPOSP1 lda bandp1\_color,x sta COLPM1 lda bandp1\_size,x sta SIZEP1 lda bandp2\_x,x sta HPOSP2 lda bandp2\_color,x sta COLPM2 lda bandp2\_size,x sta SIZEP2 lda bandp3\_x,x sta HPOSP3 lda bandp3\_color,x sta COLPM3 lda bandp3\_size,x sta SIZEP3 ?done pla ; restore A &amp; X tax pla rti ; always end DLI with RTI! 
</span></span></code></pre></td></tr></table></div></div><p>The addreses <code>bandpN_x</code>, <code>bandpN_color</code>, and <code>bandpN_size</code> (where N is the player number) are declared as lists with the number of entries equal to the number of bands. <code>band_dli_index</code> is incremented each time the DLI starts, and uses that index into the lists so it places the players in the correct location for that band.</p><p>Notice that is <em>all</em> the DLI does. It does not calculate movement or perform any player logic, it simply puts players on the screen in the appropriate place for that band. All the calculation is done in the vertical blank:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>; calculate new positions of players in all bands vbi ldx #0 ?move lda bandp0\_x,x ; update X coordinate clc ; by adding velocity. adc bandp0\_dx,x ; Note that velocity of $ff sta bandp0\_x,x ; is same as -1 cmp #$30 ; check left edge bcs ?right ; if &gt;=, it is still in playfield lda #1 ; nope, &lt;, so make velocity positive sta bandp0\_dx,x bne ?cont ?right cmp #$c0 ; check right edge bcc ?cont ; if &lt;, it is still in playfield lda #$ff ; nope, &gt;=, so make velocity negative sta bandp0\_dx,x ?cont inx ; next player cpx #num\_dli\_bands \* 4 ; loop through 12 bands \* 4 players each bcc ?move lda #$ff ; initialize band index to get ready for band A sta band\_dli\_index jmp XITVBV ; always exit deferred VBI with jump here 
</span></span></code></pre></td></tr></table></div></div><p>Unlike the simple multiplexing demo in the previous section, this VBI does not set any positions of players. Instead, this demo sets the DLI bit on the last group of 8 blank lines at the beginning of the display list, before any mode 4 lines. This initial DLI will set the players for band A, and as you can see in the demo the players above band A use the same X position and size as band L. The colors are not the same as band L, however, because of the use of the shadow registers to set the initial color in the <code>init_pmg</code> subroutine.</p><h2 id=n-multiplexing-with-arbitrary-motion>#n: Multiplexing with Arbitrary Motion</h2><p>Vertical movement within bands requires the moving memory around the player/missile graphics area (pointed to by <code>PMBASE</code>) as in normal usage, with the following limitations:</p><blockquote><ul><li><p>players must stay within their assigned band, otherwise they will get split across bands when the DLI occurs.</p></li><li><p>players should avoid the first few scan lines below the top of the band boundary to prevent splitting</p></li><li><p>when moving a player vertically within a band, only erase data from that band to prevent affecting the multiplexed players in other bands</p></li></ul></blockquote><h2 id=n-multiplexing-with-collision-detection>#n: Multiplexing With Collision Detection</h2><p>If it is important to tell in which band a has collided occurred, the DLI that starts a new band will be required to save the collision status registers, which will determine if a collision happened in the <em>previous</em> band. It will then reset the collision registers so the following DLI can check what happened in this band.</p><p>If the knowledge of the band is not important, you can just check the collision registers in the vertical blank, which will report if there have been any collisions with anything in any band.</p><h2 id=n-multiplexing-players-horizontally>#n: Multiplexing Players Horizontally</h2><p>Reusing players on the same scan line is possible, but its usefulness may be limited to mostly static cases.</p><p>from Hacker News <a class=link href=https://ift.tt/361GQA7 target=_blank rel=noopener>https://ift.tt/361GQA7</a></p></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><footer class=site-footer><section class=copyright>&copy;
2020 -
2022 ZYChimne</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.11.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#a-crash-course-on-displays>A Crash Course on Displays</a><ol><li><a href=#how-interlacing-works-with-some-hand-waving-and-why-we-ignore-it>How Interlacing Works (With Some Hand Waving) and Why We Ignore It</a></li><li><a href=#how-color-works-and-theres-more-hand-waving-isnt-there>How Color Works and There‚Äôs More Hand Waving, Isn‚Äôt There?</a></li><li><a href=#how-the-cpu-frequency-was-chosen-and-why-is-there-even-more-hand-waving-oh-author-person>How The CPU Frequency Was Chosen and Why Is There Even More Hand Waving, Oh Author Person?</a></li></ol></li><li><a href=#a-crash-course-on-display-lists>A Crash Course on Display Lists</a><ol><li><a href=#display-list-instruction-set>Display List Instruction Set</a></li><li><a href=#a-sample-display-list>A Sample Display List</a></li><li><a href=#cycle-stealing-by-antic>Cycle Stealing by ANTIC</a></li></ol></li><li><a href=#a-crash-course-on-display-list-interrupts>A Crash Course on Display List Interrupts</a><ol><li><a href=#hardware--shadow-registers>Hardware & Shadow Registers</a></li><li><a href=#a-simple-example>A Simple Example</a></li><li><a href=#a-simple-example-with-wsync>A Simple Example with WSYNC</a></li><li><a href=#a-dli-can-affect-many-scan-lines>A DLI Can Affect Many Scan Lines</a></li></ol></li><li><a href=#a-crash-course-on-display-list-interrupts-getting-interrupted>A Crash Course on Display List Interrupts Getting Interrupted</a><ol><li><a href=#dli-interrupting-another-dli>DLI Interrupting Another DLI</a></li><li><a href=#emulator-differences>Emulator Differences</a></li><li><a href=#vbi-interrupting-a-dli>VBI Interrupting A DLI</a></li><li><a href=#dli-on-the-jvb-instruction>DLI on the JVB Instruction</a></li></ol></li><li><a href=#dlis-in-a-nutshell>DLIs in a Nutshell</a></li><li><a href=#advanced-dli-examples>Advanced DLI Examples</a></li><li><a href=#1-multiple-dlis>#1: Multiple DLIs</a></li><li><a href=#2-moving-the-dli-up-and-down-the-screen>#2: Moving the DLI Up and Down the Screen</a></li><li><a href=#interlude-a-playermissile-graphics-refresher>Interlude: A Player/Missile Graphics Refresher</a></li><li><a href=#3-multiplexing-players-vertically>#3: Multiplexing Players Vertically</a></li><li><a href=#4-multiplexing-with-horizontal-motion>#4: Multiplexing With Horizontal Motion</a></li><li><a href=#n-multiplexing-with-arbitrary-motion>#n: Multiplexing with Arbitrary Motion</a></li><li><a href=#n-multiplexing-with-collision-detection>#n: Multiplexing With Collision Detection</a></li><li><a href=#n-multiplexing-players-horizontally>#n: Multiplexing Players Horizontally</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>